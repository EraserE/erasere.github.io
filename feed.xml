<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Eraser</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2024-03-20T01:24:01+00:00</updated> <author> <name>Eraser</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 Eraser </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Spring</title><link href="/posts/Spring/" rel="alternate" type="text/html" title="Spring" /><published>2023-03-22T22:34:00+00:00</published> <updated>2023-11-20T03:56:04+00:00</updated> <id>/posts/Spring/</id> <content src="/posts/Spring/" /> <author> <name>Eraser</name> </author> <category term="笔记" /> <summary> Spring 基础 1. Spring特性 从Spring框架的特性来看，有以下内容 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API； 控制反转：IOC指的是将对象的创建权交给Spring去创建。使用Spring之前，对象的创建都是用new来进行； 依赖注入：DI是指依赖的对象不需要手动调用set方法去设置。而是通过配置赋值； 面向切面编程：AOP 容器：Spring是一个容器，因为它包含并且管理应用对象的声明周期 组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用。在Spring中可以使用XML和Java注解来组合这些对象； 2. Spring组件 Spring框架的所有模块如下： Spring Core Container Spring的核心容器是其他模块建立的基础，由Beans模块，Co... </summary> </entry> <entry><title>Reactive Programming</title><link href="/posts/Reactive-Programming/" rel="alternate" type="text/html" title="Reactive Programming" /><published>2022-05-14T23:30:00+00:00</published> <updated>2022-05-14T23:30:00+00:00</updated> <id>/posts/Reactive-Programming/</id> <content src="/posts/Reactive-Programming/" /> <author> <name>Eraser</name> </author> <category term="笔记" /> <summary> Reactive Streams 基本概念 Java9开始，通过Reactive Streams和Flow API实现响应式编程。 Stream-Oriented Pub/Sub patterns 使用Pub-Sub模型，publisher负责发送消息，subscriber负责通知publisher自己可以接受多少消息并接受。 包含两个部分 Iterator: which applies a “pull model” where app subscriber(s) pull items from a publisher source. Observer: which applies a “push model” that reacts when a publisher source pushes an item to subscriber sink(s). Flow ... </summary> </entry> <entry><title>Serverless architecture</title><link href="/posts/Serverless-architecture/" rel="alternate" type="text/html" title="Serverless architecture" /><published>2022-03-25T06:00:00+00:00</published> <updated>2023-09-26T04:38:24+00:00</updated> <id>/posts/Serverless-architecture/</id> <content src="/posts/Serverless-architecture/" /> <author> <name>Eraser</name> </author> <category term="笔记" /> <summary> How the client app connects to api, lambda and DB Basic Lambda software is composed of a number of functions. Creating a serverless app with AWS Lambda is built upon event-based development, so a user’s action serves as a trigger that kickstarts backend and frontend response. For traditional three-tier client-oriented system, the client make a request to server, then the server side deals wi... </summary> </entry> <entry><title>JVM</title><link href="/posts/JVM/" rel="alternate" type="text/html" title="JVM" /><published>2022-03-22T06:00:00+00:00</published> <updated>2023-11-22T05:40:49+00:00</updated> <id>/posts/JVM/</id> <content src="/posts/JVM/" /> <author> <name>Eraser</name> </author> <category term="笔记" /> <summary> JVM 类加载 1. 类的生命周期 类加载的过程包括了加载，验证，准备，解析，初始化五个阶段。在这五个阶段中，加载，验证，准备和初始化这四个阶段发生的顺序是确定的，而解析阶段不一定。 加载 类的加载指查找并加载类的二进制数据。加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事： 通过一个类的全限定名来获取其定义的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 相对于启发阶段而言，类的加载阶段是可控性最强的阶段，因为开发人员可以使用系统提供的类加载器，也可以使用自定义的类加载器来完成加载。 加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而且在Java堆中也创建一个ja... </summary> </entry> <entry><title>计算机网络</title><link href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="alternate" type="text/html" title="计算机网络" /><published>2022-03-16T02:34:00+00:00</published> <updated>2023-10-24T02:53:01+00:00</updated> <id>/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id> <content src="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" /> <author> <name>Eraser</name> </author> <category term="笔记" /> <summary> 计算机网络 TCP 1. TCP基础 TCP全程传输控制协议，是面向连接的，可靠的，基于字节流的传输层通信协议。 面向连接：连接是一对一的，而不是和UDP一样可以一堆多； 可靠的：无论网络中出现了怎样的链路变化，TCP都能保证一个报文一定能到达接收端； 字节流：用户消息通过TCP传输时，消息可能会被操作系统分组成多个的TCP报文，如果接收方不知道消息的边界，是无法读取出有效信息的。TCP消息流有顺序，只有前一个TCP报文收到才能接受下一个报文。 TCP头部 TCP头部格式分为以下几部分： 序列号：在建立连接的时候由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次，就累加一次该数据字节数的大小，用来解决网络包的乱序问题。 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答号之后，可以认为在这个之前的数据已被... </summary> </entry> </feed>
