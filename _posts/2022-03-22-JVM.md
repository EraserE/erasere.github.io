---
title: JVM
date: 2022-03-22 01:00:00 -0500
categories: [笔记]
tags: [JVM]
pin: true
author: Eraser

toc: true
comments: true
typora-root-url: ../../eraseryao.github.io
math: false
mermaid: true
---

# JVM

## 类加载

### 1. 类的生命周期

类加载的过程包括了**加载，验证，准备，解析，初始化**五个阶段。在这五个阶段中，加载，验证，准备和初始化这四个阶段发生的顺序是确定的，而解析阶段不一定。

![img](/assets/blog_res/2022-03-22-JVM.assets/java_jvm_classload_2.png)

#### 加载

类的加载指查找并加载类的二进制数据。加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事：

- 通过一个类的全限定名来获取其定义的二进制字节流；
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

![img](/assets/blog_res/2022-03-22-JVM.assets/java_jvm_classload_1.png)

相对于启发阶段而言，类的加载阶段是可控性最强的阶段，因为开发人员可以使用系统提供的类加载器，也可以使用自定义的类加载器来完成加载。

加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而且在Java堆中也创建一个java.lang.Class对象，这样可以通过该对象访问方法区中的数据。

加载class文件有以下几种方式

- 从本地系统中直接加载；
- 通过网络下载class文件；
- 从zip，jar等归档文件中加载；
- 从专有数据库中加载；
- 将java源文件动态编译为class文件。

#### 连接

**验证：确保被加载类的正确性**

验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中所包含的信息符合当前虚拟机的要求。有以下四个检验动作

- 文件格式验证：验证字节流是否符合class文件格式的规范；
- 元数据验证：对字节码描述的信息进行语义分析；
- 字节码验证：确认程序语义是合法的，符合逻辑的；
- 符号引用验证：确保解析动作正确执行。

验证阶段很重要，但不是必须的，它对程序运行期没有影响。

**准备：为类的静态变量分配内存，并将其初始化为默认值**

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，**这些内存都将在方法区中分配**。

类变量是指static，不包括实例变量，实例变量会在对象实例化时随着对象一起分配到java堆中。

- 对于基本数据类型，类变量static和全局变量，如果不显式赋值，系统会默认赋值为0；

- static final同时修饰的变量以及局部static变量必须显式赋值，否则编译不通过；

- 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。

**解析：把类中的符号引用转换为直接引用**

解析是虚拟机将常量池内的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。

#### 初始化

初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始设定有两种方式：**声明类变量的直到初始值和使用静态代码块为类变量指定初始值**。

类初始化时机：

- 创建类的实例，也就是new；
- 访问某个类或接口的静态变量，或者对该静态变量赋值；
- 调用类的静态方法；
- 反射；
- 初始化某个类的子类，其父类也会被初始化；
- Java虚拟机启动时被标明为启动类的类。

#### 使用

类访问方法区内的数据结构的接口，对象是Heap区的数据。

#### 卸载

Java虚拟机将结束生命周期的几种情况：

- 执行了System.exit()方法；
- 程序正常结束；
- 程序在执行过程中遇到了一场或错误而终止；
- 由于操作系统出现错误而导致Java迅即进程终止。

### 2. 类的加载内存模型

![img](/assets/blog_res/2022-03-22-JVM.assets/java-basic-reflection-3.png)

## JVM运行时数据区

JVM内存大致分为**线程私有区域**和**线程共享区域**，其主要由5个部分组成，统称为**运行时数据区**:

![preview](/assets/blog_res/2022-03-22-JVM.assets/view.png)

虚拟机栈，本地方法栈，程序计数器是线程私有的，而方法区和堆区市共享的。栈帧的生命周期是和线程关联的。**方法区和堆区主要存放对象，数组等不具有确定性的数据。**

### 1. 程序计数器

程序计数器是当前线程正在执行的那条字节码指令的地址。如果当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`。在多线程情况下，其可以记录当前线程执行的位置，是唯一一个不会出现内存越界的区域。

### 2. 虚拟机栈

#### 定义

Java虚拟机栈是描述Java方法运行过程的内存模型。Java虚拟机会为每个即将运行的Java方法创建一块叫做栈帧的区域，用于存放该方法运行过程中的一些信息，如**局部变量表，操作数栈，动态链接，方法出口信息等。**

当方法运行过程中需要创建局部变量的时候，就将局部变量的值存入栈帧中的局部变量表中。

#### 局部变量表

定义为一个数字数组主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包含表**八大原始类型，对象引用，以及返回地址**。局部变量表容量大小是在编译期确定下来的。在栈帧中，与性能调优最密切。

#### 操作数栈

- **栈顶缓存技术**：由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理 CPU 的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。
- 每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好。32bit 类型占用一个栈单位深度，64bit 类型占用两个栈单位深度操作数栈。
- 并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问。

#### 方法的调用

- 静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接。
- 动态链接：如果被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接。

### 3. 本地方法栈

本地方法栈是为 JVM 运行 Native 方法准备的空间，用于管理本地方法的调用，是线程私有的。一个本地方法就是一个Java调用非Java代码的接口，这些接口包括与Java环境外交互或者与操作系统交互。

### 4. 堆区

#### 定义

对是用来**存放对象**的内存空间，几乎所有的对象都存储在堆中。

#### 特点

- **线程共享**，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。
- 在虚拟机**启动时创建**。
- 是**垃圾回收的主要场所**。
- 堆可分为**新生代**、**老年代**。
- 逻辑上连续，物理内存空间可以不连续。
- 主流情况下堆的大小可以扩展。

#### 内存划分

为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域：

- 新生代：新对象和没达到一定年龄的对象都在新生代；
- 老年代：被长时间使用的对象，老年代的内存空间比年轻代要大；
- 元空间：JDK1.8之前叫永久代：像一些方法中的操作临时对象等。JDK1.8之前是占用JVM内存，JDK1.8之后直接使用物理内存。

**年轻代**

年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为Minor GC。年轻代被分为三个部分：**Eden Memory**，和两个**Survivor Memory**，默认比例是8：1：1.

**老年代**

旧的一代内存包含那些经过许多轮GC后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集成为Major GC。

#### 对象在堆中的生命周期

- 在JVM的内存模型中，对被划分为新生代和老年代，新生代有**Eden区和Survivor区**，Survivor又由From Survivor和To Survivor组成。

- 当创建一个对象的时候，对象会被优先分配到新生代的Eden区，此时JVM会给对象定义一个**对象年轻计数器**。
- 当Eden空间不足的时候，JVM将执行新生代垃圾回收（Minor GC）
  - JVM会把存活的对象转移到Survivor中，并且对象年龄+1
  - 对象在Survivor中同样也会经历Minor GC，每经历一次Minor GC，对象年龄都会+1
- 如果分配的对象过多，对象会被直接分配到老年代。

### 5. 方法区

#### 定义

Java虚拟机定义方法区是堆的一个逻辑部分，其存放以下信息：

- 已经被虚拟机加载的类信息
- 常量
- 静态变量
- 即时编译器编译后的代码

#### 特点

方法区有以下特点：

- 线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。**整个虚拟机中只有一个方法区**。
- 永久代。方法区中的信息一般需要长期存在，而他又是堆的逻辑分区，因此用堆的划分方法，把方法区称为永久代。
- 内存回收效率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。
- 允许固定大小，也允许动态扩展。

#### 运行时常量池

##### 为什么需要常量池？

运行时常量池是方法区的一部分。一个有效的Class文件中除了包含类的版本信息，字段，方法以及接口的描述信息外。还有一项是**常量池表，包含各种字面量和对类型，域和方法的符号引用**。

Java中的Class需要数据支持，通常这种数据会很大以至于不能直接存储到Class文件中，不过可以存到常量池，包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。

**运行时常量池**

- 在加载类和结构到虚拟机后，就会创建对应的运行时常量池；
- 常量池表是Class文件的一部分，用于存储编译期生成的各种字面量和符号引用，**这部分内容将在类加载后存放到方法去的运行时常量池中**
- JVM为每个已加载的类型都维护一个常量池，池中的数据项和数组项一样通过索引访问；
- 运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括运行期解析后才能够获得的方法或字段引用。

## 垃圾回收

### 1. 哪些内存需要回收

JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性。而Java堆区和方法区的内存是动态的，需要进行垃圾回收。

### 2. 如何判断一个对象是垃圾

程序在运行过程中会创建对象，但当方法执行完成或这个对象使用完毕后，它便被定义成了垃圾，这时就需要用垃圾收集器将内存区域清理出来。

判定一个对象的存活与否，常见的算法有两种：**引用计数法** 和**可达性分析算法**。

(1) **引用计数法**：堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1，高效但是**无法处理循环引用**，现在基本已经抛弃。

(2) **可达性分析算法**：根搜索算法的中心思想，就是从某一些指定的根对象（GC Roots）出发，一步步遍历找到和这个根对象具有引用关系的对象，然后再从这些对象开始继续寻找，从而形成一个个的引用链（其实就和图论的思想一致），然后不在这些引用链上面的对象便被标识为引用不可达对象。

在Java中，可作为根对象包括下面几种：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI（Native方法）引用的对象；
- 活跃线程。

### 3.  引用类型

#### 强引用

创建一个对象并把这个对象赋给一个引用变量，普通 new 出来对象的变量引用都是强引用，有引用变量指向时永远不会被垃圾回收。

```java
Object obj = new Object();
```

#### 软引用

如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

#### 弱引用

非必需对象，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。

使用 WeakReference 类来实现弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

#### 虚引用

虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

使用 PhantomReference 来实现虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

### 4. 方法区回收判断

方法区主要回收的内容有：**废弃常量**和**无用的类**。 对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的ClassLoader已经被回收；
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 5. 常用垃圾回收算法

(1) **标记-清除法**：标记的过程其实就是上面的**可达性算法(根搜索)**所标记的不可达对象，当所有的待回收的“垃圾对象”标记完成之后，便进行第二个步骤：**统一清除**。优点是性能比较高，缺点是容易产生不连续的内存块。

![标记-清除算法](/assets/blog_res/2022-03-22-JVM.assets/1460000038256034.png)

(2) **标记-整理法**：该算法并不会直接清除掉可回收对象 ，而是让所有的对象都向一端移动，然后将端边界以外的内存全部清理掉。

![标记-整理算法](/assets/blog_res/2022-03-22-JVM.assets/1460000038256035.png)

(3) **复制算法**：复制算法将内存区域均分为了两块（记为S0和S1），而每次在创建对象的时候，只使用其中的一块区域（例如S0），当S0使用完之后，便将S0上面存活的对象全部复制到S1上面去，然后将S0全部清理掉。缺点是费内存。

![复制算法](/assets/blog_res/2022-03-22-JVM.assets/1460000038256037.png)

### 6. 分代收集

它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为**老年代（Tenured Generation）** 和 **新生代（Young Generation）**，在堆区之外还有一个代就是**永久代（Permanet Generation）(JDK1.8后移除)**。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

![堆内存示意图](/assets/blog_res/2022-03-22-JVM.assets/1460000038256033.png)

### 7. 垃圾收集器

#### 分类

在Java中，垃圾回收器按照执行机制分为四种类型：

1. 串行垃圾回收器（Serial Garbage Collector）；
2. 并行垃圾回收器（Parallel Garbage Collector）；
3. 并发标记扫描垃圾回收器（CMS Garbage Collector）；
4. G1垃圾回收器（G1 Garbage Collector）。

#### 收集器

HotSpot VM 提供了 7 种垃圾收集器，分别为：

**Serial**

串行收集器，是单线程的收集器，只会使用一个线程进行垃圾收集工作。

其优点是简单高效，没有线程交互的开销，因此拥有最高的单线程收集效率。

它是Client模式下默认的新生代收集器，因为在用户的桌面场景下，分配给虚拟机管理的内存一般来说不会很大。

**PraNew**

是串行收集器的多线程版本，是Server模式下虚拟机首选的新生代收集器。除了性能原因外，主要是因为除了Serial收集器，只有它能与CMS收集器配合工作。

**Parallel Scavenge**

是多线程收集器，目标是达到一个可控的吞吐量，它被称为吞吐量优先收集器。这里的吞吐量指CPU用于运行用户代码的时间占总时间的比值。

**Serial Old**

是Serial收集器的老年代版本。

**Parallel Old**

是Parallel Scavenge的老年代版本。

**CMS**

Concurrent Mark Sweep，Mark Sweep指的是标记-清除算法。

分为以下四个流程:

- 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度快，需要停顿；
- 并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿；
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动，需要停顿。
- 并发清除：不需要停顿。

其具有以下缺点：

- 吞吐量低，低停顿时间是以牺牲吞吐量为代价的。
- 无法处理浮动垃圾，浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，只能到下一次GC进行回收。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

**G1**

Garbage First，它是一款面向服务端应用的垃圾收集器，在多CPU和大内存场景下有很好的性能。

堆被分为新生代和老年代，其他收集器进行收集的范围都是整个新生代或者老年代，而G1可以直接对新生代和老年代一起回收。

G1把堆划分成多个大小相等的独立区域，新生代和老年代不再物理隔离。

其具备以下特点：

- 空间整合：张体看来是基于标记-整理算法实现的收集器，从局部上来看是基于复制的算法实现的，这意味着收集过程中不会产生碎片。
- 可预测的停顿

#### 分代收集

- 新生代可配置的回收器：Serial、ParNew、Parallel Scavenge
- 老年代配置的回收器：CMS、Serial Old、Parallel Old

### 8. 内存泄露

#### 定义

对象已经没有被应用程序使用，但是垃圾回收器没法移除他们，因为还在被引用。这些对象具有以下特点：**首先，这些对象是可达的；其次，这些对象是无用的**。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。

![img](/assets/blog_res/2022-03-22-JVM.assets/webp)

#### 原因

根本原因是长生命周期的对象持有短生命周期对象的引用很可能发生内存泄漏。当短生命周期的对象已经不再需要，但是长生命周期持有他的引用而导致不能被回收，就发生了内存泄漏。

具体有以下几类：

1. 静态集合类引起内存泄漏
2. 监听器
3. 各种连接
4. 内部类和外部模块的引用
5. 单例模式

#### 避免

- 使用最新稳定版本的Java
- 尽量减少使用静态变量，使用完之后及时赋值 null，移除引用
- 明确对象的有效作用域，尽量缩小对象的作用域。局部变量回收会很快。
- 减少长生命周期对象持有短生命周期的引用
- 各种连接应该及时关闭（数据库连接，网络，IO等）
- 使用内存泄漏检测工具如MAT,Visual VM，jprofile 等
- 避免在代码中使用System.gc()
- 避免使用内部类