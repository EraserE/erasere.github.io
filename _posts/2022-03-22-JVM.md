---
title: JVM
date: 2022-03-22 01:00:00 -0500
categories: [笔记]
tags: [JVM]
pin: true
author: Eraser

toc: true
comments: true
typora-root-url: ../../eraseryao.github.io
math: false
mermaid: true
---

# JVM

## JVM内存模型

JVM内存大致分为**线程私有区域**和**线程共享区域**，其主要由5个部分组成:

![preview](/assets/blog_res/2022-03-22-JVM.assets/view.png)

虚拟机栈，本地方法栈，程序计数器是线程私有的，而方法区和堆区市共享的。栈帧的生命周期是和线程关联的。**方法区和堆区主要存放对象，数组等不具有确定性的数据。**

### 1. 程序计数器

程序计数器是当前线程正在执行的那条字节码指令的地址。如果当前线程正在执行的是一个本地方法，那么此时程序计数器为`Undefined`。在多线程情况下，其可以记录当前线程执行的位置，是唯一一个不会出现内存越界的区域。

### 2. 虚拟机栈

#### 定义

Java虚拟机栈是描述Java方法运行过程的内存模型。Java虚拟机会为每个即将运行的Java方法创建一块叫做栈帧的区域，用于存放该方法运行过程中的一些信息，如**局部变量表，操作数栈，动态链接，方法出口信息等。**

当方法运行过程中需要创建局部变量的时候，就将局部变量的值存入栈帧中的局部变量表中。

#### 局部变量表

定义为一个数字数组主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包含表**八大原始类型，对象引用，以及返回地址**。局部变量表容量大小是在编译期确定下来的。在栈帧中，与性能调优最密切。

#### 操作数栈

- **栈顶缓存技术**：由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理 CPU 的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。
- 每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好。32bit 类型占用一个栈单位深度，64bit 类型占用两个栈单位深度操作数栈。
- 并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问。

#### 方法的调用

- 静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接。
- 动态链接：如果被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接。

### 3. 本地方法栈

本地方法栈是为 JVM 运行 Native 方法准备的空间。

### 4. 堆区

#### 定义

对是用来**存放对象**的内存空间，几乎所有的对象都存储在堆中。

#### 特点

- **线程共享**，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。
- 在虚拟机**启动时创建**。
- 是**垃圾回收的主要场所**。
- 堆可分为**新生代**、**老年代**。
- 逻辑上连续，物理内存空间可以不连续。
- 主流情况下堆的大小可以扩展。

#### 新生代与老年代

- 老年代比新生代生命周期长。
- 新生代与老年代空间默认比例 `1:2`

#### 四种引用方式

- 强引用：创建一个对象并把这个对象赋给一个引用变量，普通 new 出来对象的变量引用都是强引用，有引用变量指向时永远不会被垃圾回收。
- 软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。
- 弱引用：非必需对象，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。
- 虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

### 5. 方法区

#### 定义

Java虚拟机定义方法区是对的一个逻辑部分，其存放以下信息：

- 已经被虚拟机加载的类信息
- 常量
- 静态变量
- 即时编译器编译后的代码

#### 特点

方法区有以下特点：

- 线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。**整个虚拟机中只有一个方法区**。
- 永久代。方法区中的信息一般需要长期存在，而他又是堆的逻辑分区，因此用堆的划分方法，把方法区称为永久代。
- 内存回收效率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。
- 允许固定大小，也允许动态扩展。

#### 运行时常量池

方法区中存放：类信息，常量，静态变量，即时编译器编译后的代码。

## 垃圾回收

### 1. 哪些内存需要回收

JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性。而Java堆区和方法区的内存是动态的，需要进行垃圾回收。

### 2. 如何判断一个对象是垃圾

程序在运行过程中会创建对象，但当方法执行完成或这个对象使用完毕后，它便被定义成了垃圾，这时就需要用垃圾收集器将内存区域清理出来。

判定一个对象的存活与否，常见的算法有两种：**引用计数法** 和**可达性分析算法**。

(1) **引用计数法**：堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1，高效但是**无法处理循环引用**，现在基本已经抛弃。

(2) **可达性分析算法**：根搜索算法的中心思想，就是从某一些指定的根对象（GC Roots）出发，一步步遍历找到和这个根对象具有引用关系的对象，然后再从这些对象开始继续寻找，从而形成一个个的引用链（其实就和图论的思想一致），然后不在这些引用链上面的对象便被标识为引用不可达对象。

在Java中，可作为根对象包括下面几种：

- 虚拟机栈中引用的对象（栈帧中的本地变量表）；
- 方法区中类静态属性引用的对象；
- 方法区中常量引用的对象；
- 本地方法栈中JNI（Native方法）引用的对象；
- 活跃线程。

### 3. 方法区回收判断

方法区主要回收的内容有：**废弃常量**和**无用的类**。 对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的ClassLoader已经被回收；
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 4. 常用垃圾回收算法

(1) **标记-清除法**：标记的过程其实就是上面的**可达性算法(根搜索)**所标记的不可达对象，当所有的待回收的“垃圾对象”标记完成之后，便进行第二个步骤：**统一清除**。优点是性能比较高，缺点是容易产生不连续的内存块。

![标记-清除算法](/assets/blog_res/2022-03-22-JVM.assets/1460000038256034.png)

(2) **标记-整理法**：该算法并不会直接清除掉可回收对象 ，而是让所有的对象都向一端移动，然后将端边界以外的内存全部清理掉。

![标记-整理算法](/assets/blog_res/2022-03-22-JVM.assets/1460000038256035.png)

(3) **复制算法**：复制算法将内存区域均分为了两块（记为S0和S1），而每次在创建对象的时候，只使用其中的一块区域（例如S0），当S0使用完之后，便将S0上面存活的对象全部复制到S1上面去，然后将S0全部清理掉。缺点是费内存。

![复制算法](/assets/blog_res/2022-03-22-JVM.assets/1460000038256037.png)

### 5. 分代收集

它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为**老年代（Tenured Generation）** 和 **新生代（Young Generation）**，在堆区之外还有一个代就是**永久代（Permanet Generation）(JDK1.8后移除)**。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

![堆内存示意图](/assets/blog_res/2022-03-22-JVM.assets/1460000038256033.png)

### 6. 垃圾收集器

在Java中，垃圾回收器按照执行机制分为四种类型：

1. 串行垃圾回收器（Serial Garbage Collector）；
2. 并行垃圾回收器（Parallel Garbage Collector）；
3. 并发标记扫描垃圾回收器（CMS Garbage Collector）；
4. G1垃圾回收器（G1 Garbage Collector）。

HotSpot VM 提供了 7 种垃圾收集器，分别为：

1. Serial
2. PraNew
3. Parallel Scavenge
4. Serial Old
5. Parallel Old
6. CMS
7. G1

- 新生代可配置的回收器：Serial、ParNew、Parallel Scavenge
- 老年代配置的回收器：CMS、Serial Old、Parallel Old

### 7. 内存泄露

#### 定义

对象已经没有被应用程序使用，但是垃圾回收器没法移除他们，因为还在被引用。这些对象具有以下特点：**首先，这些对象是可达的；其次，这些对象是无用的**。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。

![img](/assets/blog_res/2022-03-22-JVM.assets/webp)

#### 原因

根本原因是长生命周期的对象持有短生命周期对象的引用很可能发生内存泄漏。当短生命周期的对象已经不再需要，但是长生命周期持有他的引用而导致不能被回收，就发生了内存泄漏。

具体有以下几类：

1. 静态集合类引起内存泄漏
2. 监听器
3. 各种连接
4. 内部类和外部模块的引用
5. 单例模式

#### 避免

- 使用最新稳定版本的Java
- 尽量减少使用静态变量，使用完之后及时赋值 null，移除引用
- 明确对象的有效作用域，尽量缩小对象的作用域。局部变量回收会很快。
- 减少长生命周期对象持有短生命周期的引用
- 各种连接应该及时关闭（数据库连接，网络，IO等）
- 使用内存泄漏检测工具如MAT,Visual VM，jprofile 等
- 避免在代码中使用System.gc()
- 避免使用内部类