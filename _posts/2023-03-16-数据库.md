---
title: 数据库
date: 2022-03-16 10:34:00 +0800
categories: [笔记]
tags: [数据库]
pin: true
author: Eraser

toc: true
comments: true
typora-root-url: ../../eraseryao.github.io
math: false
mermaid: true
---

# 数据库

## MySQL

### 1. InnoDB引擎

MySQL采用**InnoDB引擎**，其兼具可靠性和高性能，其为多线程的模型。其主要优点有：

1. 其DML操作，即数据操作语言遵循ACID模型，具有提交，回滚和崩溃回复等功能，可以有效保护数据。
2. 行级锁定，表示只针对当前操作的行进行加锁，可以大大减少数据库的冲突，增加并发度。
3. 将数据安排在磁盘上，来优化基于主键的查询。而且每一个表都有主键索引。
4. 支持外键约束，来保持数据的完整性。

### 2. **SQL语句执行**

![mysql查询流程](/assets/blog_res/2023-03-16-%E6%95%B0%E6%8D%AE%E5%BA%93.assets/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

连接器：MySQL基于TCP，最大连接数由 max_connections 参数控制。

查询缓存：对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空，所以一般不用。

解析语句：词法分析和语法分析。

预处理器：查询表或字段是否存在，将*拓展为表上所有列。

优化器：确定SQL查询的执行方案，选择索引。

执行器：主键索引查询，全表扫描，索引下推。

### 3. **索引：数据的目录**

(1) 分类：

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

**B+树和B树区别，为什么用B+树**

B+Tree 只在叶子节点存储数据，而 B 树的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

二叉树只有两个叶子结点，层次太多，IO操作更频繁。

Hash 表不适合做范围查询，它更适合做等值的查询。

(2) **主键索引**（聚簇索引）和**二级索引**（辅助索引）

- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

当根据二级索引查询的时候，根据二级索引的B+树得到主键值，再用主键的B+树进行查找得到数据，这个操作叫做回表。当查询的数据可以在二级索引的B+树里查到，就叫做**覆盖索引**。

(3) **唯一索引**，**普通索引**和**前缀索引**

唯一索引可以有多个，可以为空值；普通索引可以重复，用INDEX(column,...)创建。

前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，用来减少储存空间。

(4) **联合索引**

将多个字段组合成一个索引，其B+树如下所示，叶子结点为双向链表：





![联合索引](/assets/blog_res/2023-03-16-%E6%95%B0%E6%8D%AE%E5%BA%93.assets/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png)

使用联合索引时遵循**最左匹配**原则，如果在查询到时候不遵循最左匹配原则，索引就会失效。在索引为(a,b,c)的情况下，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，**b 和 c 是全局无序，局部相对有序的**，如果查询时没有a，则会索引失效。

范围查询：

假设数据表中(a,b)作为联合主键，其范围查询分为以下几种情况

1. `SELECT * FROM <table> WHERE a>1 AND b=2`

   由于联合索引是根据a的顺序排序的，所以先按照a的范围进行索引查询，程序找到a>1的部分

(4) 索引优化：前缀索引优化，覆盖索引优化，主键自增，防止索引失效。**索引下推优化**（index condition pushdown)， **可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**。

3. ### 事务

事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。事务具有以下四个特性(ACID)：

- **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。
- **一致性（Consistency）**：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。
- **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。
- **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

事务的隔离级别：

- **读未提交（read uncommitted）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（read committed）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（repeatable read）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **串行化（serializable）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

4. ### 日志

- **undo log（回滚日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。
- **redo log（重做日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要**用于掉电等故障恢复**；
- **binlog （归档日志）**：是 Server 层生成的日志，主要**用于数据备份和主从复制**；

## Redis

1. ### 基础

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存，消息队列、分布式锁等场景**。

Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是**原子性**的，因为执行命令由单线程负责的，不存在并发竞争的问题。

2. ### Redis用作MySQL的缓存

Redis 具备高性能，将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

Redis 具备高并发，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

3. ### Redis数据结构

常见的有五种数据类型：**String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）**

![Redis数据类型](/assets/blog_res/2023-03-16-%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)



4. ### Redis线程

**Redis 单线程指的是「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个线程（主线程）来完成的**。但是**Redis 程序并不是单线程的**，Redis 在启动的时候，是会**启动后台线程**（BIO）

单线程模式



![redis单线程模型](/assets/blog_res/2023-03-16-%E6%95%B0%E6%8D%AE%E5%BA%93.assets/redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png)



5. ### Redis持久化

当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。

Redis 共有三种数据持久化的方式：

- **AOF 日志**：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
- **RDB 快照**：将某一时刻的内存数据，以二进制的方式写入磁盘；
- **混合持久化方式**：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；

(1) AOF日志实现：

Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。在主线程中执行

Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处：

**避免额外的检查开销**，**不会阻塞当前写操作命令的执行**。

但是也有风险：

**数据可能会丢失**，**可能阻塞其他操作**。

(2) RBF快照：

AOF 日志记录的是操作命令，不是实际的数据，恢复的时候和能会很慢。RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据。

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：

- 执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，**会阻塞主线程**；
- 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以**避免主线程的阻塞**；

6. ### Redis集群

(1) 主从复制

主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式

![主从复制](/assets/blog_res/2023-03-16-%E6%95%B0%E6%8D%AE%E5%BA%93.assets/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png)

(2) 哨兵模式

当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。哨兵模式做到了可以监控主从服务器，并且提供**主从节点故障转移的功能。**



![哨兵模式](/assets/blog_res/2023-03-16-%E6%95%B0%E6%8D%AE%E5%BA%93.assets/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png)

7. 缓存

当**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是**缓存雪崩**的问题。

如果缓存中的**某个热点数据过期**了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是**缓存击穿**的问题。

当用户访问的数据，**既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是**缓存穿透**的问题。

# B树/B+树

B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：

![图片](https://img-blog.csdnimg.cn/img_convert/b6678c667053a356f46fc5691d2f5878.png)

B+ 树与 B 树差异的点，主要是以下这几点：

- 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；
- 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；
- 非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。
- 非叶子节点中有多少个子节点，就有多少个索引；

# Hash算法

# Zookeeper

Design
• Provide a reusable solution.
• Provide a basic kernel or a coordination core upon with applications can build more sophisticated
coordination mode.
• Move away from the server-oriented model. Instead provide some APIs.
• Move away from blocking primitives so as not to slow down an entire service just because some
components are slow.
• Support for FIFO client request ordering and linearizable writes

Participants and Service Model
• Client: use of the Zookeeper service.
• Server: ensemble of replicated services for load balancing and fault tolerance.
• Session: client connects to the server to closing,
• znode: in memory data-object for client. Like traditional file system but not store much file.
	Ephemeral znode: Remain alive while in session and cleaned while close.
	Regular znode: created by user and root node maintained by Zookeeper service

