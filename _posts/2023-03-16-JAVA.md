---
title: JAVA
date: 2022-03-16 10:34:00 +0800
categories: [笔记]
tags: [JAVA]
pin: true
author: Eraser

toc: true
comments: true
typora-root-url: ../../eraseryao.github.io
math: false
mermaid: true
---

# JAVA

## String/List/Hashmap（红黑树/链表）

### 1. 字符串

#### 概述

(1) String 类声明为 final的，**不可被继承**。

(2) String实现了Serializable接口：表示字符串是支持序列化的；实现了Comparable接口：表示String可以比较大小。

#### 底层存储

JDK8及以前底层使用final char[]数组；

JDK9及以后改用final byte[]数组。

改用final byte[]是为了节省空间 (char占2个字节，而byte只用占用1个字节）

#### Java中的String具有不可变性

(1) 如下操作需要生成新的字符串，而不是修改原有的字符串

- ﻿﻿对现有的字符串进行连接操作时
- ﻿﻿对字符串重新赋值时
- ﻿﻿调用String的replace()方法修改指定字符或字符串时

(2) 如何保证String的不可变性？

- char[]使用final修饰-＞无法指向新的char[]数组

- String内部没有提供修改的方法 -＞内容不会变

(3) 为什么将String设计为不可变？

- 字符串在实际的开发中使用太频繁，为了提高执行效率，把字符串放到了方法区的字符串常量池当中

- 不可变字符串，使得编译器可以让字符串共享

#### 字符串常量池

(1) 常量池中不会存在相同内容的常量

(2) 通过字符串字面量赋值时，数据是在常量池中

(3) String Pool是一个固定大小的 Hashtable（不会扩容）

- ﻿﻿数组+链表的哈希表（拉链法解决hash冲突）

- ﻿﻿使用StringTableSize可设置StringTable的长度

#### 字符串拼接操作

常量与常量的拼接结果在常量池 （原理是编译期优化）

只要其中有一个是变量，结果就在堆中（变量拼接的原理是 String Builder)

如果拼接的结果调用 intern()方法（将字符串添加到字符常量池中），则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。

### 2. Java容器

#### Set

1. **TreeSet**

   无序，不可重复，自动排序

   存放在TreeSet中相当于存放到TreeMap中的key部分

2. **HashSet**

   无序，不可重复，支持快速查找

3. **LinkedHashSet**

   基于双向链表实现，具有 Hashset 的查找效率。

#### Queue

1. **LinkedList**

   可以实现双向队列。

2. **PriorityQueue**

   基于堆结构实现，可以实现优先队列。

### 3. List

![_Java_List_溯风](/assets/blog_res/2023-03-16-JAVA.assets/_Java_List_%E6%BA%AF%E9%A3%8E.png)

### 4. HashMap

(1) HashMap 底层是一个数组；

(2) 数组中每个元素是一个单向链表(即，采用拉链法解决哈希冲突)；

单链表的节点每个节点是 Node<K, V> 类型；

(3) 同一个单链表中所有Node的hash值不一定一样，但是他们对应的数组下标一定一样；

数组下标利用哈希函数/哈希算法根据 hash值计算得到的；

(4) HashMap 是数组和单链表的结合体

数组查询效率高，但是增删元素效率较低；

单链表在随机增删元素方面效率较高，但是查询效率较低；

HashMap 将二者结合起来，充分它们各自的优点；

(5) HashMap 特点

无序、不可重复；

无序:因为不一定挂在那个单链表上了

(6) 为什么不可重复？

通过重写 equals 方法保证的。

JDK 1.8 之后，对 HashMap 底层数据结构(单链表)进行了改进，如果单链表元素超过8个，则将单链表转变为红黑树; 如果红黑树节点数量小于6时，会将红黑树重新变为单链表。

### 5. HashMap，HashTable，ConcurrentHashMap线程安全：

**HashMap 是线程不安全的**。

在多线程条件下，容易导致死循环。JDK 1.8 HashMap 采用数组 + 链表 + 红黑二叉树的数据结构，优化了 1.7 中数组扩容的方案，解决了 Entry 链死循环和数据丢失问题。但是多线程背景下，put 方法存在数据覆盖的问题。

**HashTable是线程安全的**。

在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。特别地，在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设为16），及任意数量线程的读操作。 

**ConcurrentHashMap的高效并发机制是通过以下三方面来保证的：**

(1) 通过锁分段技术保证并发环境下的写操作；

(2) 通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作；

(3) 通过不加锁和加锁两种方案控制跨段操作的的安全性。

### 6. String、StringBuilder、StringBuffer:

String 底层数组用 final 修饰，不可变。

StringBuilder 底层数组没有用 final 修饰，可变;线程不安全，效率高(一般用的多)

StringBuffer 底层数组没有用 final 修饰，可变;线程安全，效率低(一般用的少)

## 线程池

### 1. 线程和进程的区别

进程是对运行时程序的封装，是**系统进行资源调度和分配的的基本单位，实现了操作系统的并发**；

线程是进程的子任务，**是CPU调度和分派的基本单位**，**用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位**。每个线程都独自占用一个**虚拟处理器**：独自的**寄存器组**，**指令计数器和处理器状态**。每个线程完成不同的任务，但是**共享同一地址空间**（也就是同样的**动态内存，映射文件，目标代码等等**），**打开的文件队列和其他内核资源**。

线程在进程下行进（单纯的车厢无法运行）

一个进程可以包含多个线程（一辆火车可以有多个车厢）

不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）

同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）

进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）

进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）

进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）

进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"

进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

### 2. 线程池

**线程池（Thread Pool）**是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。

线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。

使用线程池可以带来一系列好处：

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

### 3. 线程池解决的问题

线程池解决的核心问题就是资源管理问题。

在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。

### 4. 核心设计与实现

Java中的线程池核心实现类是ThreadPoolExecutor，ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。

ThreadPoolExecutor运行机制如：

![图2 ThreadPoolExecutor运行流程](/assets/blog_res/2023-03-16-JAVA.assets/77441586f6b312a54264e3fcf5eebe2663494.png)

### 5. 线程池的创建

**通过Executors类提供的方法。**

1. **newCachedThreadPool**

   创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。

2. **newFixedThreadPool**

   创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。

3. **newScheduledThreadPool**

   创建一个周期性的线程池，支持定时及周期性执行任务。

4. **newSingleThreadExecutor**

   创建一个单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

**通过ThreadPoolExecutor类自定义。**

```Java
public ThreadPoolExecutor(int corePoolSize,
	int maximumPoolSize,
	long keepAliveTime,
	TimeUnit unit,
	BlockingQueue<Runnable> workQueue,
	ThreadFactory threadFactory,
	RejectedExecutionHandler handler) {
	// 省略...
}
```

## Java多线程

![_ThreadLocal思维导图_溯风](/assets/blog_res/2023-03-16-JAVA.assets/_ThreadLocal%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE_%E6%BA%AF%E9%A3%8E.png)

**僵尸进程**：一个**进程**使用fork创建子**进程**，如果子**进程**退出，而父**进程**并没有调用wait 或waitpid 获取子**进程**的状态信息，那么子**进程**的**进程**描述符仍然保存在系统中，这种**进程**称之为僵死**进程**。 

**孤儿进程**：一个父**进程**退出，而它的一个或多个子**进程**还在运行，那么这些子**进程**将成为**孤儿进程**。

## Java volatile

### 1. 概念

Volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。

### 2. volatile变量特性

(1) **保证可见性，不保证原子性**

当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；

这个写会操作会导致其他线程中的缓存无效。

(2) **禁止指令重排**

**重排序**在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。

### 3. volatile原理

volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。

## 死锁

一般来说，要出现死锁问题需要满足以下条件：

1. 互斥条件：一个资源每次只能被一个线程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

只要破坏死锁 4 个必要条件之一中的任何一个，死锁问题就能被解决。

## Java19新特性

1. **记录模式**（预览版）

使用 ***记录模式*** 增强 Java 编程语言以解构记录值，可以嵌套记录模式和类型模式，实现强大的、声明性的和可组合的数据导航和处理形式。

这是一个预览语言功能。

2. **Linux/RISC-V 移植**

将 JDK 移植到 Linux/RISC-V，目前仅支持 RISC-V 的 RV64GV 配置（包含向量指令的通用 64 位 ISA）。将来可能会考虑支持其他 RISC-V 配置，例如通用 32 位配置 (RV32G)。

3. **外部函数和内存 API （预览版）**

引入一个 API，Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过该 API 可有效地调用外部函数（ JVM 之外的代码）和安全地访问外部内存（不受 JVM 管理的内存），使得 Java 程序能够调用本机库并处理本机数据，而不会出现 JNI 的脆弱性和危险。

这是个预览版 API 。

4. **虚拟线程（预览版）**

将虚拟线程引入 Java 平台。虚拟线程是轻量级线程，可显著地减少编写、维护和观察高吞吐量并发应用程序的工作量。

虚拟线程 `java.lang.Thread` 是在底层操作系统线程（OS 线程）上运行 Java 代码，但在代码的整个生命周期内不捕获 OS 线程的实例。这意味着许多虚拟线程可以在同一个 OS 线程上运行 Java 代码，从而有效地共享它。

虚拟线程是由 JDK 而不是操作系统提供的线程的轻量级实现，也是**用户模式线程**的一种形式。用户模式线程在 Java 的早期版本中被称为 [“绿色线程”](https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FGreen_threads)，当时操作系统线程的概念还不够成熟和普及， Java 的所有绿色线程都共享一个 OS 线程（M:1 调度），随着线程概念的发展，绿色线程最终被现在的平台线程超越，实现为 OS 线程的包装器（1:1 调度），而最新引入的虚拟线程采用 M:N 调度，其中大量 (M) 虚拟线程被调度为在较少数量 (N) 的 OS 线程上运行。

5. **Vector API （第四次孵化）**

引入一个 API 来表达在运行时能够可靠编译的向量计算，在支持的 CPU 架构上优化向量指令，从而实现优于标量计算的性能。

6. **Switch 模式匹配（第三预览版）**

用 `switch` 表达式和语句的模式匹配，以及对模式语言的扩展来增强 Java 编程语言。将模式匹配扩展到 `switch` 中，允许针对一些模式测试表达式，这样就可以简明而安全地表达复杂的面向数据的查询。

该特性最早在 Java 17 中作为预览版出现， Java 19 为第三次预览。

7. **结构化并发（孵化阶段）**

引入用于结构化并发的 API 来简化多线程编程，结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。

这是一个孵化阶段的 API。

**Java 19创建platform thread**

`Runnable gcdRunnable = new GCDRunnable();`

`Thread thread = Thread .ofPlatform() .unstarted(gcdRunnable);`

**Structured Concurrency**：

为了让程序更易于读，理解，更快的写和更安全。

避免线程泄漏和孤儿线程，线程的生命周期都被限制在一个封闭的范围中。

模仿structured programming， 有明确的入口和出口点的执行流代码块；严格嵌套操作的生存期，以反映代码中的语法嵌套。

StructuredTaskScope是Structured Concurrency的基本接口，其定义了几个子类：ShutdownOnFailure和ShutdownOnSuccess。

## Docker

Docker的优势总结如下：

- 更快的启动时间。Docker容器启动是几秒钟的事情，因为容器只是一个操作系统进程而已。带有完整操作系统的虚拟机则需要几分钟来加载。
- 更快部署。不需要建立一个新的环境。使用Docker,Web开发团队只需要下载Docker镜像并在不同的服务器上运行。
- 容器更易管理与扩展。因为销毁与运行容器比销毁与运行虚拟机更快。
- 计算资源的更好利用，因为在一个服务器上你可以运行的容器比虚拟机要多。
- 支持多种操作系统，Windows,Mac,Debian等等。

## Zookeeper

### 1. 介绍

ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

### 2. 解决问题

在分布式系统中，以下问题经常出现：

- 确定Leader；
- 配置协调管理；
- 群组管理；
- 分布式锁。

### 3. 设计

- 顺序一致性，从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去。
- 原子性，所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。
- 单一视图，无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。
- 可靠性，一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直被保留，除非有另一个事务对其进行了变更。
- 实时性，Zookeeper 保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。

### 4. 组成

- 客户端: 使用Zookeeper服务，

- 服务器:用于负载平衡和容错的复制服务集成，

- 会话:客户端连接到服务器直到其关闭，

- Znode:客户端的内存数据对象。像传统的文件系统但不存储太多的文件。

  临时znode:在会话中保持活动，在关闭时进行清理。

  普通znode:由用户创建，由Zookeeper服务维护的根节点。



## Protobuf

Protobuf 是Google出品的序列化框架，与开发语言无关，和平台无关，具有良好的可扩展性。Protobuf和所有的序列化框架一样，都可以用于数据存储、通讯协议。

Protobuf支持生成代码的语言包括Java、Python、C++、Go、JavaNano、Ruby、C#, 泛用性广。

Portobuf的序列化的结果体积要比XML、JSON小很多，XML和JSON的描述信息太多了，导致消息要大；此外Portobuf还使用了Varint 编码，减少数据对空间的占用。

Portobuf序列化和反序列化速度比XML、JSON快很多，是直接把对象和字节数组做转换，而XML和JSON还需要构建成XML或者JSON对象结构。

