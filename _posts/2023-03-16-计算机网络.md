---
title: 计算机网络
date: 2022-03-16 10:34:00 +0800
categories: [笔记]
tags: [计算机网络]
pin: true
author: Eraser

toc: true
comments: true
typora-root-url: ../../eraseryao.github.io
math: false
mermaid: true
---

# 计算机网络

## TCP/IP

### 1. TCP基础

(1)  超时重传

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。

(2) 流量控制

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

(3) 拥塞控制

**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

于是，就有了**拥塞控制**，控制的目的就是**避免「发送方」的数据填满整个网络**。

### 2. TCP/IP模型（四层）

1. **应用层**：软件实现层面，HTTP、FTP、Telnet、DNS、SMTP等。
2. **传输层**：TCP/UDP。TCP是传输控制协议，相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。UDP 相对来说就很简单，简单到只负责发送数据包，传输效率高。可以在应用层实现TCP的功能。

3. **网络层**：IP/ICMP协议。数据部分+TCP/UDP头+IP头。

   IP地址有两种意义：

   - 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
   - 一个是**主机号**，负责标识同一「子网」下的不同主机；

   IP地址和子网掩码做**AND**运算得到网络号。

   IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。

4. **网络接口层**：MAC头部，包含了接收方和发送方的 MAC 地址。网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

Ping是由ICMP协议控制的。

### 3. 三次招手四次挥手

TCP的四元组可以确定唯一一个连接

![TCP四元组](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E5%9B%9B%E5%85%83%E7%BB%84.png)

(1) 三次握手

![TCP 三次握手](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态
- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
- 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态

**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**。

TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。

三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱**

第一次握手丢失会触发超时重传；第二次握手丢失客户端会认为第一次握手没有成功，也会触发超时重传。如果第三次握手丢失，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。

(2) 四次挥手

![TCP四次挥手](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-9008837.png)

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

解决TIME_WAIT状态过多的首要方法就是**避免服务器频繁主动断开连接**

解决 time_wait 状态大量存在，导致新连接创建失败的问题，一般解决办法：

1.客户端：HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间：现在的浏览器，一般都这么进行了

2.服务器端：

允许 time_wait 状态的 socket 被重用

缩减 time_wait 时间，设置为**1 MSL（即，2 mins）**

但是**等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包**。

### 4. TCP重传，滑动窗口，流量控制，拥塞控制

#### 重传机制

TCP在丢包的情况下会启动重传机制。

1. **超时重传**

   在发送数据时设定一个定时器，当超过指定时间后，没有收到对方的`ACK`确认应答报文，就会重发该数据。一般发生在：**数据包丢失，确认应答丢失**。

2. **快速重传**

   以数据为驱动重传。当收到**三个相同的ACK报文时**，就会在定时器过期之前，重传丢失的报文。但是无法判断该重传哪些TCP报文。

3. **SACK方法**

   即选择性确认，其在TCP头部选项字段里加一个`SACK`，他可以**将已经收到的数据信息发送给发送方**，这样发送方就知道哪些数据丢失，就可以只重传丢失的数据。

4. **Duplicated SACK**

   又称`D-SACK`，其主要使用了SACK来告诉发送方有哪些数据被重复接受了。一般用于ACK报文丢失的情况。

#### 滑动窗口

TCP每发送一个数据都要进行一次确认应答。但是当**往返时间越长，通信的效率越低**。为了解决这个问题，TCP引入了窗口的概念，窗口的大小就是**无需等待确认应答，而可以继续发送数据的最大值**。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答前，必须在缓冲区中保留已发送过的数据，如火安琪收到确认应答，此时数据就可以从缓存区清除。

窗口的大小由TCP头中的`Window`字段决定。**这个字段是接收方告诉发送端自己还有多少缓冲区可以接受数据**。

1. **发送方的滑动窗口**

   发送方的缓存窗口如下：

   ![img](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/16-0212323.jpg)

   当接收方确认5个字节的数据后，滑动窗口会往右移动5个字节。

   ![32 ~ 36 字节已确认](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/18-0212375.jpg)

2. **接收方的窗口**

   接收方窗口大小约等于发送方窗口大小，但不一定完全相等。

   ![接收窗口](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/20-0212424.jpg)

#### 流量控制

如果发送方发送数据不考虑接收方的能力，那么就会一直触发重传机制。为了解决这种现象的发生，**TCP提供一种机制可以让发送方根据接收方发实际接受能力控制发送的数据量，这就是流量控制。**

#### 拥塞控制

流量控制可以控制发送接收方，但无法知道网络中发生什么。**在网络出现拥堵时，如果继续发送大量数据包，可能导致数据包延时，丢失等，这时TCP就会重传数据，但是重传会导致网络负担更重**，所以为了避免上述情况，当网络发生拥塞时，TCP会降低数据发送量。**拥塞控制的目的是避免发送方的数据填满整个网络。**

**拥塞窗口** (**cwnd**)是发送方维护的一个状态变量，他会根据**网络的拥塞程度动态变化**。拥塞控制有以下四个算法：

1. **慢启动**

   **当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**

2. **拥塞避免**

   当前窗口超过慢启动门限`ssthresh`后会进入拥塞避免算法。**每当收到一个 ACK 时，cwnd 增加 1/cwnd**。

3. **拥塞发生**

   当发生超时重传，就会使用拥塞发生算法。

   - `ssthresh` 设为 `cwnd/2`，
   - `cwnd` 重置为 `1`

4. **快速恢复**

   - 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
   - 重传丢失的数据包；
   - 如果再收到重复的 ACK，那么 cwnd 增加 1；
   - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

## HTTP

### 1. HTTP解析

#### 解析URL

数据协议+web服务器+目录名/文件名

HTTP的请求报文和响应报文：

![HTTP消息格式](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.jpg)

#### DNS解析

通过解析URL生成HTTP消息后，需要**查询服务器域名对应的IP地址**。

在域名中，**越靠右**的位置表示其层级**越高**。其解析流程如下：

![DNS解析](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/DNS%E8%A7%A3%E6%9E%90.jpg)

#### 协议栈

应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分别是负责收发数据的 TCP 和 UDP 协议，下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

![协议栈](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/7.jpg)

**TCP**

TCP会给数据包加上TCP头部，而TCP数据部分存放着HTTP头部和数据。

**IP**

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。IP会加IP头部。

IP 中的 `ICMP` 协议和 `ARP` 协议。

- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP` 用于根据 IP 地址查询相应的以太网 MAC 地址。

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

**MAC**

用于两点传输。MAC包头的协议类型只是用IP协议和ARP协议。

发送方的MAC地址是写在网卡ROM里的。对于接收方，只需要告诉以太网对方的MAC地址，以太网就会把包发过去。

发送方可以查**路由表**来找到目标，然后把包发给Gateway中的IP地址。如果不知道对方MAC地址，就用ARP协议广播。

**网卡**

数字信号——>电信号

#### 交换机

交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，**交换机的端口不具有 MAC 地址**。

交换机有mac地址表映射网线端口。找不到对应的mac就广播发送。

广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

#### 路由器

路由器的接收与自己端口MAC地址匹配的包。然后根据路由表和包的IP来判断转发目标。得到目标IP后，再用ARP协议得到其MAC地址转发。

和交换机区别：

- 因为**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 而**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。

### 2. HTTP状态码

| 100  | Continue                        | 继续。客户端应继续其请求                                     |
| ---- | ------------------------------- | ------------------------------------------------------------ |
| 101  | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|      |                                 |                                                              |
| 200  | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201  | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202  | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203  | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204  | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205  | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206  | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|      |                                 |                                                              |
| 300  | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301  | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302  | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303  | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304  | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305  | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306  | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307  | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|      |                                 |                                                              |
| 400  | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401  | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402  | Payment Required                | 保留，将来使用                                               |
| 403  | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404  | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405  | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406  | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407  | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408  | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409  | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410  | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411  | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412  | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413  | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414  | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415  | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416  | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417  | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|      |                                 |                                                              |
| 500  | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501  | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502  | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503  | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504  | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505  | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

### 3. GET与POST区别

**GET的语义是从服务器获取指定资源；POST的语义是根据请求负荷（报文Body）对指定资源作出处理。**

对于安全和幂等，在HTTP协议中，所谓安全是指请求方法不会破坏服务器上的资源；而所谓幂等是指多次执行相同操作，结果都是相同的。

所以在安全和幂等方面：

- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

### 4. HTTP缓存

#### 实现方式

对于一些重复性请求，我们可以把这对请求-响应的数据都缓存在本地，那么下次就直接读取本地的数据，所以避免发送HTTP请求的方法是通过缓存技术。

HTTP的缓存实现方式分为**强制缓存**和**协商缓存**。

1. **强制缓存**

   强制缓存是指只要浏览器判断缓存没有过期，则直接使用浏览器本地缓存，决定权在浏览器这边。其是利用下面两个HTTP响应头部字段来实现的，他们表示资源在客户段缓存的有效期：

   - `Cache-Control`， 是一个相对时间；
   - `Expires`，是一个绝对时间；

   如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 。

   Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：

   - 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
   - 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
   - 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

2. **协商缓存**

   当请求返回304的时候，一般是服务端告诉浏览器可以使用本地缓存资源，这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。

   ![协商缓存](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E7%BC%93%E5%AD%98etag.png)

   上图为协商缓存的一个过程，所以协商缓存就是与服务端协商后，通过协商结果来判断是否使用本地缓存。

   协商缓存可以基于两种头部实现：

   (1) 请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现，这两个字段的意思是：

   - 响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
   - 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比，如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

   (2) 请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：

   - 响应头部中 `Etag`：唯一标识响应资源；
   - 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

   **协商缓存的这两个字段都需要配合强制缓存中的Cache-control字段来使用，只有在未能命中强制缓存的时候，才能发起协商缓存字段的请求**。

   下面是强制缓存和协商缓存的工作流程：

![工作流程](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/http%E7%BC%93%E5%AD%98.png)

### 5. HTTP和HTTPS

#### 两者的区别

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

#### HTTPS解决了HTTP的哪些问题

HTTPS在HTTP与TCP层之间加入了SSL/TLS协议，可以很好的解决HTTP不安全的风险

- **信息加密**：交互信息无法被窃取。
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示。
- **身份证书**：证明淘宝是真的淘宝网。

HTTPS通过**混合加密，摘要算法，数字证书**来保证通信的安全。

1. **混合加密**

   通过混合加密的方式可以保证信息的机密性。HTTPS采用的是对称加密和非对称加密结合的**混合加密**方式：

   - 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
   - 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据

2. **摘要算法+数字签名**

   为了保证内容不被篡改，我们要对内容计算出一个”指纹“，发给对方，然后对方收到后也对内容做一个“指纹”，与发来的指纹进行比较，来检查数据是否被篡改。

   **在计算机中会用到摘要算法来计算出内容的哈希值**，也就是内容的指纹。但是为了防止内容和指纹同时被篡改，要用到**非对称加密算法**来解决。一共有两个密钥，公钥和私钥。但是一般不会用非对称加密直接加密内容，比较耗费性能。

   所以非对称加密的用途主要在于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，我们常说的**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密**。

3. **数字证书**

   数字证书一般用来验证身份，其工作流程如下：

   ![数子证书工作流程](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)

#### HTTPS如何建立连接

SSL/TLS协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

