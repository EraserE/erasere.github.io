---
title: 计算机网络
date: 2022-03-16 10:34:00 +0800
categories: [笔记]
tags: [计算机网络]
pin: true
author: Eraser

toc: true
comments: true
typora-root-url: ../../eraseryao.github.io
math: false
mermaid: true
---

# 计算机网络

## TCP

### 1. TCP基础

TCP全程**传输控制协议**，是**面向连接的，可靠的，基于字节流**的传输层通信协议。

- 面向连接：连接是一对一的，而不是和UDP一样可以一堆多；
- 可靠的：无论网络中出现了怎样的链路变化，TCP都能保证一个报文一定能到达接收端；
- 字节流：用户消息通过TCP传输时，消息可能会被操作系统分组成多个的TCP报文，如果接收方不知道消息的边界，是无法读取出有效信息的。TCP消息流有顺序，只有前一个TCP报文收到才能接受下一个报文。

#### TCP头部

TCP头部格式分为以下几部分：

![TCP 头格式](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/format,png-20230309230534096-0474042.png)

- **序列号**：在建立连接的时候由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次，就累加一次该**数据字节数**的大小，**用来解决网络包的乱序问题**。
- **确认应答号**：指下一次期望收到的数据的序列号，发送端收到这个确认应答号之后，可以认为在这个之前的数据已被正常接受，**用来解决丢包问题**。
- **控制位**：
  - `ACK`：该位为1时，确认应答的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 1 。
  - `RST`：该位为1时，表示 TCP 连接中出现异常必须强制断开连接。
  - `SYN`：该位为1时，表示希望建立连接，并在其**序列号**的字段进行序列号初始值的设定。
  - `FIN`：该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。

#### TCP连接

**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket，序列号和窗口大小称为连接。**

TCP的四元组可以确定唯一一个连接

![TCP四元组](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E5%9B%9B%E5%85%83%E7%BB%84.png)

源地址和目标地址字段（32位）是在IP头部，作用是通过IP协议发送报文到对方主机。

源端口和目的端口字段（16位）是在TCP头部，作用是告诉TCP协议该把报文发送到哪个进程中。

#### TCP/UDP

UDP全称**用户数据报协议**，他不提供复杂的控制机制，利用IP提供面向无连接的通信服务。

UDP协议头部只有8个字节，分别是：源端口和目标端口号，包长度，校验和。

他们的区别如下：

1. **连接**

   TCP是面向连接的传输协议，在传输数据前要先建立连接；UDP不需要建立连接，即刻传输数据。

2. **服务对象**

   TCP是一对一的两点服务，仅支持一对一连接；UDP支持一对一，一对多，多对多的交互通信。

3. **可靠性**

   TCP是可靠的，数据可以无差错，不丢失，不重复，按顺序到达；UDP 是尽最大努力交付，不保证可靠交付数据。

4. **拥塞控制，流量控制**

   TCP拥有流量控制，拥塞控制的功能，保证传输数据的安全，UDP没有。

5. **首部开销**

   TCP的首部较长，会有一定的开销，首部在没有使用选项的大小是20字节；UDP首部较短，只有固定的8个字节，开销较小。

6. **传输方式**

   TCP是**流式传输**，没有边界，但是保证顺序和可靠。UDP是一个一个包发送是有边界的，但是可能丢包和乱序。

7. **分片**

   TCP的大小如果大于MSS大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP包。如果中途丢失了一个分片，只需要传输这个丢失的分片。

   UDP的数据如果大于MTU，则会在IP层进行分片，目标主机收到后，在IP层进行组装。

TCP和UDP可以共用同一个端口。当主机收到数据包的时候，可以在IP包头的协议号字段知道该数据包是TCP还是UDP，并发送给不同的模块。因此TCP和UDP的端口相互独立。

#### TCP特点

(1)  超时重传

重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。

(2) 流量控制

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。**

(3) 拥塞控制

**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

于是，就有了**拥塞控制**，控制的目的就是**避免「发送方」的数据填满整个网络**。

### 2. TCP/IP模型（四层）

1. **应用层**：软件实现层面，HTTP、FTP、Telnet、DNS、SMTP等。
2. **传输层**：TCP/UDP。TCP是传输控制协议，相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。UDP 相对来说就很简单，简单到只负责发送数据包，传输效率高。可以在应用层实现TCP的功能。

3. **网络层**：IP/ICMP协议。数据部分+TCP/UDP头+IP头。

   IP地址有两种意义：

   - 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
   - 一个是**主机号**，负责标识同一「子网」下的不同主机；

   IP地址和子网掩码做**AND**运算得到网络号。

   IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。

4. **网络接口层**：MAC头部，包含了接收方和发送方的 MAC 地址。网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

Ping是由ICMP协议控制的。

### 3. TCP三次握手

![TCP 三次握手](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态
- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
- 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态

**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**。

TCP 的连接状态在 Linux下可以通过 `netstat -napt` 命令查看。

#### 为什么是三次握手？

由之前的定义，TCP的连接包含**Socket，序列号和窗口大小**。保持三次连接可以防止重复连接，同步序列号以及减少资源浪费。

1. **防止重复连接**

   三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱**

   当客户端先发送了`SYN=90`的报文，但是此时客户端突然下线，而发送的`SYN`报文也因为网络原因造成拥塞，服务端没有及时收到。而现在客户端重新上线后，又发送了`SYN=100`的报文。此时如果旧的`SYN=90`的报文先到达服务端，假如没有第三次握手，服务端就会直接和旧的报文建立连接。而在三次握手的情况下，服务端会返回`SYN=90+1`给客户端，客户端收到后发现于预期`SYN=100+1`不符，于是向服务器发送`RST`主动终止旧的连接。

   所以TCP使用三次握手建立连接的**最主要原因就是防止「历史连接」初始化了连接**。

2. **同步序列号**

   TCP通信协议的双方，都要维护一个序列号，增加传输的可靠性。其有以下作用：

   - 接收方可以去掉重复数据；
   - 接收方可以按照序列号确认包的接受顺序；
   - 可以标识发送出去的数据包中，哪些是已被对方接收的。

   服务端接收到客户端的序列号，回应`ACK`并发送自己的序列号，客户端收到后再回应服务端`ACK`，这样可以确认两者都接收到各自的序列号。

3. **减少资源浪费**

   在第一点中，如果没有第三次握手，服务端建立了旧的连接，那么会发送大量无用数据包，占用网络资源。

所以，不使用两次握手和四次握手的原因：

- 两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

#### 序列号的初始化

每次建立TCP连接时，都需要初始化不同的序列号，这样的原因是，**为了防止历史报文被下一个相同的四元组的连接接收**，以及**防止TCP报文被伪造**。

#### 连接丢失

第一次握手丢失会触发超时重传；

第二次握手丢失客户端会认为第一次握手没有成功，也会触发超时重传。

如果第三次握手丢失，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。

### 4. TCP四次挥手

![TCP四次挥手](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-9008837.png)

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

解决TIME_WAIT状态过多的首要方法就是**避免服务器频繁主动断开连接**

解决 time_wait 状态大量存在，导致新连接创建失败的问题，一般解决办法：

1.客户端：HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间：现在的浏览器，一般都这么进行了

2.服务器端：

允许 time_wait 状态的 socket 被重用

缩减 time_wait 时间，设置为**1 MSL（即，2 mins）**

但是**等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包**。

#### 为什么挥手四次

服务器在收到客户端的`FIN`报文时，通常还会有等待完成的数据的发送和处理，所以服务端的`ACK`和`FIN`一般是分开发送。但在某些特定情况下，四次挥手也可以变为三次挥手。

#### 挥手丢失



### 5. TCP重传

TCP在丢包的情况下会启动重传机制。

1. **超时重传**

   在发送数据时设定一个定时器，当超过指定时间后，没有收到对方的`ACK`确认应答报文，就会重发该数据。一般发生在：**数据包丢失，确认应答丢失**。

2. **快速重传**

   以数据为驱动重传。当收到**三个相同的ACK报文时**，就会在定时器过期之前，重传丢失的报文。但是无法判断该重传哪些TCP报文。

3. **SACK方法**

   即选择性确认，其在TCP头部选项字段里加一个`SACK`，他可以**将已经收到的数据信息发送给发送方**，这样发送方就知道哪些数据丢失，就可以只重传丢失的数据。

4. **Duplicated SACK**

   又称`D-SACK`，其主要使用了SACK来告诉发送方有哪些数据被重复接受了。一般用于ACK报文丢失的情况。

### 6. 滑动窗口

TCP每发送一个数据都要进行一次确认应答。但是当**往返时间越长，通信的效率越低**。为了解决这个问题，TCP引入了窗口的概念，窗口的大小就是**无需等待确认应答，而可以继续发送数据的最大值**。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答前，必须在缓冲区中保留已发送过的数据，如火安琪收到确认应答，此时数据就可以从缓存区清除。

窗口的大小由TCP头中的`Window`字段决定。**这个字段是接收方告诉发送端自己还有多少缓冲区可以接受数据**。

1. **发送方的滑动窗口**

   发送方的缓存窗口如下：

   ![img](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/16-0212323.jpg)

   当接收方确认5个字节的数据后，滑动窗口会往右移动5个字节。

   ![32 ~ 36 字节已确认](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/18-0212375.jpg)

2. **接收方的窗口**

   接收方窗口大小约等于发送方窗口大小，但不一定完全相等。

   ![接收窗口](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/20-0212424.jpg)

### 7. 流量控制

如果发送方发送数据不考虑接收方的能力，那么就会一直触发重传机制。为了解决这种现象的发生，**TCP提供一种机制可以让发送方根据接收方发实际接受能力控制发送的数据量，这就是流量控制。**

### 8. 拥塞控制

流量控制可以控制发送接收方，但无法知道网络中发生什么。**在网络出现拥堵时，如果继续发送大量数据包，可能导致数据包延时，丢失等，这时TCP就会重传数据，但是重传会导致网络负担更重**，所以为了避免上述情况，当网络发生拥塞时，TCP会降低数据发送量。**拥塞控制的目的是避免发送方的数据填满整个网络。**

**拥塞窗口** (**cwnd**)是发送方维护的一个状态变量，他会根据**网络的拥塞程度动态变化**。拥塞控制有以下四个算法：

1. **慢启动**

   **当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**

2. **拥塞避免**

   当前窗口超过慢启动门限`ssthresh`后会进入拥塞避免算法。**每当收到一个 ACK 时，cwnd 增加 1/cwnd**。

3. **拥塞发生**

   当发生超时重传，就会使用拥塞发生算法。

   - `ssthresh` 设为 `cwnd/2`，
   - `cwnd` 重置为 `1`

4. **快速恢复**

   - 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
   - 重传丢失的数据包；
   - 如果再收到重复的 ACK，那么 cwnd 增加 1；
   - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

## IP



## HTTP

### 1. HTTP解析（网页请求过程）

#### 解析URL

数据协议+web服务器+目录名/文件名

HTTP的请求报文和响应报文：

![HTTP消息格式](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.jpg)

#### DNS解析

通过解析URL生成HTTP消息后，需要**查询服务器域名对应的IP地址**。

在域名中，**越靠右**的位置表示其层级**越高**。其解析流程如下：

![DNS解析](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/DNS%E8%A7%A3%E6%9E%90.jpg)

#### 协议栈

应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分别是负责收发数据的 TCP 和 UDP 协议，下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

![协议栈](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/7.jpg)

**TCP**

TCP会给数据包加上TCP头部，而TCP数据部分存放着HTTP头部和数据。

**IP**

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。IP会加IP头部。

IP 中的 `ICMP` 协议和 `ARP` 协议。

- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP` 用于根据 IP 地址查询相应的以太网 MAC 地址。

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

**MAC**

用于两点传输。MAC包头的协议类型只是用IP协议和ARP协议。

发送方的MAC地址是写在网卡ROM里的。对于接收方，只需要告诉以太网对方的MAC地址，以太网就会把包发过去。

发送方可以查**路由表**来找到目标，然后把包发给Gateway中的IP地址。如果不知道对方MAC地址，就用ARP协议广播。

**网卡**

数字信号——>电信号

#### 交换机

交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，**交换机的端口不具有 MAC 地址**。

交换机有mac地址表映射网线端口。找不到对应的mac就广播发送。

广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

#### 路由器

路由器的接收与自己端口MAC地址匹配的包。然后根据路由表和包的IP来判断转发目标。得到目标IP后，再用ARP协议得到其MAC地址转发。

和交换机区别：

- 因为**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 而**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。

### 2. HTTP状态码

| 100  | Continue                        | 继续。客户端应继续其请求                                     |
| ---- | ------------------------------- | ------------------------------------------------------------ |
| 101  | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|      |                                 |                                                              |
| 200  | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201  | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202  | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203  | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204  | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205  | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206  | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|      |                                 |                                                              |
| 300  | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301  | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302  | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303  | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304  | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305  | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306  | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307  | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|      |                                 |                                                              |
| 400  | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401  | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402  | Payment Required                | 保留，将来使用                                               |
| 403  | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404  | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405  | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406  | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407  | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408  | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409  | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410  | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411  | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412  | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413  | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414  | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415  | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416  | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417  | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|      |                                 |                                                              |
| 500  | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501  | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502  | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503  | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504  | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505  | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

### 3. HTTP字段

**Host字段**：

客户端发送请求时，用来指定服务器的域名；

**Content-Length字段**：

服务器在返回数据时会有此字段，用来表示本次回应的数据长度；

HTTP是基于TCP传输协议进行通信的，TCP协议会存在粘包的问题，**HTTP协议通过设置回车符，换行符作为HTTP header的边界，通过Content-Length作为HTTP body的边界来解决粘包的问题**。

**Connection字段**：

该字段最常用于客户端要求服务端使用HTTP长连接机制，以便请求其他复用。**HTTP长连接的特点是，只要一方没有明确提出断开连接，则保持TCP连接状态**。

HTTP/1.1版本默认都是长连接，但为了兼容老版本HTTP，需要指定`Connection`首部字段的值为`Keep-Alive`.

**Content-Type字段**

该字段用于回应服务器时，告诉客户端，本次数据是什么格式。

```text
Content-Type: text/html; Charset=utf-8
```

上面的类型表明，发送的是网页，而且编码是UTF-8。客户端请求的时候，可以用`Accept`字段声明自己接受哪些数据格式。

**Content-Encoding字段**

该字段说明数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

### 4. GET与POST区别

**GET的语义是从服务器获取指定资源；POST的语义是根据请求负荷（报文Body）对指定资源作出处理。**

GET的请求参数位置一般是写在URL中的，URL规定只能支持ASCII，所以GET请求只允许ASCII字符，而且浏览器会对URL的长度有限制（HTTP协议对URL的长度是没有限制的）。

POST请求携带数据的位置一般是写在抱文body中，body中可以是任意格式的数据，而且浏览器一般不限制大小。

对于安全和幂等，在HTTP协议中，所谓安全是指请求方法不会破坏服务器上的资源；而所谓幂等是指多次执行相同操作，结果都是相同的。

所以在安全和幂等方面：

- **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。

### 5. HTTP缓存

#### 实现方式

对于一些重复性请求，我们可以把这对请求-响应的数据都缓存在本地，那么下次就直接读取本地的数据，所以避免发送HTTP请求的方法是通过缓存技术。

HTTP的缓存实现方式分为**强制缓存**和**协商缓存**。

1. **强制缓存**

   强制缓存是指只要浏览器判断缓存没有过期，则直接使用浏览器本地缓存，决定权在浏览器这边。其是利用下面两个HTTP响应头部字段来实现的，他们表示资源在客户段缓存的有效期：

   - `Cache-Control`， 是一个相对时间；
   - `Expires`，是一个绝对时间；

   如果 HTTP 响应头部同时有 `Cache-Control` 和 `Expires` 字段的话，**Cache-Control 的优先级高于 Expires** 。

   `Cache-control` 选项更多一些，设置更加精细，所以建议使用 `Cache-Control` 来实现强缓存。具体的实现流程如下：

   - 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 `Cache-Control`，`Cache-Control` 中设置了过期时间大小；
   - 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
   - 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

2. **协商缓存**

   当请求返回304的时候，一般是服务端告诉浏览器可以使用本地缓存资源，这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。

   ![协商缓存](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E7%BC%93%E5%AD%98etag.png)

   上图为协商缓存的一个过程，所以协商缓存就是与服务端协商后，通过协商结果来判断是否使用本地缓存。

   协商缓存可以基于两种头部实现：

   (1) 请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现，这两个字段的意思是：

   - 服务器发回的HTTP响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
   - 客户端请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 `Last-Modified` 声明，则客户端再次发起请求的时候带上 `If-Modified-Since` 字段，值为其第一次请求时返回的 `Last-Modified` ，服务器收到请求后与被请求资源的最后修改时间进行对比，如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

   (2) 请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：

   - 响应头部中 `Etag`：唯一标识响应资源；
   - 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 `Etag`，则再次向服务器发起请求时，会将请求头 `If-None-Match` 值设置为 `Etag` 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

   第一种是根据时间实现的，第二种方法是根据唯一标识实现的，相对来说后者可以更加准确判断文件内容是否被修改，避免由于篡改时间导致的不可靠问题。

   如果第一次请求的时候服务器返回的HTTP头部同时有`Last-Modified`和`ETag`字段时，那么客户端下一次请求的时候，如果带上这两个值，则`ETag`的优先级更高，即服务端先会判断`ETag`是否变化，如果没变化再判断`Last-Modified`。`ETag`优先级更高的原因有下：
   
   1. 在没有修改文件的情况下最后修改时间也有可能会变，导致重复请求；
   
   2. 有些文件是在秒级以内修改的，`If-Modified`字段只能以秒为颗粒度检测，使用`ETag`就能保证一秒内刷新多次。
   
   3. 有些服务器不能精确获取文件修改时间。
   
   **协商缓存的这两个字段都需要配合强制缓存中的Cache-control字段来使用，只有在未能命中强制缓存的时候，才能发起协商缓存字段的请求**。
   
   下面是强制缓存和协商缓存的工作流程：

![工作流程](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/http%E7%BC%93%E5%AD%98.png)

### 6. HTTP版本

到目前为止，HTTP 常见到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。

#### HTTP/1.1

HTTP1.1最突出的特点是简单，灵活和易于扩展以及应用广泛和跨平台。

**简单**：HTTP报文的格式是head+body，头部信息也是key-value的简单形式，易于理解。

**灵活和易于扩展**：HTTP请求里的各类方法，URI/URL，状态码等都允许开发者自定义和补充；同时由于HTTP工作在应用层，则它的下层可以随意变化，比如HTTPS就是在HTTP和TCP层之间加了SSL/TLS安全协议。

**应用广泛和跨平台**：大家都用。

但是HTTP也有缺点，无状态，明文传输，不安全。

**无状态**：好处是服务器不用记忆HTTP的状态，可以减轻服务器负担；坏处就是服务器没有记忆能力，在完成有关联性的操作会非常麻烦。对于无状态问题，解决方法之一就是**Cookie**。

**明文传输**：用HTTPS解决。

HTTP1.1是基于TCP/IP，并且使用了**请求-应答**通信模式。其性能从以下三个方面来看：

1. **长连接**

   早期HTTP1.0有一个问题是，每发起一次请求都要建立一次TCP连接，并且是串行请求，增加了网络开销。在HTTP1.1时期，提出了长连接的通信方式，这种连接方式的特点是**只要一方没有明确提出断开连接，则保持TCP连接状态**。如果一方长时间没有数据交互，则HTTP会自动断开连接。

2. **管道网络传输**

   HTTP1.1采用了长连接的方式，这使得管道传输成为可能。管道网络传输指在同一个TCP连接中，客户端可以发起多个请求，只要第一个请求发出，不必等其回来，就可以发第二个请求，**减少响应时间**。但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。如果服务器在处理前面的请求耗时较长，那么后面的请求处理会被阻塞住，这称为**队头阻塞**。所以，**HTTP1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

3. **队头阻塞**

   请求-应答的模式会造成HTTP的性能问题，产生队头阻塞，所以HTTP1.1性能一般。

#### HTTP/2

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

其相比于HTTP/1.1有如下性能上的改进：

1. **头部压缩**

   如果你同时发出多个请求，他们具有相同或相似的头部，那么HTTP/2会消除重复的部分。这就是所谓的`HPACK`算法：**在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，之后就发送索引号，加快传输速度。**

2. **二进制格式**

   区别于HTTP/1.1的纯文本形式的报文，HTTP/2采用二进制格式，头部信息和数据都是二进制格式，统称为帧，**头信息帧（Headers Frame）和数据帧（Data Frame）**。

   计算机在收到报文后，无需进行转换，可以直接解析二进制报文，增加了数据传输效率。

3. **并发传输**

   HTTP/1.1是基于请求-响应模型的，同一个连接中，HTTP完成一个事物才能进行下一个，如果遇到响应迟迟不来，则会造成队头阻塞。

   HTTP/2引出了Stream概念，多个Stream复用在一条TCP连接。一个TCP连接包含多个Stream，每个Stream里可以包含一个或多个Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。

   **针对不同的HTTP请求用独一无二的Stream ID来进行区分，接收端可以通过Stream ID来有序组装成HTTP消息，不同Stream的帧可以是乱序发送的，因此可以并发不同的Stream，即交错发送请求和相应。**

   ![img](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-0390350.jpeg)

4. **服务器主动推送资源**

   服务器不仅是被动的响应，而是可以主动向客户端发起信息。客户端和服务端都可以建立Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。

   比如客户端在请求HTML网页时，服务端可以主动推送css文件，减少通信次数。

HTTP/2的缺陷有以下几点：

- HTTP/2在HTTP层面解决了请求和响应的阻塞问题，但是在TCP层面依然可能发生拥塞。
- HTTP/2通过多个请求复用一个TCP连接，一旦发生TCP丢包，就会阻塞住所有的HTTP请求。

**由于是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当前面的字节数据没有到达时，后收到的字节数据只能存放在内核缓冲区里**，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

#### HTTP/3

HTTP/2的队头阻塞是因为TCP，所以**HTTP/3把HTTP下层的协议改成UDP**。UDP协议可以不管发送顺序，也不用管丢包。不过，基于UDP的**QUIC协议**可以实现类似TCP的可靠传输。

QUIC协议有以下特点：

1. **无队头阻塞**

   QUIC协议也有类似HTTP/2 Stream的多路复用概念，也可以在同一条连接上并发传输多个Stream。QUIC也可以保证传输的可靠性，**当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题**。而HTTP/2只要有一个流阻塞，那么整个TCP连接都会受到阻塞。

2. **更快的连接建立**

   对于HTTP/1和HTTP/2协议，TCP和TLS是分层的，很难合并到一起，因此需要分批次握手，先TCP，再TLS。

   HTTP/3在传输前虽然需要QUIC协议握手，但握手过程只需要1RTT，握手的目的是确认双方的连接ID，连接迁移就是基于连接ID实现的。

   HTTP/3的QUIC协议并不与TLS协议分层，而是QUIC协议包含TLS，他自己的帧里会携带TLS的记录。

   ![HTTP/1 ~ HTTP/3](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/27-HTTP3-0450214.png)

3. **连接迁移**

   基于TCP传输的HTTP协议由四元组来确定一条TCP连接，那么当用户切换网络，比如WIFI到蜂窝网络，那么IP地址就会发生变化，就必须断开重连，而重连过程中又涉及多次握手，就会有延迟，连接迁移的成本就会高。

   而QUIC协议没有通过四元组的方式，而使用**连接ID**来标记通信的两个端点。客户端和服务端可以自行选择一组ID来表示自己，即使网络变化，只要仍保有上下文信息，就可以无缝切换连接。

   QUIC是新协议，可能会有适配性问题，会被当作普通UDP。

### 7. HTTP和HTTPS

#### 两者的区别

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

#### HTTPS解决了HTTP的哪些问题

HTTPS在HTTP与TCP层之间加入了SSL/TLS协议，可以很好的解决HTTP不安全的风险

- **信息加密**：交互信息无法被窃取。
- **校验机制**：无法篡改通信内容，篡改了就不能正常显示。
- **身份证书**：证明淘宝是真的淘宝网。

HTTPS通过**混合加密，摘要算法，数字证书**来保证通信的安全。

1. **混合加密**

   通过混合加密的方式可以保证信息的机密性。HTTPS采用的是对称加密和非对称加密结合的**混合加密**方式：

   - 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
   - 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

2. **摘要算法+数字签名**

   为了保证内容不被篡改，我们要对内容计算出一个”指纹“，发给对方，然后对方收到后也对内容做一个“指纹”，与发来的指纹进行比较，来检查数据是否被篡改。

   **在计算机中会用到摘要算法来计算出内容的哈希值**，也就是内容的指纹。但是为了防止内容和指纹同时被篡改，要用到**非对称加密算法**来解决。一共有两个密钥，公钥和私钥。

   这两个密钥是可以双向加解密的，公钥加密，私钥解密，是为了防止内容被篡改；而私钥加密，公钥解密是为了防止消息被冒充。但是一般不会用非对称加密直接加密内容，比较耗费性能。

   所以非对称加密的用途主要在于**通过「私钥加密，公钥解密」的方式，来确认消息的身份**，我们常说的**数字签名算法**，就是用的是这种方式，不过私钥加密内容不是内容本身，而是**对内容的哈希值加密**。

3. **数字证书**

   数字证书一般用来验证身份，其工作流程如下：

   ![数子证书工作流程](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)
   
   首先，服务器会把自己的公钥注册到数字证书认证机构，数字证书认证机构会用自己的私钥将服务器的公钥加密做数字签名，然后颁发数字证书。客户端在向服务端请求的时候拿到服务器的数字证书，使用预先内置的数字证书认证机构的公钥来验证服务器数字证书的真实性。然后从数字证书中获得服务器的公钥加密报文。

#### HTTPS如何建立连接

SSL/TLS协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

前两步就是SSL/TLS的握手阶段，TLS的握手阶段涉及四次通信。使用不同的密钥交换算法，握手流程也会不同。现在常用的密钥交换算法有两种：**RSA算法和ECDHE算法**。

基于RSA算法的TLS握手过程如下所示：

![HTTPS 连接建立过程](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-0268478.png)

详细流程如下：

1. **ClientHello**

   首先，由客户端向服务器发起 `ClientHello` 加密通信请求。

   在这一步，客户端主要向服务器发送一下信息：

   - 客户端支持的TLS协议版本；
   - 客户端产生的随机数，用于后续的会话加密；
   - 客户端支持的密码套件，如RSA加密。

2. **ServerHello**

   服务端收到客户端请求后，向客户端发出响应，包含以下内容：

   - 确认TLS版本，如果浏览器不支持，则关闭加密通信；
   - 服务器产生随机数，用于后面生成会话密钥；
   - 确认的密码套件，如RSA；
   - 服务器的数字证书。

3. **客户端回应**

   客户端在收到服务器的回应之后，首先通过浏览器或者操作系统中的CA公钥核实服务器数字证书的真实性。

   如果证书没有问题，客户端就会从证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

   - 一个随机数，会被服务器公钥加密；
   - 加密方法改变通知，表明之后都会用会话密钥加密通信；
   - 客户端握手结束通知，表示客户端的握手阶段已经结束。同时把之前的数据做个摘要，用来供服务端校验。

   **服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

4. **服务端最后的回应**

   服务端收到客户端的第三个随机数后，通过协商加密的算法，计算出本次通信的会话密钥；

   然后，向客户端发送最后的消息：

   - 加密算法改变的通知；
   - 服务器握手结束的通知，并将之前的数据做摘要给客户端校验。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

#### 数字证书签发

数字证书的签发过程大致如下：

![img](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C-0301938.png)

CA签发证书为上图左部分，首先CA会把持有者的公钥，用途，颁发者，过期时间等有效信息打包，对其进行Hash加密，将加密后的哈希值用自己的私钥进行加密，形成CA的认证签名。将信息和签名组合成证书。

而客户端在拿到签名后用公钥将CA的签名解密，得到Hash值，与证书中信息的Hash值进行比较，如果相同则校验通过。

证书一般有多个层级，是为了保证根证书的安全性。

#### HTTPS应用数据如何保持完整性

TLS在实现上分为**握手协议**和**记录协议**两层：

- 握手协议就是TLS的四次握手过程，负责协商加密算法和生成加密密钥；
- 记录协议负责保护应用数据并验证其完整性和来源，所以对HTTP数据加密使用的是记录协议。

TLS记录协议主要负责消息的压缩，加密及数据的认证，过程如下：

![img](/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE-0369425-0369446.png)

- 首先，消息会被分成许多更短的片段，然后分别对每个片段进行压缩；
- 接下来，经过压缩的片段会被加上消息认证码（MAC值，由Hash算法生成），这是为了保证完整性，并进行数据认证。通过MAC码可以识别出篡改，其中包含片段编码以防止重放攻击；
- 经过压缩的片段再加上消息认证码一起被对称加密；
- 最后，经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

#### HTTPS安全性

HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。

HTTPS抓包能实现就是抓包软件让客户端信任了他自己签发的证书，从而实现解包。