---
title: Spring
date: 2023-03-22 17:34:00 -0500
categories: [笔记]
tags: [Spring]
pin: true
author: Eraser

toc: true
comments: true
typora-root-url: ../../eraseryao.github.io
math: false
mermaid: true
---

# Spring

## 基础

### 1. Spring特性

从Spring框架的特性来看，有以下内容

- 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API；
- 控制反转：IOC指的是将对象的创建权交给Spring去创建。使用Spring之前，对象的创建都是用new来进行；
- 依赖注入：DI是指依赖的对象不需要手动调用set方法去设置。而是通过配置赋值；
- 面向切面编程：AOP
- 容器：Spring是一个容器，因为它包含并且管理应用对象的声明周期
- 组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用。在Spring中可以使用XML和Java注解来组合这些对象；

### 2. Spring组件

Spring框架的所有模块如下：

![img](/assets/blog_res/2022-03-22-Spring.assets/spring-framework-introduce-8.png)

#### Spring Core Container

Spring的核心容器是其他模块建立的基础，由Beans模块，Core核心模块，Context上下文模块和SpEL表达式语言模块组成。

- **Beans模块**：提供了框架的基础部分，包括控制反转和依赖注入。
- **Core核心模块**：封装了Spring框架的底层部分，包括资源访问，类型转换以及一些常用的工具类。
- **Context上下文模块**：建立在Core和Beans模块的基础上，基础Beans模块功能并添加资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播等。
- **SpEL模块**：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组等。

#### Data Access/Integration

数据访问/集成层包括JDBC，ORM，OXM，JMS和Transactions模块

- **JDBC模块**：提供了一个JDBC的样例模板，使用这些模板能消除冗长的JDBC编码还有必须的事务控制，能享受到Spring管理事务的好处。
- **ORM模块**：提供与流行的对象-关系映射框架无缝集成的API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。
- **OXM模块**：提供了一个支持Object/XML映射的抽象层实现。将Java对象映射成XML数据，或者将XML数据映射成Java对象。
- **JMS模块**：指Java消息服务，用于在两个应用之间或分布式系统中发送消息，进行异步通信。
- **Transactions事务模块**：支持编程和声明式事务管理。

#### Web模块

Spring的Web层包含以下组件：

- **Web模块**：提供了最基本的Web开发集成特性，例如多文件上传功能，使用的Servlet监听器和IOC容器初始化以及Web应用上下文。
- **Servlet模块**：提供了一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入，更简单的数据绑定，数据验证等。
- **WebSocket模块**：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建WebSocket Server，从而实现双向通讯。
- **WebFlux模块**：Spring WebFlux是Spring Framework5中引入的新的响应式web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范，Spring WebFlux用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。

#### AOP，Aspects，Instrumentation和Messaging

具体包含以下组件：

- **AOP模块**：提供了面向切面编程的实现，提供比如日志记录，权限控制，性能统计等通用功能和业务逻辑分离的技术，并且通过动态的把这些功能添加到需要的代码中来降低系统的耦合。
- **Aspects模块**：提供与AspectJ的集成，是一个强大且成熟的AOP框架。
- **Instrumentation模块**：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。
- **messaging模块**：提供了对消息传递体系结构和协议的支持。

#### Test模块

提供了对JUnit和TestNG测试的支持，还提供了一些基于Spring的测试功能。

#### @RestController vs @Controller

Controller只返回一个页面，而RestController只返回对象，其返回JSON或XML形式数据。

## IOC

IoC（控制反转）是一种设计思想，将原本在程序中手动创建对象的控制权，交由Spring框架管理。

**IOC容器**：

Spring用来实现IoC的载体，实际上就是个Map，存放的是各种对象。

工厂模式，我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

Spring时代一般用Xml文件来配置bean，后来Springboot直接用注解配置。

## AOP

即面向切面编程，其把功能分为核心业务功能，和周边功能

- **所谓的核心业务**，比如登录，增加数据，删除数据都叫核心业务
- **所谓的周边功能**，比如性能统计，日志，事务管理等等

周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面。

在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 "编织" 在一起，这就叫AOP。

我们将记录日志功能解耦为日志切面，它的目标是解耦。进而引出AOP的理念：就是将分散在各个业务逻辑代码中相同的代码通过**横向切割**的方式抽取到一个独立的模块中。

![img](/assets/blog_res/2022-03-22-Spring.assets/spring-framework-aop-4.png)

他将那些与业务无关，却为业务模块所共同调用的逻辑或责任（如事务处理，日志管理，权限控制等）封装起来。

### 目的

AOP能够减少那些与业务无关，却被业务模块共同调用的逻辑封装起来，从而减少系统的重复代码，降低模块间的耦合度，提高可拓展性。

## Spring事务

### 分类

编程式事务：代码中硬编码

声明式事务：基于XML的声明式事务和基于注解的事务

### 隔离级别

#### ISOLATION_DEFAULT

使用后端数据库默认隔离级别

#### ISOLATION_READ_UNCOMMITED

读未提交，允许读取尚未提交的数据，最低的隔离级别

#### ISOLATION_READ_COMMITED

读已提交，允许读取并发事务已提交的数据，可以阻止脏读

#### ISOLATION_REPEATALBE_READ

可重复读，对同一字段多次读取结果都是一致的，无法阻止幻读

#### ISOLATION_SERIAZABLE

串行化，效率较低

### 事务传播行为

![截屏2023-03-30 22.13.15](/assets/blog_res/2022-03-22-Spring.assets/%E6%88%AA%E5%B1%8F2023-03-30%2022.13.15.png)

### 设计模式

#### 工厂设计模式

Spring使用工厂模式通过BeanFactory，ApplicationContext创建Bean对象。

#### 代理设计模式

Spring AOP的功能实现。

#### 单例设计模式

Spring中的Bean默认都是单例的。

#### 模版方法模式

Spring中jdbcTemplate，hibernateTemplate等以template结尾等对数据库操作的类，他们就是用到了模版模式。

#### 包装器设计模式

项目需要连接多个数据库，而不同的客户每次访问就要访问不同的数据库，这种模式让我们可以根据客户的需求去动态切换不同的数据库。

#### 观察者模式

Spring事件驱动模型就是一个典型。

#### 适配器模式

Spring AOP增强或通知使用到了这个模式。

## Spring Bean

### 作用域

**singleton**

唯一bean实例，Spring中的bean默认都是单例的。

**prototype**

每次请求都会创建一个新的bean实例。

**request**

每一次HTTP请求都会产生一个新的bean，该bean仅在当前的HTTP request内有效。

**session**

每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。

**global-session**

全局session作用域，仅仅在给予portlet的web中才有意义，Spring5已经没有了。

### 单例bean线程安全

多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。

一般情况下，常用的Controller，Service，Dao这些Bean都是无状态的，无状态的bean不能保存数据，因此是线程安全的。

#### 解决方法

在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中。

改变Bean的作用域为“prototype”：每次请求都会创建一个新的bean实例，自然不会存在线程安全问题。

### @Component和Bean区别

#### Component

注解作用于类

通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。

#### Bean

作用于方法

@Bean告诉Spring这是某个类的示例，当需要用他的时候还给。

@Bean注解比Component注解的自定义性更强，而且很多地方我们只能通过@Bean注解来注册Bean，比如当引用第三方库中的类需要装配到Spring容器中时，则只能通过Bean来实现。

### 类声明为Spring的Bean注解

@Autowired注解自动装配bean

@Component，通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪个层，可以用@Component注解标注。

@Repository，对应持久层，主要用于数据库相关操作。

@Service，对应服务层，主要涉及一些复杂逻辑，需要用到dao层。

@Controller，对应SpringMVC控制层，主要用于接受用户请求并调用Service层返回数据给前端页面。

### Bean生命周期

1. BeanDefinitionReader读取Bean的配置信息(XML等)，将读取到的每个Bean的配置信息使用BeanDefinition表示，同时注册到相应的BeanDefinitionRegistry(一个map)中。
2. 通过实现了BeanFactoryPostProcessor的类，自定义修改BeanDefinition中的信息(如果有的话)
3. Bean的实例化:
    (1) 采用策略化bean的实例， 两种方式: cglib，反射
    (2) 获取Bean的实例之后，根据BeanDefinition中信息，填充Bean的属性、依赖
4. 检测各种Aware接口，BeanFactory的、ApplicationContext的等
5. 调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例
6. 如果实现了InitializingBean接口，执行对应的afterPropertiesSet()方法
7. 如果定义了init-method，执行对应的自定义初始化方法
8. 调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例
9. 使用
10. 判断Bean的Scope，如果是prototype类型，不再管理
11. 如果是单例类型，如果实现了DisposableBean接口，执行对应的destoy方法
12. 如果定义了destory-method，执行对应的自定义销毁方法

![img](/assets/blog_res/2022-03-22-Spring.assets/1704860a4de235.awebp)

概括起来就是4个阶段

**实例化**：实例化一个bean对象；

**属性赋值**：为bean设置相关属性和依赖；

**初始化**：Aware接口的依赖注入、BeanPostProcessor在初始化前后的处理以及InitializingBean和init-method的初始化操作；

**销毁**：注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。

#### Aware接口

若Spring检测到bean实现了Aware接口，则会为其注入相应的依赖。所以通过让bean实现Aware接口，则能在bean中获得相应的Spring容器资源。

## MyBatis

(1) MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。

(2) Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。

- mybatis配置 SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。 mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。
- 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂
- 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。
- mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。
- Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。
- Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。
- Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。