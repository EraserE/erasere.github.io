<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="Spring" /><meta name="author" content="Eraser" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="Spring" /><meta property="og:description" content="Spring" /><link rel="canonical" href="/posts/Spring/" /><meta property="og:url" content="/posts/Spring/" /><meta property="og:site_name" content="Eraser" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-22T22:34:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Eraser" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Eraser"},"dateModified":"2023-11-20T03:56:04+00:00","datePublished":"2023-03-22T22:34:00+00:00","description":"Spring","headline":"Spring","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/Spring/"},"url":"/posts/Spring/"}</script><title>Spring | Eraser</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Eraser"><meta name="application-name" content="Eraser"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Eraser</a></div><div class="site-subtitle font-italic">Gura天下第一！</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/erasere" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['m.sathe2900','protonmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Spring</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Spring</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1679524440" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/03/22 </em> </span> <span> 更新于 <em class="" data-ts="1700452564" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/11/19 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8329 字"> <em>46 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="spring">Spring</h1><h2 id="基础"><span class="mr-2">基础</span><a href="#基础" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-spring特性"><span class="mr-2">1. Spring特性</span><a href="#1-spring特性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>从Spring框架的特性来看，有以下内容</p><ul><li>非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API；<li>控制反转：IOC指的是将对象的创建权交给Spring去创建。使用Spring之前，对象的创建都是用new来进行；<li>依赖注入：DI是指依赖的对象不需要手动调用set方法去设置。而是通过配置赋值；<li>面向切面编程：AOP<li>容器：Spring是一个容器，因为它包含并且管理应用对象的声明周期<li>组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用。在Spring中可以使用XML和Java注解来组合这些对象；</ul><h3 id="2-spring组件"><span class="mr-2">2. Spring组件</span><a href="#2-spring组件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Spring框架的所有模块如下：</p><p><a href="/assets/blog_res/2022-03-22-Spring.assets/spring-framework-introduce-8.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-Spring.assets/spring-framework-introduce-8.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="spring-core-container"><span class="mr-2">Spring Core Container</span><a href="#spring-core-container" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Spring的核心容器是其他模块建立的基础，由Beans模块，Core核心模块，Context上下文模块和SpEL表达式语言模块组成。</p><ul><li><strong>Beans模块</strong>：提供了框架的基础部分，包括控制反转和依赖注入。<li><strong>Core核心模块</strong>：封装了Spring框架的底层部分，包括资源访问，类型转换以及一些常用的工具类。<li><strong>Context上下文模块</strong>：建立在Core和Beans模块的基础上，基础Beans模块功能并添加资源绑定，数据验证，国际化，JavaEE支持，容器生命周期，事件传播等。<li><strong>SpEL模块</strong>：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组等。</ul><h4 id="data-accessintegration"><span class="mr-2">Data Access/Integration</span><a href="#data-accessintegration" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>数据访问/集成层包括JDBC，ORM，OXM，JMS和Transactions模块</p><ul><li><strong>JDBC模块</strong>：提供了一个JDBC的样例模板，使用这些模板能消除冗长的JDBC编码还有必须的事务控制，能享受到Spring管理事务的好处。<li><strong>ORM模块</strong>：提供与流行的对象-关系映射框架无缝集成的API，包括 JPA、JDO、Hibernate 和 MyBatis 等。而且还可以使用 Spring 事务管理，无需额外控制事务。<li><strong>OXM模块</strong>：提供了一个支持Object/XML映射的抽象层实现。将Java对象映射成XML数据，或者将XML数据映射成Java对象。<li><strong>JMS模块</strong>：指Java消息服务，用于在两个应用之间或分布式系统中发送消息，进行异步通信。<li><strong>Transactions事务模块</strong>：支持编程和声明式事务管理。</ul><h4 id="web模块"><span class="mr-2">Web模块</span><a href="#web模块" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Spring的Web层包含以下组件：</p><ul><li><strong>Web模块</strong>：提供了最基本的Web开发集成特性，例如多文件上传功能，使用的Servlet监听器和IOC容器初始化以及Web应用上下文。<li><strong>Servlet模块</strong>：提供了一个Spring MVC Web框架实现。Spring MVC框架提供了基于注解的请求资源注入，更简单的数据绑定，数据验证等。<li><strong>WebSocket模块</strong>：提供了简单的接口，用户只要实现响应的接口就可以快速的搭建WebSocket Server，从而实现双向通讯。<li><strong>WebFlux模块</strong>：Spring WebFlux是Spring Framework5中引入的新的响应式web框架。与Spring MVC不同，它不需要Servlet API，是完全异步且非阻塞的，并且通过Reactor项目实现了Reactive Streams规范，Spring WebFlux用于创建基于事件循环执行模型的完全异步且非阻塞的应用程序。</ul><h4 id="aopaspectsinstrumentation和messaging"><span class="mr-2">AOP，Aspects，Instrumentation和Messaging</span><a href="#aopaspectsinstrumentation和messaging" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>具体包含以下组件：</p><ul><li><strong>AOP模块</strong>：提供了面向切面编程的实现，提供比如日志记录，权限控制，性能统计等通用功能和业务逻辑分离的技术，并且通过动态的把这些功能添加到需要的代码中来降低系统的耦合。<li><strong>Aspects模块</strong>：提供与AspectJ的集成，是一个强大且成熟的AOP框架。<li><strong>Instrumentation模块</strong>：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用。<li><strong>messaging模块</strong>：提供了对消息传递体系结构和协议的支持。</ul><h4 id="test模块"><span class="mr-2">Test模块</span><a href="#test模块" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>提供了对JUnit和TestNG测试的支持，还提供了一些基于Spring的测试功能。</p><h2 id="ioc控制反转"><span class="mr-2">IOC控制反转</span><a href="#ioc控制反转" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-基础"><span class="mr-2">1. 基础</span><a href="#1-基础" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IoC（控制反转）是一种设计思想，将原本在程序中手动创建对象的控制权，交由Spring框架管理。</p><p>Spring里面的bean就类似是定义的一个组件，而组件的作用就是实现某个功能。传统的Java程序设计需要直接在对象内部通过new进行创建，而在Spring中，Spring框架管理这些Bean的创建工作。</p><p>Spring框架将托管的Bean放置在IoC容器中，支持xml配置，Java配置以及注解配置等，并管理Bean的整个生命周期。</p><p>应用程序从IoC容器中获取依赖的Bean，注入到程序中，这个过程叫<strong>依赖注入</strong>，控制反转通过依赖注入实现。</p><h3 id="2-spring-bean"><span class="mr-2">2. Spring Bean</span><a href="#2-spring-bean" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="作用域"><span class="mr-2">作用域</span><a href="#作用域" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>singleton</strong></p><p>唯一bean实例，Spring中的bean默认都是单例的。</p><p><strong>prototype</strong></p><p>每次请求都会创建一个新的bean实例。</p><p><strong>request</strong></p><p>每一次HTTP请求都会产生一个新的bean，该bean仅在当前的HTTP request内有效。</p><p><strong>session</strong></p><p>每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效。</p><p><strong>global-session</strong></p><p>全局session作用域，仅仅在给予portlet的web中才有意义，Spring5已经没有了。</p><h4 id="单例bean线程安全"><span class="mr-2">单例bean线程安全</span><a href="#单例bean线程安全" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p><p>一般情况下，常用的Controller，Service，Dao这些Bean都是无状态的，无状态的bean不能保存数据，因此是线程安全的。</p><p><strong>解决方法</strong>：</p><p>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal中。</p><p>改变Bean的作用域为“prototype”：每次请求都会创建一个新的bean实例，自然不会存在线程安全问题。</p><h4 id="component和bean区别"><span class="mr-2">@Component和Bean区别</span><a href="#component和bean区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Component注解作用于类，通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中。</p><p>Bean作用于方法，@Bean告诉Spring这是某个类的示例，当需要用他的时候还给。</p><p>@Bean注解比Component注解的自定义性更强，而且很多地方我们只能通过@Bean注解来注册Bean，比如当引用第三方库中的类需要装配到Spring容器中时，则只能通过Bean来实现。</p><h4 id="类声明为spring的bean注解"><span class="mr-2">类声明为Spring的Bean注解</span><a href="#类声明为spring的bean注解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>@Autowired注解自动装配bean</p><p>@Component，通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪个层，可以用@Component注解标注。</p><p>@Repository，对应持久层，主要用于数据库相关操作。</p><p>@Service，对应服务层，主要涉及一些复杂逻辑，需要用到dao层。</p><p>@Controller，对应SpringMVC控制层，主要用于接受用户请求并调用Service层返回数据给前端页面。</p><h4 id="bean生命周期"><span class="mr-2">Bean生命周期</span><a href="#bean生命周期" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>BeanDefinitionReader读取Bean的配置信息(XML等)，将读取到的每个Bean的配置信息使用BeanDefinition表示，同时注册到相应的BeanDefinitionRegistry(一个map)中。<li>通过实现了BeanFactoryPostProcessor的类，自定义修改BeanDefinition中的信息(如果有的话)<li>Bean的实例化: (1) 采用策略化bean的实例， 两种方式: cglib，反射 (2) 获取Bean的实例之后，根据BeanDefinition中信息，填充Bean的属性、依赖<li>检测各种Aware接口，BeanFactory的、ApplicationContext的等<li>调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例<li>如果实现了InitializingBean接口，执行对应的afterPropertiesSet()方法<li>如果定义了init-method，执行对应的自定义初始化方法<li>调用BeanPostProcessor接口的前置处理方法，处理符合要求的Bean实例<li>使用<li>判断Bean的Scope，如果是prototype类型，不再管理<li>如果是单例类型，如果实现了DisposableBean接口，执行对应的destoy方法<li>如果定义了destory-method，执行对应的自定义销毁方法</ol><p><a href="/assets/blog_res/2022-03-22-Spring.assets/1704860a4de235.awebp" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-Spring.assets/1704860a4de235.awebp" alt="img" class="lazyload" data-proofer-ignore></a></p><p>概括起来就是4个阶段</p><p><strong>实例化</strong>：实例化一个bean对象；</p><p><strong>属性赋值</strong>：为bean设置相关属性和依赖；</p><p><strong>初始化</strong>：Aware接口的依赖注入、BeanPostProcessor在初始化前后的处理以及InitializingBean和init-method的初始化操作；</p><p><strong>销毁</strong>：注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</p><p><strong>Aware接口</strong></p><p>若Spring检测到bean实现了Aware接口，则会为其注入相应的依赖。所以通过让bean实现Aware接口，则能在bean中获得相应的Spring容器资源。</p><h3 id="3-ioc容器"><span class="mr-2">3. IOC容器</span><a href="#3-ioc容器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IoC容器指Spring用来实现IoC的载体，用来控制对象的生命周期以及对象间的关系。实际上就是个Map，存放的是各种对象。比如xml里配置的bean节点，@controller，@repository，@compoment等。<strong>在Spring中BeanFactory是IoC容器的实际代表者。</strong></p><h3 id="4-ioc配置"><span class="mr-2">4. IoC配置</span><a href="#4-ioc配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IoC配置有三种方式，目前主流的方式是注解+Java配置。</p><h4 id="xml配置"><span class="mr-2">xml配置</span><a href="#xml配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>就是将bean的信息配置到xml文件里，通过Spring加载文件为我们创建bean。这种方式出现较早，优点是可以使用于任何场景，结构清晰，通俗易懂，缺点是配置繁琐，不宜维护，拓展性差。</p><h4 id="java配置"><span class="mr-2">Java配置</span><a href="#java配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>将类的创建交给自己创建的JavaConfig来完成，Spring只负责维护和管理，采用纯Java方式，其本质上就是把在XML上的配置声明转移到Java配置类中。</p><p>优点是适用于任何场景，由于是纯Java代码，扩展性高，但是缺点是声明不明显，如果大量配置可读性较差。</p><h4 id="注解配置"><span class="mr-2">注解配置</span><a href="#注解配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有@Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建和管理。前提是要先配置Spring的注解扫描器。</p><p>优点是开发便捷，通俗易懂，方便维护，缺点是具有局限性，对于一些第三方资源无法添加注解。</p><h3 id="5-依赖注入"><span class="mr-2">5. 依赖注入</span><a href="#5-依赖注入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>常用的注入方式主要有三种：构造方法注入（Construct注入），setter注入，基于注解的注入（接口注入）</p><h4 id="setter方式"><span class="mr-2">setter方式</span><a href="#setter方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>setter方式本质上包含两步，第一步是需要new UserServiceImpl()创建对象, 所以需要默认构造函数，第二步，调用setUserDao()函数注入userDao的值, 所以需要setUserDao()函数。</p><h4 id="构造方法注入"><span class="mr-2">构造方法注入</span><a href="#构造方法注入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>本质上是new UserServiceImpl(userDao)创建对象，</p><h4 id="注解注入"><span class="mr-2">注解注入</span><a href="#注解注入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>以@Autowired注解注入为例，修饰符有三个属性：Constructor，byType，byName。默认按照byType注入。</p><ul><li><strong>constructor</strong>：通过构造方法进行自动注入，spring会匹配与构造方法参数类型一致的bean进行注入，如果有一个多参数的构造方法，一个只有一个参数的构造方法，在容器中查找到多个匹配多参数构造方法的bean，那么spring会优先将bean注入到多参数的构造方法中。<li><strong>byName</strong>：被注入bean的id名必须与set方法后半截匹配，并且id名称的第一个单词首字母必须小写，这一点与手动set注入有点不同。<li><strong>byType</strong>：查找所有的set方法，将符合符合参数类型的bean注入。</ul><h2 id="aop面向切面编程"><span class="mr-2">AOP面向切面编程</span><a href="#aop面向切面编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-基础-1"><span class="mr-2">1. 基础</span><a href="#1-基础-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>即面向切面编程，其把功能分为核心业务功能，和周边功能</p><ul><li><strong>所谓的核心业务</strong>，比如登录，增加数据，删除数据都叫核心业务<li><strong>所谓的周边功能</strong>，比如性能统计，日志，事务管理等等</ul><p>周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面。</p><p>在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这就叫AOP。</p><p>我们将记录日志功能解耦为日志切面，它的目标是解耦。进而引出AOP的理念：就是将分散在各个业务逻辑代码中相同的代码通过<strong>横向切割</strong>的方式抽取到一个独立的模块中。</p><p><a href="/assets/blog_res/2022-03-22-Spring.assets/spring-framework-aop-4.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-Spring.assets/spring-framework-aop-4.png" alt="img" class="lazyload" data-proofer-ignore></a></p><p>他将那些与业务无关，却为业务模块所共同调用的逻辑或责任（如事务处理，日志管理，权限控制等）封装起来。</p><p>AOP能够减少那些与业务无关，却被业务模块共同调用的逻辑封装起来，从而减少系统的重复代码，降低模块间的耦合度，提高可拓展性。</p><h3 id="2-术语"><span class="mr-2">2. 术语</span><a href="#2-术语" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>连接点（Jointpoint）</strong>：表示需要在程序中插入横切关注点的扩展点，<strong>连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等</strong>；<li><strong>切入点（Pointcut）</strong>：选择一组相关连接点的模式，即可以认为连接点的集合，Spring默认使用AspectJ语法；<li><strong>通知（Advice）</strong>：在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；<li><strong>方面/切面（Aspect）</strong>：横切关注点的模块化，比如的日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；<li><strong>引入（inter-type declaration）</strong>：也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）；<li><strong>目标对象（Target Object）</strong>：需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为被通知对象；<li><strong>织入（Weaving）</strong>：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入；<li><strong>AOP代理（AOP Proxy）</strong>：AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。</ul><h4 id="通知类型"><span class="mr-2">通知类型</span><a href="#通知类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>前置通知</strong>：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程；<li><strong>后置通知</strong>：在某连接点正常完成后执行的通知；<li><strong>异常通知</strong>：在方法抛出异常推出时执行的通知；<li><strong>最终通知</strong>：在某连接点推出的时候执行的通知，不管他是正常结束或者抛出异常；<li><strong>环绕通知</strong>：包围一个连接点的通知，如方法调用。环绕通知可以在方法调用前后完成自定义行为。</ul><p>环绕通知是最常用的通知类型。和AspectJ一样，Spring提供所有类型的通知。但是推荐尽量使用简单的通知类型来实现需要的功能。</p><h3 id="3-spring-aop和aspectj"><span class="mr-2">3. Spring AOP和AspectJ</span><a href="#3-spring-aop和aspectj" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="aspectj"><span class="mr-2">AspectJ</span><a href="#aspectj" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>AspectJ是一个java实现的AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）。AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容。</p><h4 id="两者关系"><span class="mr-2">两者关系</span><a href="#两者关系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>AspectJ是更强的AOP框架，是实际意义的<strong>AOP标准</strong>；<li>Spring为何不写类似AspectJ的框架？ Spring AOP使用纯Java实现, 它不需要专门的编译过程, 它一个<strong>重要的原则就是无侵入性（non-invasiveness）</strong>; Spring 小组完全有能力写类似的框架，只是Spring AOP从来没有打算通过提供一种全面的AOP解决方案来与AspectJ竞争。Spring的开发小组相信无论是基于代理的框架如Spring AOP或者是成熟的框架如AspectJ都是很有价值的，他们之间应该是<strong>互补而不是竞争的关系</strong>。<li>Spring小组喜欢@AspectJ注解风格更胜于Spring XML配置； 所以<strong>在Spring 2.0使用了和AspectJ 5一样的注解，并使用AspectJ来做切入点解析和匹配</strong>。<strong>但是，AOP在运行时仍旧是纯的Spring AOP，并不依赖于AspectJ的编译器或者织入器（weaver）</strong>。</ul><h3 id="4-aop配置方式"><span class="mr-2">4. AOP配置方式</span><a href="#4-aop配置方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Spring AOP支持对XML模式和基于@AspectJ注解的两种配置方式。</p><h4 id="xml-schema配置方式"><span class="mr-2">XML Schema配置方式</span><a href="#xml-schema配置方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Spring提供了使用aop命名空间来定义一个切面。通过在xml文件中配置关联目标类和切面来进行AOP。</p><div class="language-xml highlighter-rouge"><div class="code-header"> <span data-label-text="XML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="nt">&lt;aop:aspectj-autoproxy/&gt;</span>
    <span class="c">&lt;!-- 目标类 --&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"demoService"</span> <span class="na">class=</span><span class="s">"tech.pdai.springframework.service.AopDemoServiceImpl"</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- configure properties of bean here as normal --&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

    <span class="c">&lt;!-- 切面 --&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"logAspect"</span> <span class="na">class=</span><span class="s">"tech.pdai.springframework.aspect.LogAspect"</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- configure properties of aspect here as normal --&gt;</span>
    <span class="nt">&lt;/bean&gt;</span>

    <span class="nt">&lt;aop:config&gt;</span>
        <span class="c">&lt;!-- 配置切面 --&gt;</span>
        <span class="nt">&lt;aop:aspect</span> <span class="na">ref=</span><span class="s">"logAspect"</span><span class="nt">&gt;</span>
            <span class="c">&lt;!-- 配置切入点 --&gt;</span>
            <span class="nt">&lt;aop:pointcut</span> <span class="na">id=</span><span class="s">"pointCutMethod"</span> <span class="na">expression=</span><span class="s">"execution(* tech.pdai.springframework.service.*.*(..))"</span><span class="nt">/&gt;</span>
            <span class="c">&lt;!-- 环绕通知 --&gt;</span>
            <span class="nt">&lt;aop:around</span> <span class="na">method=</span><span class="s">"doAround"</span> <span class="na">pointcut-ref=</span><span class="s">"pointCutMethod"</span><span class="nt">/&gt;</span>
            <span class="c">&lt;!-- 前置通知 --&gt;</span>
            <span class="nt">&lt;aop:before</span> <span class="na">method=</span><span class="s">"doBefore"</span> <span class="na">pointcut-ref=</span><span class="s">"pointCutMethod"</span><span class="nt">/&gt;</span>
            <span class="c">&lt;!-- 后置通知；returning属性：用于设置后置通知的第二个参数的名称，类型是Object --&gt;</span>
            <span class="nt">&lt;aop:after-returning</span> <span class="na">method=</span><span class="s">"doAfterReturning"</span> <span class="na">pointcut-ref=</span><span class="s">"pointCutMethod"</span> <span class="na">returning=</span><span class="s">"result"</span><span class="nt">/&gt;</span>
            <span class="c">&lt;!-- 异常通知：如果没有异常，将不会执行增强；throwing属性：用于设置通知第二个参数的的名称、类型--&gt;</span>
            <span class="nt">&lt;aop:after-throwing</span> <span class="na">method=</span><span class="s">"doAfterThrowing"</span> <span class="na">pointcut-ref=</span><span class="s">"pointCutMethod"</span> <span class="na">throwing=</span><span class="s">"e"</span><span class="nt">/&gt;</span>
            <span class="c">&lt;!-- 最终通知 --&gt;</span>
            <span class="nt">&lt;aop:after</span> <span class="na">method=</span><span class="s">"doAfter"</span> <span class="na">pointcut-ref=</span><span class="s">"pointCutMethod"</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/aop:aspect&gt;</span>
<span class="nt">&lt;/aop:config&gt;</span>
</pre></table></code></div></div><h4 id="aspectj注解方式"><span class="mr-2">AspectJ注解方式</span><a href="#aspectj注解方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>基于XML声明式配置存在一些不足，比如需要在Spring配置文件配置大量的代码信息，所以Spring使用了@AspectJ框架为AOP的实现提供了一套注解。</p><ul><li><strong>@Aspect</strong>：用来定义一个切面；<li><strong>@pointcut</strong>：用于定义切入点表达式，在使用时还需要定义一个包含名字和任意参数的方法签名来表示切入点名称，这个方法签名就是一个返回值为void，且方法体为空的普通方法；<li><strong>@Before</strong>：用于定义前置通知，相当于BeforeAdvice，在使用时，通常需要指定一个value属性值，该属性值用于指定一个切入点表达式(可以是已有的切入点，也可以直接定义切入点表达式)；<li><strong>@AfterReturning</strong>：用于定义后置通知，相当于AfterReturningAdvice，在使用时可以指定pointcut / value和returning属性，其中pointcut / value这两个属性的作用一样，都用于指定切入点表达式；<li><strong>@Around</strong>：用于定义环绕通知，相当于MethodInterceptor，在使用时需要指定一个value属性，该属性用于指定该通知被植入的切入点；<li><strong>@After-Throwing</strong>：用于定义异常通知来处理程序中未处理的异常，相当于ThrowAdvice；<li><strong>@After</strong>：用于定义最终final通知，不管是否异常，该通知都会执行。使用的时候需要指定一个value属性，该属性用于指定该通知被植入的切入点。</ul><h4 id="aspectj注解织入方式"><span class="mr-2">AspectJ注解织入方式</span><a href="#aspectj注解织入方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Spring AOP的实现方式是动态织入，动态织入的方式是在运行的时候动态的将要增强的代码织入到目标类中，这样往往是通过动态代理技术实现完成的。如Java JDK的动态代理或者CGLIB的动态代理。Spring AOP采用的是基于运行时增强的代理技术。</p><p>定义Aspect如下</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="nd">@Aspect</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PerformanceTraceAspect</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Log</span> <span class="n">logger</span> <span class="o">=</span> <span class="nc">LogFactory</span><span class="o">.</span><span class="na">getLog</span><span class="o">(</span><span class="nc">PerformanceTraceAspect</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Pointcut</span><span class="o">(</span><span class="s">"execution(public void *.method1()) || execution(public void *.method2())"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">myPointcut</span><span class="o">()</span> <span class="o">{}</span>

    <span class="nd">@Around</span><span class="o">(</span><span class="s">"myPointcut()"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">performanceTrace</span><span class="o">(</span><span class="nc">ProceedingJoinPoint</span> <span class="n">joinPoint</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Throwable</span> <span class="o">{</span>
        <span class="nc">StopWatch</span> <span class="n">watch</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StopWatch</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">watch</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">watch</span><span class="o">.</span><span class="na">stop</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isInfoEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"PT in method["</span> <span class="o">+</span> <span class="n">joinPoint</span><span class="o">.</span><span class="na">getSignature</span><span class="o">().</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">"]&gt;&gt;&gt;"</span> <span class="o">+</span> <span class="n">watch</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>通过AspectJProxyFactory手动织入</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">manualWeaver</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 手动织入</span>
    <span class="nc">AspectJProxyFactory</span> <span class="n">weaver</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AspectJProxyFactory</span><span class="o">();</span>
    <span class="n">weaver</span><span class="o">.</span><span class="na">setProxyTargetClass</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
    <span class="c1">// 声明目标对象</span>
    <span class="n">weaver</span><span class="o">.</span><span class="na">setTarget</span><span class="o">(</span><span class="k">new</span> <span class="nc">Foo</span><span class="o">());</span>
    <span class="c1">// 声明切面</span>
    <span class="n">weaver</span><span class="o">.</span><span class="na">addAspect</span><span class="o">(</span><span class="nc">PerformanceTraceAspect</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="c1">// 获取代理</span>
    <span class="nc">Object</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">weaver</span><span class="o">.</span><span class="na">getProxy</span><span class="o">();</span>
    <span class="c1">// 执行已经织入切面逻辑的方法</span>
    <span class="o">((</span><span class="nc">Foo</span><span class="o">)</span> <span class="n">proxy</span><span class="o">).</span><span class="na">method1</span><span class="o">(</span><span class="k">new</span> <span class="nc">FlyImpl</span><span class="o">());</span>
    <span class="o">((</span><span class="nc">Foo</span><span class="o">)</span> <span class="n">proxy</span><span class="o">).</span><span class="na">method2</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="spring事务"><span class="mr-2">Spring事务</span><a href="#spring事务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-基础-2"><span class="mr-2">1. 基础</span><a href="#1-基础-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Spring 事务的本质，其实就是通过 Spring AOP 切面技术，在合适的地方开启事务，接着在合适的地方提交事务或回滚事务，从而实现了业务编程层面的事务操作</strong></p><p><strong>分类：</strong></p><p>编程式事务：代码中硬编码</p><p>声明式事务：基于XML的声明式事务和基于注解的事务</p><h3 id="2-隔离级别"><span class="mr-2">2. 隔离级别</span><a href="#2-隔离级别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Spring的事务隔离级别和Mysql数据库类似，分为五种</p><ul><li><p><strong>ISOLATION_DEFAULT</strong>：使用后端数据库默认隔离级别</p><li><p><strong>ISOLATION_READ_UNCOMMITED</strong>：读未提交，允许读取尚未提交的数据，最低的隔离级别</p><li><p><strong>ISOLATION_READ_COMMITED</strong>：读已提交，允许读取并发事务已提交的数据，可以阻止脏读</p><li><p><strong>ISOLATION_REPEATALBE_READ</strong>：可重复读，对同一字段多次读取结果都是一致的，无法阻止幻读</p><li><p><strong>ISOLATION_SERIAZABLE</strong>：串行化，效率较低</p></ul><h3 id="3-事务传播行为"><span class="mr-2">3. 事务传播行为</span><a href="#3-事务传播行为" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>事务传播类型，指的是事务与事务之间的交互策略。例如：在事务方法 A 中调用事务方法 B，当事务方法 B 失败回滚时，事务方法 A 应该如何操作。Spring 事务中定义了 7 种事务传播类型，分别是：REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED。其中最常用的只有 3 种，即：<strong>REQUIRED，REQUIRES_NEW，NESTED。</strong></p><ul><li><strong>PROPAGATE_REQUIRED</strong>：REQUIRED 是 Spring 默认的事务传播类型，该传播类型的特点是：当前方法存在事务时，子方法加入该事务。此时父子方法共用一个事务，无论父子方法哪个发生异常回滚，整个事务都回滚。即使父方法捕捉了异常，也是会回滚。而当前方法不存在事务时，子方法新建一个事务。<li><strong>PROPAGATE_REQUIRES_NEW</strong>：该传播类型的特点是：无论当前方法是否存在事务，子方法都新建一个事务。此时父子方法的事务时独立的，它们都不会相互影响。但父方法需要注意子方法抛出的异常，避免因子方法抛出异常，而导致父方法回滚。<li><strong>PROPAGATE_NESTED</strong>：当前方法存在事务时，子方法加入在嵌套事务执行。当父方法事务回滚时，子方法事务也跟着回滚。当子方法事务发送回滚时，父事务是否回滚取决于是否捕捉了异常。如果捕捉了异常，那么就不回滚，否则回滚。与REQUIRED的区别是在子方法事务发生异常回滚时，父方法有着不同的反应动作。</ul><h3 id="4-spring事务失效"><span class="mr-2">4. Spring事务失效</span><a href="#4-spring事务失效" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>若同一类中的其他没有 @Transactional 注解的方法内部调用有 @Transactional 注解的方法，有 @Transactional 注解的方法的事务会失效。这是由于 Spring AOP 代理的原因造成的，因为只有当 @Transactional 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p><p>另外，如果直接调用，不通过对象调用，也是会失效的。因为 Spring 事务是通过 AOP 实现的。</p><p>@Transactional 注解只有作用到 public 方法上事务才生效。</p><p>被 @Transactional 注解的方法所在的类必须被 Spring 管理。</p><p>底层使用的数据库必须支持事务机制，否则不生效。</p><h3 id="5-spring设计模式"><span class="mr-2">5. Spring设计模式</span><a href="#5-spring设计模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>工厂设计模式</strong></p><p>Spring使用工厂模式通过BeanFactory，ApplicationContext创建Bean对象。</p><p><strong>代理设计模式</strong></p><p>Spring AOP的功能实现。</p><p><strong>单例设计模式</strong></p><p>Spring中的Bean默认都是单例的。</p><p><strong>模版方法模式</strong></p><p>Spring中jdbcTemplate，hibernateTemplate等以template结尾等对数据库操作的类，他们就是用到了模版模式。</p><p><strong>包装器设计模式</strong></p><p>项目需要连接多个数据库，而不同的客户每次访问就要访问不同的数据库，这种模式让我们可以根据客户的需求去动态切换不同的数据库。</p><p><strong>观察者模式</strong></p><p>Spring事件驱动模型就是一个典型。</p><p><strong>适配器模式</strong></p><p>Spring AOP增强或通知使用到了这个模式。</p><h2 id="springboot"><span class="mr-2">SpringBoot</span><a href="#springboot" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-基础-3"><span class="mr-2">1. 基础</span><a href="#1-基础-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="springframework优缺点"><span class="mr-2">SpringFramework优缺点</span><a href="#springframework优缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Spring是Java企业版的轻量级替代品，其为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象实现了企业级Java的功能.</p><p>Spring可以带来一下好处：</p><ul><li>使用Spring IOC容器，将对象之间的依赖关系交给Spring，降低组件之间的耦合性；<li>可以提供众多服务如事务管理等；<li>支持AOP，方便面向切面编程；<li>对主流框架提供了很好的集成支持，如hibernate，jpa等；<li>Spring依赖注入降低了业务对象替换的复杂性；<li>Spring属于低入侵，代码污染低；<li>Spring高可开放，并不强制依赖于Spring，开发者可选择Spring的部分或全部。</ul><p>但是，Spring也有以下问题：</p><p>虽然Spring的组件代码是轻量级的，但是他的配置却是重量级的。一开始Spring用XML配置，数量非常多。Spring2.5引入了基于注解的组件扫描，消除了大量显式XML配置。Spring3.0引入基于Java的配置。</p><p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p><h4 id="springboot特点"><span class="mr-2">SpringBoot特点</span><a href="#springboot特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>SpringBoot对上述缺点进行了改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维转换。</p><ul><li>为基于Spring的开发提供更快的入门体验；<li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求；<li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器，安全，指标，健康检测，外部配置等；</ul><p><strong>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式。</strong></p><h4 id="springboot核心功能"><span class="mr-2">SpringBoot核心功能</span><a href="#springboot核心功能" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>起步依赖：其本质上是一个Maven项目对象模型，定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。简单地说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认功能。<li>自动配置：SpringBoot的自动配置是一个运行时的过程，其是Spring自动完成的。</ul><h4 id="常用注解"><span class="mr-2">常用注解</span><a href="#常用注解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>@SpringBootApplication</strong>：定义在main方法入口处，用于启动SpringBoot应用项目；<li><strong>@EnableAutoConfiguration</strong>：让SpringBoot根据路径中的jar包依赖当前项目进行自动配置，比如在src/main/resources的META-INF/spring.factories里；<li><strong>@Value</strong>：application.properties定义属性，直接使用@Value注入即可；<li><strong>@ConfigurationProperties(prefix=”person”)</strong>：可以新建一个properties文件，注解的属性prefix指定为properties配置的前缀，通过location指定properties文件的位置；<li><strong>@RestController</strong>：RestController只返回对象，其返回JSON或XML形式数据，在开发时需要与@Controller和@ResponseBody组合；<li><strong>@Controller</strong>：Controller只返回一个页面，用于标注组件的控制层；<li><strong>@Service, @Repository, @RequsetMapping, @RequestParam, @PathVariable</strong><li><strong>@ResponseBody</strong>：支持将返回值放在response体内。而不是返回一个页面；<li><strong>@PostConstruct</strong>：Spring容器要初始化的时候，执行该方法；<li><strong>@Autowired</strong>：在默认情况下使用@Autowired注解进行自动注入时，Spring容器中匹配的候选Bean数目有且只能有一个。</ul><h3 id="2-统一封装接口"><span class="mr-2">2. 统一封装接口</span><a href="#2-统一封装接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="restful-api"><span class="mr-2">RESTful API</span><a href="#restful-api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>REST指Representational State Transfer，即表现层状态转化，是所有Web应用都应该遵守的架构设计指导原则。面向资源是REST最明显的特征。</p><p>RESTful API是符合REST设计标准的API，REST 架构设计，遵循的各项标准和准则，就是 HTTP 协议的表现，换句话说，HTTP 协议就是属于 REST 架构的设计模式。比如，无状态，请求-响应。</p><h4 id="为什么"><span class="mr-2">为什么</span><a href="#为什么" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>现在大多数项目采用前后端分离的模式进行开发，统一返回方便前端进行开发和封装，以及返回时给出响应编码和信息。</p><h3 id="3-mybatis"><span class="mr-2">3. MyBatis</span><a href="#3-mybatis" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="jdbc"><span class="mr-2">JDBC</span><a href="#jdbc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>JDBC (Java数据库连接) 是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问。它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口。</p><p>其优点是运行的时候快捷高效，但是在编译器代码量大，繁琐的异常处理，不支持数据库跨平台。</p><h4 id="基础-1"><span class="mr-2">基础</span><a href="#基础-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。</p><p>Mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。</p><h4 id="配置"><span class="mr-2">配置</span><a href="#配置" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>mybatis配置 SqlMapConfig.xml，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。 mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。<li>通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂。<li>由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。<li>mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。<li>Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。<li>Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。<li>Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/spring/" class="post-tag no-text-decoration" >Spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Spring%20-%20Eraser&url=%2Fposts%2FSpring%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Spring%20-%20Eraser&u=%2Fposts%2FSpring%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FSpring%2F&text=Spring%20-%20Eraser" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/JAVA/">JAVA</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><li><a href="/posts/JVM/">JVM</a><li><a href="/posts/Spring/">Spring</a><li><a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs5289/">CS5289</a> <a class="post-tag" href="/tags/java/">JAVA</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/reactive-programming/">Reactive Programming</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/JAVA/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JAVA</h3><div class="text-muted small"><p> JAVA 基础 1. 面向对象 三大特性 Java有三大特性：封装，继承，多态。 封装：利用抽象数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据在被保护的抽象数据类型的内部，尽可能隐藏内部细节，只保留一些对外接口使之与外部发生联系，用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 继承：继承实现了IS-A关系，遵循里氏替换原则，即派生子类...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据库</h3><div class="text-muted small"><p> 数据库 MySQL 1. InnoDB引擎 MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎。 MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是MySQL之前的默认存储引擎。 MEMORY存储引擎提供”内存中”表。MERGE存储引擎允许集合...</p></div></div></a></div><div class="card"> <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络</h3><div class="text-muted small"><p> 计算机网络 TCP 1. TCP基础 TCP全程传输控制协议，是面向连接的，可靠的，基于字节流的传输层通信协议。 面向连接：连接是一对一的，而不是和UDP一样可以一堆多； 可靠的：无论网络中出现了怎样的链路变化，TCP都能保证一个报文一定能到达接收端； 字节流：用户消息通过TCP传输时，消息可能会被操作系统分组成多个的TCP报文，如果接收方不知道消息的边界，是无法读取出...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Reactive-Programming/" class="btn btn-outline-primary" prompt="上一篇"><p>Reactive Programming</p></a><div class="btn btn-outline-primary disabled" prompt="下一篇"><p>-</p></div></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs5289/">CS5289</a> <a class="post-tag" href="/tags/java/">JAVA</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/reactive-programming/">Reactive Programming</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/EraserE">Eraser</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
