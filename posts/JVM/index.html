<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="JVM" /><meta name="author" content="Eraser" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="JVM" /><meta property="og:description" content="JVM" /><link rel="canonical" href="/posts/JVM/" /><meta property="og:url" content="/posts/JVM/" /><meta property="og:site_name" content="Eraser" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-22T06:00:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="JVM" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Eraser" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Eraser"},"dateModified":"2023-11-22T05:40:49+00:00","datePublished":"2022-03-22T06:00:00+00:00","description":"JVM","headline":"JVM","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/JVM/"},"url":"/posts/JVM/"}</script><title>JVM | Eraser</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Eraser"><meta name="application-name" content="Eraser"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Eraser</a></div><div class="site-subtitle font-italic">Gura天下第一！</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/erasere" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['m.sathe2900','protonmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>JVM</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>JVM</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1647928800" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/03/22 </em> </span> <span> 更新于 <em class="" data-ts="1700631649" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/11/21 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7808 字"> <em>43 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="jvm">JVM</h1><h2 id="类加载"><span class="mr-2">类加载</span><a href="#类加载" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-类的生命周期"><span class="mr-2">1. 类的生命周期</span><a href="#1-类的生命周期" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>类加载的过程包括了<strong>加载，验证，准备，解析，初始化</strong>五个阶段。在这五个阶段中，加载，验证，准备和初始化这四个阶段发生的顺序是确定的，而解析阶段不一定。</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/java_jvm_classload_2.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/java_jvm_classload_2.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="加载"><span class="mr-2">加载</span><a href="#加载" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>类的加载指查找并加载类的二进制数据。加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事：</p><ul><li>通过一个类的全限定名来获取其定义的二进制字节流；<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</ul><p><a href="/assets/blog_res/2022-03-22-JVM.assets/java_jvm_classload_1.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/java_jvm_classload_1.png" alt="img" class="lazyload" data-proofer-ignore></a></p><p>相对于启发阶段而言，类的加载阶段是可控性最强的阶段，因为开发人员可以使用系统提供的类加载器，也可以使用自定义的类加载器来完成加载。</p><p>加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而且在Java堆中也创建一个java.lang.Class对象，这样可以通过该对象访问方法区中的数据。</p><p>加载class文件有以下几种方式</p><ul><li>从本地系统中直接加载；<li>通过网络下载class文件；<li>从zip，jar等归档文件中加载；<li>从专有数据库中加载；<li>将java源文件动态编译为class文件。</ul><h4 id="连接"><span class="mr-2">连接</span><a href="#连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>验证：确保被加载类的正确性</strong></p><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中所包含的信息符合当前虚拟机的要求。有以下四个检验动作</p><ul><li>文件格式验证：验证字节流是否符合class文件格式的规范；<li>元数据验证：对字节码描述的信息进行语义分析；<li>字节码验证：确认程序语义是合法的，符合逻辑的；<li>符号引用验证：确保解析动作正确执行。</ul><p>验证阶段很重要，但不是必须的，它对程序运行期没有影响。</p><p><strong>准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，<strong>这些内存都将在方法区中分配</strong>。</p><p>类变量是指static，不包括实例变量，实例变量会在对象实例化时随着对象一起分配到java堆中。</p><ul><li><p>对于基本数据类型，类变量static和全局变量，如果不显式赋值，系统会默认赋值为0；</p><li><p>static final同时修饰的变量以及局部static变量必须显式赋值，否则编译不通过；</p><li><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</p></ul><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>解析是虚拟机将常量池内的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。</p><h4 id="初始化"><span class="mr-2">初始化</span><a href="#初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始设定有两种方式：<strong>声明类变量的直到初始值和使用静态代码块为类变量指定初始值</strong>。</p><p>类初始化时机：</p><ul><li>创建类的实例，也就是new；<li>访问某个类或接口的静态变量，或者对该静态变量赋值；<li>调用类的静态方法；<li>反射；<li>初始化某个类的子类，其父类也会被初始化；<li>Java虚拟机启动时被标明为启动类的类。</ul><h4 id="使用"><span class="mr-2">使用</span><a href="#使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>类访问方法区内的数据结构的接口，对象是Heap区的数据。</p><h4 id="卸载"><span class="mr-2">卸载</span><a href="#卸载" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java虚拟机将结束生命周期的几种情况：</p><ul><li>执行了System.exit()方法；<li>程序正常结束；<li>程序在执行过程中遇到了一场或错误而终止；<li>由于操作系统出现错误而导致Java迅即进程终止。</ul><h3 id="2-类的加载内存模型"><span class="mr-2">2. 类的加载内存模型</span><a href="#2-类的加载内存模型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/blog_res/2022-03-22-JVM.assets/java-basic-reflection-3.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/java-basic-reflection-3.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h3 id="3-类加载机制"><span class="mr-2">3. 类加载机制</span><a href="#3-类加载机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>类的加载有三种方式：</p><ol><li>命令行启动应用时候由JVM初始化加载。<li>通过Class.forName()方法动态加载；<li>通过ClassLoader.loadClass()方法动态加载。</ol><p>后两种加载方式的区别如下：</p><ul><li>Class.forName()：将类的.class文件加载到jvm中，还会对类进行解释，执行类中的static块；<li>ClassLoader.loadClass()：只加载类的.class文件，不做其他事；</ul><p>类加载器的层次如下：</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/java_jvm_classload_3.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/java_jvm_classload_3.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="jvm类加载机制"><span class="mr-2">JVM类加载机制</span><a href="#jvm类加载机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>全盘负责</strong>：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另一个类加载器来载入；<li><strong>父类委托</strong>：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类；<li><strong>缓存机制</strong>：缓存机制将会保证所有加载过的Class都会被缓存。当程序中需要使用某个Class时，类加载器会先从缓存中寻找Class，只有缓存区不在才会从系统中读取。这就是为什么修改了Class后必须重启JVM才会生效；<li><strong>双亲委派机制</strong>：如果一个类加载器收到了类加载的请求，他首先不会自己尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此所有的类加载请求都应该被传递到顶层的启动类加载器中。只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</ul><p><strong>双亲委派优势</strong></p><ul><li>系统类防止内存中出现多份同样的字节码<li>保证Java程序安全稳定运行</ul><h2 id="jvm运行时数据区"><span class="mr-2">JVM运行时数据区</span><a href="#jvm运行时数据区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>JVM内存大致分为<strong>线程私有区域</strong>和<strong>线程共享区域</strong>，其主要由5个部分组成，统称为<strong>运行时数据区</strong>:</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/view.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/view.png" alt="preview" class="lazyload" data-proofer-ignore></a></p><p>虚拟机栈，本地方法栈，程序计数器是线程私有的，而方法区和堆区市共享的。栈帧的生命周期是和线程关联的。<strong>方法区和堆区主要存放对象，数组等不具有确定性的数据。</strong></p><h3 id="1-程序计数器"><span class="mr-2">1. 程序计数器</span><a href="#1-程序计数器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>程序计数器是当前线程正在执行的那条字节码指令的地址。如果当前线程正在执行的是一个本地方法，那么此时程序计数器为<code class="language-plaintext highlighter-rouge">Undefined</code>。在多线程情况下，其可以记录当前线程执行的位置，是唯一一个不会出现内存越界的区域。</p><h3 id="2-虚拟机栈"><span class="mr-2">2. 虚拟机栈</span><a href="#2-虚拟机栈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="定义"><span class="mr-2">定义</span><a href="#定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java虚拟机栈是描述Java方法运行过程的内存模型。Java虚拟机会为每个即将运行的Java方法创建一块叫做栈帧的区域，用于存放该方法运行过程中的一些信息，如<strong>局部变量表，操作数栈，动态链接，方法出口信息等。</strong></p><p>当方法运行过程中需要创建局部变量的时候，就将局部变量的值存入栈帧中的局部变量表中。</p><h4 id="局部变量表"><span class="mr-2">局部变量表</span><a href="#局部变量表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>定义为一个数字数组主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包含表<strong>八大原始类型，对象引用，以及返回地址</strong>。局部变量表容量大小是在编译期确定下来的。在栈帧中，与性能调优最密切。</p><h4 id="操作数栈"><span class="mr-2">操作数栈</span><a href="#操作数栈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>栈顶缓存技术</strong>：由于操作数是存储在内存中，频繁的进行内存读写操作影响执行速度，将栈顶元素全部缓存到物理 CPU 的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。<li>每一个操作数栈会拥有一个明确的栈深度，用于存储数值，最大深度在编译期就定义好。32bit 类型占用一个栈单位深度，64bit 类型占用两个栈单位深度操作数栈。<li>并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问。</ul><h4 id="方法的调用"><span class="mr-2">方法的调用</span><a href="#方法的调用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接。<li>动态链接：如果被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接。</ul><h3 id="3-本地方法栈"><span class="mr-2">3. 本地方法栈</span><a href="#3-本地方法栈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，用于管理本地方法的调用，是线程私有的。一个本地方法就是一个Java调用非Java代码的接口，这些接口包括与Java环境外交互或者与操作系统交互。</p><h3 id="4-堆区"><span class="mr-2">4. 堆区</span><a href="#4-堆区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="定义-1"><span class="mr-2">定义</span><a href="#定义-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>对是用来<strong>存放对象</strong>的内存空间，几乎所有的对象都存储在堆中。</p><h4 id="特点"><span class="mr-2">特点</span><a href="#特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>线程共享</strong>，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。<li>在虚拟机<strong>启动时创建</strong>。<li>是<strong>垃圾回收的主要场所</strong>。<li>堆可分为<strong>新生代</strong>、<strong>老年代</strong>。<li>逻辑上连续，物理内存空间可以不连续。<li>主流情况下堆的大小可以扩展。</ul><h4 id="内存划分"><span class="mr-2">内存划分</span><a href="#内存划分" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域：</p><ul><li>新生代：新对象和没达到一定年龄的对象都在新生代；<li>老年代：被长时间使用的对象，老年代的内存空间比年轻代要大；<li>元空间：JDK1.8之前叫永久代：像一些方法中的操作临时对象等。JDK1.8之前是占用JVM内存，JDK1.8之后直接使用物理内存。</ul><p><strong>年轻代</strong></p><p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为Minor GC。年轻代被分为三个部分：<strong>Eden Memory</strong>，和两个<strong>Survivor Memory</strong>，默认比例是8：1：1.</p><p><strong>老年代</strong></p><p>旧的一代内存包含那些经过许多轮GC后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集成为Major GC。</p><h4 id="对象在堆中的生命周期"><span class="mr-2">对象在堆中的生命周期</span><a href="#对象在堆中的生命周期" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p>在JVM的内存模型中，对被划分为新生代和老年代，新生代有<strong>Eden区和Survivor区</strong>，Survivor又由From Survivor和To Survivor组成。</p><li>当创建一个对象的时候，对象会被优先分配到新生代的Eden区，此时JVM会给对象定义一个<strong>对象年轻计数器</strong>。<li>当Eden空间不足的时候，JVM将执行新生代垃圾回收（Minor GC）<ul><li>JVM会把存活的对象转移到Survivor中，并且对象年龄+1<li>对象在Survivor中同样也会经历Minor GC，每经历一次Minor GC，对象年龄都会+1</ul><li>如果分配的对象过多，对象会被直接分配到老年代。</ul><h3 id="5-方法区"><span class="mr-2">5. 方法区</span><a href="#5-方法区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="定义-2"><span class="mr-2">定义</span><a href="#定义-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java虚拟机定义方法区是堆的一个逻辑部分，其存放以下信息：</p><ul><li>已经被虚拟机加载的类信息<li>常量<li>静态变量<li>即时编译器编译后的代码</ul><h4 id="特点-1"><span class="mr-2">特点</span><a href="#特点-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>方法区有以下特点：</p><ul><li>线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。<strong>整个虚拟机中只有一个方法区</strong>。<li>永久代。方法区中的信息一般需要长期存在，而他又是堆的逻辑分区，因此用堆的划分方法，把方法区称为永久代。<li>内存回收效率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。<li>允许固定大小，也允许动态扩展。</ul><h4 id="运行时常量池"><span class="mr-2">运行时常量池</span><a href="#运行时常量池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="为什么需要常量池"><span class="mr-2">为什么需要常量池？</span><a href="#为什么需要常量池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>运行时常量池是方法区的一部分。一个有效的Class文件中除了包含类的版本信息，字段，方法以及接口的描述信息外。还有一项是<strong>常量池表，包含各种字面量和对类型，域和方法的符号引用</strong>。</p><p>Java中的Class需要数据支持，通常这种数据会很大以至于不能直接存储到Class文件中，不过可以存到常量池，包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。</p><p><strong>运行时常量池</strong></p><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池；<li>常量池表是Class文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法去的运行时常量池中</strong><li>JVM为每个已加载的类型都维护一个常量池，池中的数据项和数组项一样通过索引访问；<li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括运行期解析后才能够获得的方法或字段引用。</ul><h2 id="垃圾回收"><span class="mr-2">垃圾回收</span><a href="#垃圾回收" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-哪些内存需要回收"><span class="mr-2">1. 哪些内存需要回收</span><a href="#1-哪些内存需要回收" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性。而Java堆区和方法区的内存是动态的，需要进行垃圾回收。</p><h3 id="2-如何判断一个对象是垃圾"><span class="mr-2">2. 如何判断一个对象是垃圾</span><a href="#2-如何判断一个对象是垃圾" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>程序在运行过程中会创建对象，但当方法执行完成或这个对象使用完毕后，它便被定义成了垃圾，这时就需要用垃圾收集器将内存区域清理出来。</p><p>判定一个对象的存活与否，常见的算法有两种：<strong>引用计数法</strong> 和<strong>可达性分析算法</strong>。</p><p>(1) <strong>引用计数法</strong>：堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1，但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1，高效但是<strong>无法处理循环引用</strong>，现在基本已经抛弃。</p><p>(2) <strong>可达性分析算法</strong>：根搜索算法的中心思想，就是从某一些指定的根对象（GC Roots）出发，一步步遍历找到和这个根对象具有引用关系的对象，然后再从这些对象开始继续寻找，从而形成一个个的引用链（其实就和图论的思想一致），然后不在这些引用链上面的对象便被标识为引用不可达对象。</p><p>在Java中，可作为根对象包括下面几种：</p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）；<li>方法区中类静态属性引用的对象；<li>方法区中常量引用的对象；<li>本地方法栈中JNI（Native方法）引用的对象；<li>活跃线程。</ul><h3 id="3--引用类型"><span class="mr-2">3. 引用类型</span><a href="#3--引用类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="强引用"><span class="mr-2">强引用</span><a href="#强引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>创建一个对象并把这个对象赋给一个引用变量，普通 new 出来对象的变量引用都是强引用，有引用变量指向时永远不会被垃圾回收。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</pre></table></code></div></div><h4 id="软引用"><span class="mr-2">软引用</span><a href="#软引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p><p>使用 SoftReference 类来创建软引用。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="nc">SoftReference</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">sf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SoftReference</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;(</span><span class="n">obj</span><span class="o">);</span>
<span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  <span class="c1">// 使对象只被软引用关联</span>
</pre></table></code></div></div><h4 id="弱引用"><span class="mr-2">弱引用</span><a href="#弱引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>非必需对象，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。</p><p>使用 WeakReference 类来实现弱引用。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="nc">WeakReference</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">wf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WeakReference</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;(</span><span class="n">obj</span><span class="o">);</span>
<span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</pre></table></code></div></div><h4 id="虚引用"><span class="mr-2">虚引用</span><a href="#虚引用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>使用 PhantomReference 来实现虚引用。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="nc">PhantomReference</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">pf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PhantomReference</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;(</span><span class="n">obj</span><span class="o">);</span>
<span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</pre></table></code></div></div><h3 id="4-方法区回收判断"><span class="mr-2">4. 方法区回收判断</span><a href="#4-方法区回收判断" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>方法区主要回收的内容有：<strong>废弃常量</strong>和<strong>无用的类</strong>。 对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；<li>加载该类的ClassLoader已经被回收；<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</ul><h3 id="5-常用垃圾回收算法"><span class="mr-2">5. 常用垃圾回收算法</span><a href="#5-常用垃圾回收算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>(1) <strong>标记-清除法</strong>：标记的过程其实就是上面的<strong>可达性算法(根搜索)</strong>所标记的不可达对象，当所有的待回收的“垃圾对象”标记完成之后，便进行第二个步骤：<strong>统一清除</strong>。优点是性能比较高，缺点是容易产生不连续的内存块。</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/1460000038256034.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/1460000038256034.png" alt="标记-清除算法" class="lazyload" data-proofer-ignore></a></p><p>(2) <strong>标记-整理法</strong>：该算法并不会直接清除掉可回收对象 ，而是让所有的对象都向一端移动，然后将端边界以外的内存全部清理掉。</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/1460000038256035.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/1460000038256035.png" alt="标记-整理算法" class="lazyload" data-proofer-ignore></a></p><p>(3) <strong>复制算法</strong>：复制算法将内存区域均分为了两块（记为S0和S1），而每次在创建对象的时候，只使用其中的一块区域（例如S0），当S0使用完之后，便将S0上面存活的对象全部复制到S1上面去，然后将S0全部清理掉。缺点是费内存。</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/1460000038256037.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/1460000038256037.png" alt="复制算法" class="lazyload" data-proofer-ignore></a></p><h3 id="6-分代收集"><span class="mr-2">6. 分代收集</span><a href="#6-分代收集" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为<strong>老年代（Tenured Generation）</strong> 和 <strong>新生代（Young Generation）</strong>，在堆区之外还有一个代就是<strong>永久代（Permanet Generation）(JDK1.8后移除)</strong>。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/1460000038256033.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/1460000038256033.png" alt="堆内存示意图" class="lazyload" data-proofer-ignore></a></p><h3 id="7-垃圾收集器"><span class="mr-2">7. 垃圾收集器</span><a href="#7-垃圾收集器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="分类"><span class="mr-2">分类</span><a href="#分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在Java中，垃圾回收器按照执行机制分为四种类型：</p><ol><li>串行垃圾回收器（Serial Garbage Collector）；<li>并行垃圾回收器（Parallel Garbage Collector）；<li>并发标记扫描垃圾回收器（CMS Garbage Collector）；<li>G1垃圾回收器（G1 Garbage Collector）。</ol><h4 id="收集器"><span class="mr-2">收集器</span><a href="#收集器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>HotSpot VM 提供了 7 种垃圾收集器，分别为：</p><p><strong>Serial</strong></p><p>串行收集器，是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>其优点是简单高效，没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是Client模式下默认的新生代收集器，因为在用户的桌面场景下，分配给虚拟机管理的内存一般来说不会很大。</p><p><strong>PraNew</strong></p><p>是串行收集器的多线程版本，是Server模式下虚拟机首选的新生代收集器。除了性能原因外，主要是因为除了Serial收集器，只有它能与CMS收集器配合工作。</p><p><strong>Parallel Scavenge</strong></p><p>是多线程收集器，目标是达到一个可控的吞吐量，它被称为吞吐量优先收集器。这里的吞吐量指CPU用于运行用户代码的时间占总时间的比值。</p><p><strong>Serial Old</strong></p><p>是Serial收集器的老年代版本。</p><p><strong>Parallel Old</strong></p><p>是Parallel Scavenge的老年代版本。</p><p><strong>CMS</strong></p><p>Concurrent Mark Sweep，Mark Sweep指的是标记-清除算法。</p><p>分为以下四个流程:</p><ul><li>初始标记：仅仅只是标记一下GC Roots能直接关联到的对象，速度快，需要停顿；<li>并发标记：进行GC Roots Tracing的过程，它在整个回收过程中耗时最长，不需要停顿；<li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动，需要停顿。<li>并发清除：不需要停顿。</ul><p>其具有以下缺点：</p><ul><li>吞吐量低，低停顿时间是以牺牲吞吐量为代价的。<li>无法处理浮动垃圾，浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，只能到下一次GC进行回收。<li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</ul><p><strong>G1</strong></p><p>Garbage First，它是一款面向服务端应用的垃圾收集器，在多CPU和大内存场景下有很好的性能。</p><p>堆被分为新生代和老年代，其他收集器进行收集的范围都是整个新生代或者老年代，而G1可以直接对新生代和老年代一起回收。</p><p>G1把堆划分成多个大小相等的独立区域，新生代和老年代不再物理隔离。</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="image" class="lazyload" data-proofer-ignore></a></p><p>通过引入Region的概念，从而将原来的一整块内存空间划分成多个小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来很大的灵活性，是的可以测的停顿时间模型成为可能。通过记录每个Region垃圾回收的时间以及回收所获得的空间，并维护一个优先列表，优先回收价值最大的Region。</p><p>其具备以下特点：</p><ul><li>空间整合：张体看来是基于标记-整理算法实现的收集器，从局部上来看是基于复制的算法实现的，这意味着收集过程中不会产生碎片。<li>可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒。</ul><h4 id="分代收集"><span class="mr-2">分代收集</span><a href="#分代收集" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>新生代可配置的回收器：Serial、ParNew、Parallel Scavenge<li>老年代配置的回收器：CMS、Serial Old、Parallel Old</ul><h3 id="8-内存泄露"><span class="mr-2">8. 内存泄露</span><a href="#8-内存泄露" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="定义-3"><span class="mr-2">定义</span><a href="#定义-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>对象已经没有被应用程序使用，但是垃圾回收器没法移除他们，因为还在被引用。这些对象具有以下特点：<strong>首先，这些对象是可达的；其次，这些对象是无用的</strong>。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p><p><a href="/assets/blog_res/2022-03-22-JVM.assets/webp" class="popup img-link "><img data-src="/assets/blog_res/2022-03-22-JVM.assets/webp" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="原因"><span class="mr-2">原因</span><a href="#原因" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>根本原因是长生命周期的对象持有短生命周期对象的引用很可能发生内存泄漏。当短生命周期的对象已经不再需要，但是长生命周期持有他的引用而导致不能被回收，就发生了内存泄漏。</p><p>具体有以下几类：</p><ol><li>静态集合类引起内存泄漏<li>监听器<li>各种连接<li>内部类和外部模块的引用<li>单例模式</ol><h4 id="避免"><span class="mr-2">避免</span><a href="#避免" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>使用最新稳定版本的Java<li>尽量减少使用静态变量，使用完之后及时赋值 null，移除引用<li>明确对象的有效作用域，尽量缩小对象的作用域。局部变量回收会很快。<li>减少长生命周期对象持有短生命周期的引用<li>各种连接应该及时关闭（数据库连接，网络，IO等）<li>使用内存泄漏检测工具如MAT,Visual VM，jprofile 等<li>避免在代码中使用System.gc()<li>避免使用内部类</ul><h2 id="jvm调优参数"><span class="mr-2">JVM调优参数</span><a href="#jvm调优参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-jvm参数"><span class="mr-2">1. JVM参数</span><a href="#1-jvm参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>-Xms</strong>：堆的最小值；<li><strong>-Xmx</strong>：对的最大值，-Xms和-Xmx的单位默认字节都是以k，m做单位的；<li><strong>-Xmn</strong>：新生代大小；<li><strong>-Xss</strong>：每个线程池堆栈大小；<li><strong>-XX:NewRatio</strong>：设置新生代与老年代的比值。-XX:NewRatio=4 表示新生代与老年代所占比例为1:4 ，新生代占比整个堆的五分之一。如果设置了-Xmn的情况下，该参数是不需要在设置的。<li><strong>-XX:PermSize</strong>：设置持久代初始值，默认是物理内存的1/64；<li><strong>-XX:MaxPermSize</strong>：设置持久代最大值，默认是物理内存1/4；<li><strong>-XX:MaxTenuringThreshold</strong>：新生代对象存活次数，默认15 (若对象在eden区，经历一次MinorGC后还活着，则被移动到Survior区，年龄加1。以后，对象每次经历MinorGC，年龄都加1。达到阀值，则移入老年代)；<li><strong>-XX:SurvivorRatio</strong>：Eden区与Subrvivor区大小的比值，如果设置为8，两个Subrvivor区与一个Eden区的比值为2:8，一个Survivor区占整个新生代的十分之一；</ul><p>经验：</p><ol><li>Xmn用于设置新生代大小，国小会增加Minor GC的频率，过大会减小老年代的大小，一般设为整个对空间的1/4或1/3.<li>XX:SurvivorRatio用于设置新生代中survivor空间和eden空间的大小比例，XX:TargetSurvivorRatio表示当经历Minor GC后，survivor空间占有量百分比超过他的时候，就会压缩进入老年代。默认值为50%；<li>为了性能考虑，一开始尽量将新生代对象留在新生代，避免新生代的大对象直接进入老年代。因为新生代的对象大部分都是短期的，这就造成了老年代内存的浪费，并且回收代价也高；<li>当Xms=Xmx，可以使得堆相对稳定，避免不停震荡；<li>一般来说，MaxPermSize设为64MB可以满足绝大多数的应用了。</ol><h3 id="2-垃圾回收"><span class="mr-2">2. 垃圾回收</span><a href="#2-垃圾回收" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="垃圾回收算法"><span class="mr-2">垃圾回收算法</span><a href="#垃圾回收算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>引用计数法: 会有循环引用的问题，古老的方法；<li>标记清除。根可达判断，最大的问题是空间碎片(清除垃圾之后剩下不连续的内存空间)；<li>复制算法。对于短命对象来说有用，否则需要复制大量的对象，效率低。<strong>如Java的新生代堆空间中就是使用了它(survivor空间的from和to区)；</strong><li>标记整理。对于老年对象来说有用，无需复制，不会产生内存碎片。</ul><h4 id="gc考虑的指标"><span class="mr-2">GC考虑的指标</span><a href="#gc考虑的指标" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>吞吐量：应用耗时和实际耗时的比值；<li>停顿时间：垃圾回收的时候，由于Stop the World，应用的所有程序的所有线程都会挂起，造成应用的停顿。</ul><h4 id="回收器的jvm参数"><span class="mr-2">回收器的JVM参数</span><a href="#回收器的jvm参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>-XX:+UseSerialGC</strong>：串行垃圾回收，现在基本很少使用；<li><strong>-XX:+UseParNewGC</strong>：新生代使用并行，老年代使用串行；<li><strong>-XX:+UseConcMarkSweepGC</strong>：新生代使用并行，老年代使用CMS；<li><strong>-XX:ParallelGCThreads</strong>：指定并行的垃圾回收器的线程数量，最好等于CPU数量；<li><p><strong>-XX:+DisableExplicitGC</strong>：禁用System.gc()，因为它会触发Full GC，这是很浪费性能的，JVM会在需要GC的时候自己触发GC；</p><li><p><strong>-XX:CMSFullGCsBeforeCompaction</strong>：在多少次GC后进行内存压缩，这个是因为并行收集器不对内存空间进行压缩的，所以运行一段时间后会产生很多碎片，使得运行效率降低；</p><li><p><strong>-XX:+CMSParallelRemarkEnabled</strong>：降低标记停顿；</p><li><p><strong>-XX:+UseCMSCompactAtFullCollection</strong>：在每一次Full GC时对老年代区域碎片整理，因为CMS是不会移动内存的，因此会非常容易出现碎片导致内存不够用的；</p><li><p><strong>-XX:+UseCmsInitiatingOccupancyOnly</strong>：使用手动触发或者自定义触发cms 收集，同时也会禁止hostspot 自行触发CMS GC；</p><li><strong>-XX:CMSInitiatingOccupancyFraction</strong>：使用CMS作为垃圾回收，使用70%后开始CMS收集。</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/jvm/" class="post-tag no-text-decoration" >JVM</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=JVM%20-%20Eraser&url=%2Fposts%2FJVM%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=JVM%20-%20Eraser&u=%2Fposts%2FJVM%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FJVM%2F&text=JVM%20-%20Eraser" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/JAVA/">JAVA</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><li><a href="/posts/JVM/">JVM</a><li><a href="/posts/Spring/">Spring</a><li><a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs5289/">CS5289</a> <a class="post-tag" href="/tags/java/">JAVA</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/reactive-programming/">Reactive Programming</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/JAVA/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JAVA</h3><div class="text-muted small"><p> JAVA 基础 1. 面向对象 三大特性 Java有三大特性：封装，继承，多态。 封装：利用抽象数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据在被保护的抽象数据类型的内部，尽可能隐藏内部细节，只保留一些对外接口使之与外部发生联系，用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 继承：继承实现了IS-A关系，遵循里氏替换原则，即派生子类...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据库</h3><div class="text-muted small"><p> 数据库 MySQL 1. InnoDB引擎 MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎。 MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是MySQL之前的默认存储引擎。 MEMORY存储引擎提供”内存中”表。MERGE存储引擎允许集合...</p></div></div></a></div><div class="card"> <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络</h3><div class="text-muted small"><p> 计算机网络 TCP 1. TCP基础 TCP全程传输控制协议，是面向连接的，可靠的，基于字节流的传输层通信协议。 面向连接：连接是一对一的，而不是和UDP一样可以一堆多； 可靠的：无论网络中出现了怎样的链路变化，TCP都能保证一个报文一定能到达接收端； 字节流：用户消息通过TCP传输时，消息可能会被操作系统分组成多个的TCP报文，如果接收方不知道消息的边界，是无法读取出...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="btn btn-outline-primary" prompt="上一篇"><p>计算机网络</p></a> <a href="/posts/Serverless-architecture/" class="btn btn-outline-primary" prompt="下一篇"><p>Serverless architecture</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs5289/">CS5289</a> <a class="post-tag" href="/tags/java/">JAVA</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/reactive-programming/">Reactive Programming</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/EraserE">Eraser</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
