<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="JAVA" /><meta name="author" content="Eraser" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="JAVA" /><meta property="og:description" content="JAVA" /><link rel="canonical" href="/posts/JAVA/" /><meta property="og:url" content="/posts/JAVA/" /><meta property="og:site_name" content="Eraser" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-16T02:34:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="JAVA" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Eraser" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Eraser"},"dateModified":"2023-12-04T05:53:55+00:00","datePublished":"2022-03-16T02:34:00+00:00","description":"JAVA","headline":"JAVA","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/JAVA/"},"url":"/posts/JAVA/"}</script><title>JAVA | Eraser</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Eraser"><meta name="application-name" content="Eraser"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Eraser</a></div><div class="site-subtitle font-italic">Gura天下第一！</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/erasere" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['m.sathe2900','protonmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>JAVA</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>JAVA</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1647398040" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/03/16 </em> </span> <span> 更新于 <em class="" data-ts="1701669235" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/12/03 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="26563 字"> <em>147 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="java">JAVA</h1><h2 id="基础"><span class="mr-2">基础</span><a href="#基础" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-面向对象"><span class="mr-2">1. 面向对象</span><a href="#1-面向对象" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="三大特性"><span class="mr-2">三大特性</span><a href="#三大特性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java有三大特性：<strong>封装，继承，多态</strong>。</p><p><strong>封装</strong>：利用抽象数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据在被保护的抽象数据类型的内部，尽可能隐藏内部细节，只保留一些对外接口使之与外部发生联系，用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p><strong>继承</strong>：继承实现了IS-A关系，遵循里氏替换原则，即派生子类可以在程序中替换其基类对象。父类引用指向子类对象称为<strong>向上转型</strong>，比如<code class="language-plaintext highlighter-rouge">List&lt;?&gt; list=new ArrayList&lt;&gt;();</code></p><p><strong>多态</strong>：多态分为编译时多态和运行时多态：</p><ul><li>编译时多态主要指方法的重载；<li>运行时多态主要指程序中定义的对象引用所指向的具体类型在运行期间才确定。</ul><h4 id="函数式编程"><span class="mr-2">函数式编程</span><a href="#函数式编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>指令式编程利用计算机的指令或者语法，告诉计算机一步步要做什么。而声明式方法就是告诉计算机要实现什么样的功能，而不关注计算机内部处理。</p><p><strong>面向对象编程时对数据进行抽象，而函数式编程是对行为进行抽象</strong>。函数式编程能让程序员写出更容易阅读的代码，这种代码更多的表现了业务逻辑，而不是从机制是如何实现。</p><p>在写回调函数和事件处理器时，程序员不必再纠缠于匿名内部类的冗繁和可读性，函数式编程让事件处理系统变得更加简单。能将函数方便地传递也让编写惰性代码变得容易，只有在真正需要的时候，才初始化变量的值。</p><p>其核心思想是使用不可变的值和函数，函数对一个值进行处理，映射成另一个值。对核心类库的改进主要包括集合类的API和新引入的流Stream。流使程序员可以站在更高的抽象层次上对集合进行操作。</p><h3 id="2-数据类型"><span class="mr-2">2. 数据类型</span><a href="#2-数据类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="包装类型"><span class="mr-2">包装类型</span><a href="#包装类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java有八个基本类型：boolean(1)，byte(8)，char(16)，short(16)，int(32)，float(32)，long(64)，double(64)。</p><p>基本类型都有包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><h4 id="缓存池"><span class="mr-2">缓存池</span><a href="#缓存池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>编译器会在<strong>缓冲池范围内的基本类型</strong>（比如在Java8中Integer的缓存大小默认为-128～127）自动装箱的过程调用valueOf()方法，一次多个Integer实力使用自动装箱来创建并且值相同，那么就会引用相同对象。</p><p>例如</p><ul><li>new Integer(123)每次都会新建一个对象；<li>Integer.valueOf(123)会用缓存池中的对象，多次调用会取得同一个对象的引用。</ul><h4 id="string字符串"><span class="mr-2">String字符串</span><a href="#string字符串" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>概述</strong></p><p>(1) String 类声明为 final的，<strong>不可被继承</strong>。</p><p>(2) String实现了Serializable接口：表示字符串是支持序列化的；实现了Comparable接口：表示String可以比较大小。</p><p><strong>底层存储</strong></p><p>JDK8及以前底层使用final char[]数组；</p><p>JDK9及以后改用final byte[]数组。</p><p>改用final byte[]是为了节省空间 (char占2个字节，而byte只用占用1个字节）</p><p><strong>Java中的String具有不可变性</strong></p><p>(1) 如下操作需要生成新的字符串，而不是修改原有的字符串</p><ul><li>﻿﻿对现有的字符串进行连接操作时；<li>﻿﻿对字符串重新赋值时；<li>﻿﻿调用String的replace()方法修改指定字符或字符串时。</ul><p>(2) 如何保证String的不可变性？</p><ul><li><p>char[]使用final修饰，无法指向新的char[]数组；</p><li><p>String内部没有提供修改的方法，保证内容不会变。</p></ul><p>(3) 为什么将String设计为不可变？</p><ul><li>字符串在实际的开发中使用太频繁，为了提高执行效率，把字符串放到了方法区的字符串常量池当中；<li>不可变字符串，使得编译器可以让字符串共享；<li>String的Hash值经常被使用，不变的特征可以使得hash值也不变，因此只需一次计算；<li>如果一个String对象已经被创建过，那么就会从String Pool（字符串常量池）中取得引用。只有String是不可变的才能使用字符串常量池。</ul><p><strong>字符串常量池</strong></p><p>(1) 常量池中不会存在相同内容的常量；</p><p>(2) 通过字符串字面量赋值时，数据是在常量池中；</p><p>(3) String Pool是一个固定大小的 Hashtable（不会扩容）</p><ul><li>﻿﻿数组+链表的哈希表（拉链法解决hash冲突）；<li>﻿﻿使用StringTableSize可设置StringTable的长度。</ul><p><strong>String.intern()</strong></p><p>使用String.intern()可以保证相同内容的字符串变量引用同一内存对象。</p><p><strong>字符串拼接操作</strong></p><p>常量与常量的拼接结果在常量池 （原理是编译期优化）</p><p>只要其中有一个是变量，结果就在堆中（变量拼接的原理是 String Builder)</p><p>如果拼接的结果调用 intern()方法（将字符串添加到字符常量池中），则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。</p><p><strong>String、StringBuilder、StringBuffer:</strong></p><p>String 底层数组用 final 修饰，不可变。</p><p>StringBuilder 底层数组没有用 final 修饰，可变;线程不安全，效率高(一般用的多)</p><p>StringBuffer 底层数组没有用 final 修饰，可变;线程安全，效率低(一般用的少)</p><h4 id="参数传递"><span class="mr-2">参数传递</span><a href="#参数传递" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java的参数是以值的形式传入方法中，而不是引用传递。</p><p>在将一个对象参数传入一个方法时，本质上是<strong>将对象的地址以值的方式传递到形参中</strong>。因此在方法中改变指针引用的对象，那么此时两个指针指向的是完全不同的对象，一方改变所指对象内容对另一方没有影响。但如果在方法中改变对象的字段值会改变原来对象的字段值，因为改变的是同一个地址指向的内容。</p><h3 id="3-继承"><span class="mr-2">3. 继承</span><a href="#3-继承" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="抽象类与接口"><span class="mr-2">抽象类与接口</span><a href="#抽象类与接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>1. 抽象类</strong></p><p>抽象类和抽象方法都使用abstract关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><p><strong>2. 接口</strong></p><p>接口是抽象类的延伸。在Java8之前，他可以看作一个完全抽象的类，从Java8开始，接口也可以拥有默认的方法实现。接口的成员默认都是public的，并且不允许被定义为private或者protected。</p><p>接口的字段默认是static和final的。</p><h4 id="super"><span class="mr-2">Super</span><a href="#super" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>访问父类的构造函数：可以使用super()函数访问父类构造函数，委托父类完成一些初始化的工作。</p><p>访问父类的成员，如果子类重写了父类中的某个方法的实现，可以通过使用super关键字来引用父类方法的实现。</p><h4 id="函数式接口"><span class="mr-2">函数式接口</span><a href="#函数式接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>Functional</strong></p><p>Function&lt;T, R&gt; 是 Java 8 中的一个函数式接口，用于表示接受一个输入参数 T，并返回一个结果 R 的函数。Function接口中有一个抽象方法apply，用于定义函数的逻辑。Function接口通常用于将数据进行转换、映射或者执行某种转换操作。</p><p><strong>Supplier</strong></p><p>Supplier&lt; T &gt; 是一个功能接口，表示无参传入，返回一个结果为T的函数。接口中有一个功能方法get()，不接受刃和参数。Supplier可以如下定义：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="o">()-&gt;{</span>
    <span class="c1">//函数逻辑实现</span>
<span class="o">}</span>
<span class="n">s</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="c1">//调用接口</span>
</pre></table></code></div></div><p><strong>Accumulator</strong></p><p>在Java中，我们可以使用类来定义累加器。累加器类通常包含一个私有的累加结果变量和一些公共方法，用于更新和获取累加结果。</p><h4 id="静态绑定和动态绑定"><span class="mr-2">静态绑定和动态绑定</span><a href="#静态绑定和动态绑定" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在Java中存在两种绑定方式，一种为静态绑定，又称作早期绑定。另一种就是动态绑定，亦称为后期绑定。</p><p><strong>区别</strong></p><ul><li>静态绑定发生在编译时期，动态绑定发生在运行时期。<li>使用private或static或final修饰的变量或方法，使用静态绑定；而可以被子类重写的方法则会根据运行时的对象进行动态绑定。<li>静态绑定可以使用类信息来完成，而动态绑定需要使用对象信息完成。<li>重载的方法使用静态绑定完成，重写的方法则用动态绑定完成。</ul><p><strong>重载和重写</strong></p><ul><li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写</strong>，重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。<li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</ul><h4 id="类的初始化"><span class="mr-2">类的初始化</span><a href="#类的初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>考虑到以下继承关系：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">A</span><span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">a</span><span class="o">;</span><span class="c1">//类变量</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>
    <span class="c1">//静态代码块</span>
    <span class="kd">static</span><span class="o">{</span>
        <span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是父类的静态代码块"</span><span class="o">+</span><span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">//构造代码块</span>
    <span class="o">{</span>
        <span class="n">id</span><span class="o">=</span><span class="mi">11</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是父类的构造代码块id:"</span><span class="o">+</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="no">A</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是父类的无参构造函数"</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="no">A</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是父类的name"</span><span class="o">+</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">B</span> <span class="kd">extends</span> <span class="no">A</span><span class="o">{</span>
    <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">b</span><span class="o">;</span>
    <span class="kd">static</span><span class="o">{</span>
        <span class="n">b</span><span class="o">=</span><span class="mi">12</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是子类的静态代码块"</span><span class="o">+</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
     <span class="no">B</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"这是子类的name:"</span><span class="o">+</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test666</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    	<span class="no">B</span> <span class="n">bb</span><span class="o">=</span><span class="k">new</span> <span class="no">B</span><span class="o">(</span><span class="s">"GG"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>静态代码在类的初始化阶段就被初始化。<strong>所以当类加载的时候，首先执行父类A的静态代码块，然后执行子类B的静态代码块；当new一个B对象时，首先执行父类A的构造代码块，然后执行父类的构造方法，接着执行子类的构造代码块，最后执行子类B的构造方法。</strong></p><h3 id="4-泛型"><span class="mr-2">4. 泛型</span><a href="#4-泛型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>泛型的意义在于适用于多种数据类型，执行相同的代码。其本质是为了参数化类型。也就是说在泛型的使用过程中，操作的数据类型被指定位一个参数，这种参数可以用在类，接口方法中，分别称为泛型类，泛型接口和泛型方法。</p><h4 id="基本使用"><span class="mr-2">基本使用</span><a href="#基本使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>泛型类</strong></p><p>比如HashMap中的Node数组</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="no">K</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;{</span>       <span class="c1">// 此处指定了两个泛型类型  </span>
    <span class="kd">private</span> <span class="no">K</span> <span class="n">key</span> <span class="o">;</span>     <span class="c1">// 此变量的类型由外部决定  </span>
    <span class="kd">private</span> <span class="no">V</span> <span class="n">value</span> <span class="o">;</span>   <span class="c1">// 此变量的类型由外部决定  </span>
    <span class="kd">public</span> <span class="no">K</span> <span class="nf">getKey</span><span class="o">(){</span>  
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="no">V</span> <span class="nf">getValue</span><span class="o">(){</span>  
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setKey</span><span class="o">(</span><span class="no">K</span> <span class="n">key</span><span class="o">){</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span> <span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="no">V</span> <span class="n">value</span><span class="o">){</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span> 

<span class="nc">Node</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">&lt;&gt;();</span> <span class="c1">// 用String和Integer初始化</span>
</pre></table></code></div></div><p><strong>泛型接口</strong></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">interface</span> <span class="nc">Info</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>        <span class="c1">// 在接口上定义泛型  </span>
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getVar</span><span class="o">()</span> <span class="o">;</span> <span class="c1">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span>
<span class="o">}</span>  
<span class="kd">class</span> <span class="nc">InfoImpl</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">implements</span> <span class="nc">Info</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;{</span>   <span class="c1">// 定义泛型接口的子类  </span>
    <span class="kd">private</span> <span class="no">T</span> <span class="kt">var</span> <span class="o">;</span>             <span class="c1">// 定义属性  </span>
    <span class="kd">public</span> <span class="nf">InfoImpl</span><span class="o">(</span><span class="no">T</span> <span class="kt">var</span><span class="o">){</span>     <span class="c1">// 通过构造方法设置属性内容  </span>
        <span class="k">this</span><span class="o">.</span><span class="na">setVar</span><span class="o">(</span><span class="kt">var</span><span class="o">)</span> <span class="o">;</span>    
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setVar</span><span class="o">(</span><span class="no">T</span> <span class="kt">var</span><span class="o">){</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">var</span> <span class="o">=</span> <span class="kt">var</span> <span class="o">;</span>  
    <span class="o">}</span>  
    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getVar</span><span class="o">(){</span>  
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">var</span> <span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span> 

<span class="nc">Info</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">InfoImpl</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="s">"GG"</span><span class="o">)</span> <span class="o">;</span>  <span class="c1">// 通过子类实例化对象  </span>
</pre></table></code></div></div><p><strong>泛型方法</strong></p><p>是在调用方法的时候声明泛型的具体类型。</p><p>定义泛型方法的语法格式：</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/java-basic-generic-4.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/java-basic-generic-4.png" alt="img" class="lazyload" data-proofer-ignore></a></p><p>调用泛型方法的语法格式：</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/java-basic-generic-5.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/java-basic-generic-5.png" alt="img" class="lazyload" data-proofer-ignore></a></p><p>在定义泛型方法的时候，必须要在返回值的前面加一个 <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code> 来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。</p><p><code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code> 的作用就是指明泛型的具体类型，而<code class="language-plaintext highlighter-rouge">Class&lt;T&gt;</code> 类型的变量可以用来创建泛型类的对象。</p><p>泛型方法中，我们不知道具体的类型是什么，也不知道构造方法如何，因此没办法去new一个对象，但是可以用遍变量的newInstance方法创建对象，也就是利用反射去创建对象。</p><p><strong>泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</strong></p><h4 id="泛型的上下限"><span class="mr-2">泛型的上下限</span><a href="#泛型的上下限" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>为了解决泛型中隐含的类型转换问题，Java泛型加入了类型参数的上下边界机制。<strong><code class="language-plaintext highlighter-rouge">&lt;? extends A&gt;</code>表示该类型参数可以是A(上边界)或者A的子类类型。<code class="language-plaintext highlighter-rouge">&lt;? super A&gt;</code>表示该类型参数可以是A(下边界)或者A的父类类型。</strong></p><p>如果有多个限制，则使用&amp;符号。</p><h4 id="类型擦除"><span class="mr-2">类型擦除</span><a href="#类型擦除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>为了兼容之前的Java版本，Java泛型的实现采用了伪泛型的策略，即<strong>Java在语法上支持泛型，但是在编译阶段会进行类型擦除</strong>。将所有的泛型表示都替换为具体的类型。</p><p>泛型擦除的原则是：</p><ul><li>消除类型参数声明，即删除&lt;&gt;及其包围的部分。<li>根据类型参数的上下界推断并替换所有的类型参数位原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。<li>为了保证类型安全，必要时插入强制类型转换代码。<li>自动产生桥接方法，<strong>以保证擦除类型后的代码仍具有泛型的多态性。</strong></ul><p>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span> <span class="c1">// 一般写成new ArrayList&lt;&gt;()</span>
<span class="nc">ArrayList</span> <span class="n">list2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
</pre></table></code></div></div><p>list1在初始化的时候指定了泛型，而后面new的时候只是在内存中开辟了一个存储空间，可以存储任何对象，真正涉及类型检查的是他们的引用。所以list2没有指定泛型的话就没有类型检查。</p><h4 id="泛型的多态"><span class="mr-2">泛型的多态</span><a href="#泛型的多态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>类型的擦除会造成多态的冲突，而JVM解决的方法就是桥接方法。</p><p>考虑到继承关系：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>  

    <span class="kd">private</span> <span class="no">T</span> <span class="n">value</span><span class="o">;</span>  

    <span class="kd">public</span> <span class="no">T</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="n">value</span><span class="o">;</span>  
    <span class="o">}</span>  

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">DateInter</span> <span class="kd">extends</span> <span class="nc">Pair</span><span class="o">&lt;</span><span class="nc">Date</span><span class="o">&gt;</span> <span class="o">{</span>  

    <span class="nd">@Override</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setValue</span><span class="o">(</span><span class="nc">Date</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>  
        <span class="kd">super</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>  
    <span class="o">}</span>  

    <span class="nd">@Override</span>  
    <span class="kd">public</span> <span class="nc">Date</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>  
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</pre></table></code></div></div><p>在子类中我们将父类的泛型设定为Date，并且覆盖了父类的两个方法，本意是对父类的get和set方法进行重写。但是编译器在进行类型擦除的时候，会将父类指定的Date擦除成Object，但是子类方法的参数还会是Date类型。所以为了防止重写变成重载，<strong>JVM使用了桥接方法，在子类中生成对应的Object参数的set和get方法，在方法中调用自己重写的get和set方法，解决了类型擦除和多态的冲突</strong>。</p><h4 id="基本类型不能作为泛型"><span class="mr-2">基本类型不能作为泛型</span><a href="#基本类型不能作为泛型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在Java中，<strong>基本类型不能作为泛型</strong>，比如 <code class="language-plaintext highlighter-rouge">List&lt;int&gt;</code> 是不被允许的。因为在编译的时候进行类型擦除，List的原始类型变为Object，而Object不能存储int，只能引用Integer的值。但是由于Java提供了自动装箱拆箱的操作，所以可以使用 <code class="language-plaintext highlighter-rouge">list.add(1)</code> 。</p><p><strong>泛型也不能被实例化</strong>，因为泛型的构造方法不确定，找不到对应的字节码文件。但是可以通过反射的方法初始化</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="no">T</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">newInstance</span><span class="o">();</span>
</pre></table></code></div></div><h4 id="泛型中的静态方法和静态变量"><span class="mr-2">泛型中的静态方法和静态变量</span><a href="#泛型中的静态方法和静态变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>    
    <span class="kd">public</span> <span class="kd">static</span> <span class="no">T</span> <span class="n">one</span><span class="o">;</span>   <span class="c1">//编译错误    </span>
    <span class="kd">public</span> <span class="kd">static</span>  <span class="no">T</span> <span class="nf">show</span><span class="o">(</span><span class="no">T</span> <span class="n">one</span><span class="o">){</span> <span class="c1">//编译错误    </span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>    
    <span class="o">}</span>    
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test2</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="no">T</span> <span class="nf">show</span><span class="o">(</span><span class="no">T</span> <span class="n">one</span><span class="o">){</span> <span class="c1">//这是正确的    </span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>    
    <span class="o">}</span>    
<span class="o">}</span>
</pre></table></code></div></div><p>因为泛型类中的泛型参数的实例化时在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。</p><p>不过可以定义泛型方法，因为泛型方法使用的T时自己在方法中定义的T，而不是泛型类中的T。</p><h3 id="5-反射"><span class="mr-2">5. 反射</span><a href="#5-反射" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>反射是程序在运行时才知道要操作的类型，并可以获取到类的完整构造。通过反射机制，Java可以做到<strong>运行时类型识别</strong>，它允许运行中的Java程序对自身进行检查，能直接操作程序对内部属性和方法。</p><p>反射就是把Java中的各种成分映射成一个个Java对象。例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><h4 id="class类"><span class="mr-2">Class类</span><a href="#class类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Class类存在于java.lang包中，其实例表示Java应用程序运行时的类或接口。每个java类运行的时候都在JVM里表现为一个class对象，可以通过类名.class，类型.getClass()，Class.forName(“类名”)等方法获得class对象。数组也同样被映射为class对象的一个类，所有具有相同元素类型和位数的数组都应该共享该Class对象。基本类型也同样表现为class对象。</p><h4 id="反射api"><span class="mr-2">反射API</span><a href="#反射api" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java类成员包括以下三类：属性字段，构造函数，方法。而反射API分为以下几类：</p><ul><li>Field 类：提供有关类的属性信息，以及对它的动态访问权限。它是一个封装反射类的属性的类。<li>Constructor 类：提供有关类的构造方法的信息，以及对它的动态访问权限。它是一个封装反射类的构造方法的类。<li>Method 类：提供关于类的方法的信息，包括抽象方法。它是用来封装反射类方法的一个类。<li>Class 类：表示正在运行的 Java 应用程序中的类的实例。<li>Object 类：Object 是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。</ul><h4 id="实现原理"><span class="mr-2">实现原理</span><a href="#实现原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；<li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；<li>反射也是考虑了线程安全的，放心使用；<li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；<li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；<li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；<li>调度反射方法，最终是由jvm执行invoke0()执行。invoke0是个native方法，由jvm进行调用业务方法。从而完成反射调用功能。</ol><h3 id="6-注解"><span class="mr-2">6. 注解</span><a href="#6-注解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="基础-1"><span class="mr-2">基础</span><a href="#基础-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>注解annontation是Java5开始引入的新特性，他提供了一种安全的类似注解的机制，用来将任何的信息或元数据与程序元素进行关联，为程序元素加上更直观的说明。</p><p>Java的注解是附加在代码中的一些元信息，用于一些工具在编译，运行时进行解析和使用，起到说明，配置的功能。注解不会也不影响代码的实际逻辑，仅仅起到辅助作用。</p><p><strong>注解的用处</strong></p><ul><li>生成文档，常见的有 <code class="language-plaintext highlighter-rouge">@param</code>，<code class="language-plaintext highlighter-rouge">@return</code> 等<li>跟踪代码的依赖性，实现替代配置文件的功能。<li>在编译时进行格式检查，比如 <code class="language-plaintext highlighter-rouge">@override</code>，放在方法前，如果这个方法并不是覆盖了超类的方法，则编译时就会检查出。</ul><p><strong>注解的分类</strong></p><p>Java的注解可以分为三大类：</p><ul><li>标准注解：包括<strong>@Override，@Deprecated，@SuppressWarning</strong>等，他们提供了一些常用元数据，可以帮助程序员更好组织和管理代码。<li>元注解：Java的元注解是用来注解其他注解的注解，它们包括<strong>@Retention，@Target，@Document，@Inherited</strong>等。其主要用来控制注解的作用域，保留期限，文档化等。<li>自定义注解：可以用于类，方法，变量，参数等程序元素，以提供额外的指令。</ul><h4 id="原理"><span class="mr-2">原理</span><a href="#原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>注解的本质是一个继承了 <code class="language-plaintext highlighter-rouge">Annotation</code> 的特殊接口，其具体实现类是Java运行时产生的动态代理类。而我们通过反射获取注解时，<strong>返回的是Java运行时生成的动态代理对象</strong> <code class="language-plaintext highlighter-rouge">$Proxy1</code>。通过代理对象调用自定义注解的方法，最终会调用 <code class="language-plaintext highlighter-rouge">AnnotationInvocationHandler</code> 的 <code class="language-plaintext highlighter-rouge">invoke</code> 方法。</p><p>具体来说，Java注解实现原理可以分为以下四大步骤：</p><p><strong>定义Java注解</strong></p><p>Java的注解实际上就是一个接口，它可以包含多个成员变量和方法，其中的成员变量称为注解的元素</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">@Target</span><span class="o">(</span><span class="nc">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="nc">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="nc">TestAnnotation</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>这个注解包含了一个属性value，表示注解的值。</p><p><strong>注解标记</strong></p><p>使用Java注解时，需要在对应的类，方法，字段上添加注解标记。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">@TestAnnotation</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="n">doSomething</span> <span class="o">{</span>
    <span class="c1">// method</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>编译期间处理</strong></p><p>Java编译器在编译源代码时，会扫描源代码中所有使用了注解的地方，并将注解处理成一个与注解元素相关的数据结构。这个数据结构包含了：注解的所有元素的值，并保存在编译后的Java字节码文件中，这个过程成为注解的编译时处理。</p><p>在编译期间，Java编译器会将这些注解信息转换为Java字节码中的注解信息，并将这些信息存储在Class文件中。</p><p><strong>反射调用</strong></p><p>在运行时，可以通过Java反射机制读取和处理注解信息。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">MyClass</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="s">"doSomething"</span><span class="o">);</span>
<span class="nc">TestAnnotation</span> <span class="n">annotation</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">TestAnnotation</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">value</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="na">value</span><span class="o">();</span>
</pre></table></code></div></div><p>这里通过反射机制获取doSomething方法的注解，然后获取注解value的值。</p><h4 id="使用"><span class="mr-2">使用</span><a href="#使用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>以Spring的@Autowired注解为例，某类上有@Autowired注解，Java可以通过反射机制知道这个属性上有这个注解，然后根据这个注解，执行spring事先写好的让这个注解的起作用的代码，然后完成注入。</p><p>注解不能使用extends来继承，但是注解在编译后，编译器会自动继承Java.lang.annotation.Annotation接口。区别于注解的继承，被注解的子类继承父类注解可以用@Inherited。如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解。</p><h3 id="7-异常"><span class="mr-2">7. 异常</span><a href="#7-异常" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="异常的结构"><span class="mr-2">异常的结构</span><a href="#异常的结构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>异常指不期而至的各种情况。他发生在程序运行期间，干扰了正常的指令流程。Java通过API中Throwable类的众多子类描述不同的异常。所以Java的异常都是对象，是Throwable子类的实例。</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/java-basic-exception-1.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/java-basic-exception-1.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="异常关键字"><span class="mr-2">异常关键字</span><a href="#异常关键字" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>try</strong>：用于监听。将要被监听的代码放在try语句块之内，当try语句块内发生异常的时候，异常被抛出。<li><strong>catch</strong>：用于捕获异常。捕获try中抛出的异常。<li><strong>finally</strong>：finally语句块总是会被执行。它主要用于回收在try中打开的资源，只有在finally块执行完成后，才会返回执行try或catch中的返回或抛出语句。<li><strong>throw</strong>：抛出异常/<li><strong>throws</strong>：用在方法签名中，用于声明该方法可能会抛出异常。</ul><h4 id="异常的申明"><span class="mr-2">异常的申明</span><a href="#异常的申明" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在Java中，当前执行的语句必须属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。</p><p>若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p><h4 id="异常处理机制"><span class="mr-2">异常处理机制</span><a href="#异常处理机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java处理异常主要依靠异常表。</p><p>异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下</p><ul><li><strong>from</strong> 可能发生异常的起始点<li><strong>to</strong> 可能发生异常的结束点<li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置<li><strong>type</strong> 异常处理者处理的异常的类信息</ul><p>当异常发生的时候：</p><ol><li>JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理；<li>如果当前方法的异常表不为空，并且符合异常处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理；<li>如果上一条未找到合适的处理者，则继续查找异常表中的剩余条目；<li>如果当前方法的异常表无法处理，则继续查找刚刚调用该方法的调用处，并重复上面的操作。<li>如果所有的栈帧都被弹出，仍然没有处理，则会跑给当前的Thread，Thread会终止；<li>如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。</ol><h2 id="java容器"><span class="mr-2">Java容器</span><a href="#java容器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/v2-37a924e5830ed38d9c76296314cb4baa_1440w.webp" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/v2-37a924e5830ed38d9c76296314cb4baa_1440w.webp" alt="Java容器详解Ⅰ——概述- 知乎" class="lazyload" data-proofer-ignore></a></p><h3 id="1-collection"><span class="mr-2">1. Collection</span><a href="#1-collection" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="set"><span class="mr-2">Set</span><a href="#set" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li><p><strong>TreeSet</strong></p><p>基于红黑树实现，无序，不可重复，自动排序；</p><p>存放在TreeSet中相当于存放到TreeMap中的key部分。</p><li><p><strong>HashSet</strong></p><p>基于哈希表实现，无序，不可重复，支持快速查找。</p><li><p><strong>LinkedHashSet</strong></p><p>基于双向链表实现，具有 Hashset 的查找效率。</p></ol><h4 id="queue"><span class="mr-2">Queue</span><a href="#queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li><p><strong>LinkedList</strong></p><p>可以实现双向队列。</p><li><p><strong>PriorityQueue</strong></p><p>基于堆结构实现，可以实现优先队列。</p></ol><h4 id="list"><span class="mr-2">List</span><a href="#list" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>List在Java里面是一个接口，继承自Collection。为了追求效率，ArrayList和LinkedList都没有实现同步，vector有同步。</p><p><strong>ArrayList</strong></p><ol><li><p>底层结构是Object数组，元素可以为null；</p><li><p>相比于原生的数组在初始化的时候必须指定大小，ArrayList实现了动态扩容：</p><ul><li><p>new—个ArravList 的时候，默认会有一个空的Object 数组，大小为0，第一次add 数据的时候，会给这个数组一个初始化的大小，默认为 10；</p><li><p>每一次add，都会先去计算这个数组够不够空间，够就追加上去，不够就扩容；</p><li><p>在源码里面，有个grow方法，每一次扩容原来的1.5倍，扩完容后，调用arraycopy来对数组进行拷贝。</p></ul><li><p>日常开发中用的最多，因为遍历需求高。</p></ol><p><strong>LinkedList</strong></p><p>LinkedList同时实现了List接口和Deque接口，因为它既可以看作一个顺序容器们也可以看作一个队列。其底层数据结构是双向链表，元素可以为null。</p><p><strong>Queue</strong></p><p>Queue可以通过LinkedList实现，队列的插入，删除，检视可以使用自带collection的方法，也可以用队列实现的方法。前者失败会抛出异常，后者会返回特殊值。</p><p><strong>Vector</strong></p><p>底层结构是数组，线程安全，扩容的时候直接扩两倍容。</p><p><strong>ArrayList和LinkedList区别</strong></p><ol><li><p>线程安全</p><p>二者都是线程不安全的。</p><li><p>底层数据结构</p><ul><li><p>ArrayList底层使用的是Objiect[]数组;</p><li><p>Linkedlist底层使用的是双向链表数据结构。</p></ul><li><p>插入和删除是否受元素位置影响</p><ul><li>ArrayList采用数组存储，所!以插入和删除元素的时间复杂度受元泰位置的影响；<li>Linkedlist 采用链表进行存储。</ul><li><p>是否支持随机快速访问</p><ul><li>ArrayList 支持 get(index) 方法；<li>Linkedlist 不支持高效的随机元素访问。</ul><li><p>内存空间占用</p><ul><li>ArravList 的空间浪费主要体现在list列表的结尾会预留一定的容量空间；<li>Linkedlist 的空间花费则体现在它的每个元素都需要消耗比ArrayList更多的空间，用于存放直接后继和直接前驱以及数据。</ul></ol><p><strong>ArrayList和Vector区别</strong></p><p>两者都用Object[]存储，但是ArrayList线程不安全，vector线程安全。</p><h4 id="priorityqueue"><span class="mr-2">PriorityQueue</span><a href="#priorityqueue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>优先队列，其作用是<strong>保证每次取出的元素都是队列中权值最小的</strong>，元素大小的判断可以通过构造比较器。</p><p>Java中的优先队列实现了Queue接口，不允许放入null元素，其通过堆实现，具体说是通过完全二叉树实现的小顶堆。</p><h3 id="2-map"><span class="mr-2">2. Map</span><a href="#2-map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="hashmap"><span class="mr-2">HashMap</span><a href="#hashmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>HashMap实现了Map接口，<strong>即允许放入key为null的的元素，也允许插入value为null的元素</strong>，该容器不保证元素顺序，根据需要可能会对元素重新哈希。</p><p>HashMap的参数如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// 最开始的容量，必须是 2 的次方，这里即 2 的 4 次方</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_INITIAL_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="c1">// aka 16</span>
<span class="c1">// 最大容量</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAXIMUM_CAPACITY</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="o">;</span>
<span class="c1">// 负载</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">float</span> <span class="no">DEFAULT_LOAD_FACTOR</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="o">;</span>
<span class="c1">// list to tree 的临界值</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="mi">8</span><span class="o">;</span>
<span class="c1">// 删除冲突节点后，hash相同的节点数目小于这个数，红黑树就恢复成链表</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">UNTREEIFY_THRESHOLD</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
<span class="c1">// 扩容的临界值</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MIN_TREEIFY_CAPACITY</span> <span class="o">=</span> <span class="mi">64</span><span class="o">;</span>
<span class="c1">// 存储元素的数组</span>
<span class="kd">transient</span> <span class="nc">Node</span><span class="o">&lt;</span><span class="n">k</span><span class="o">,</span><span class="n">v</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>
</pre></table></code></div></div><ol><li><p>HashMap 底层是一个数组；</p><li><p>在Java8之前，数组中每个元素是一个单向链表(即，采用拉链法解决哈希冲突)，单链表的节点每个节点是 Node&lt;K, V&gt; 类型；</p><p>Java8之后，对 HashMap 底层数据结构(单链表)进行了改进，如果单链表元素超过8个，则将单链表转变为红黑树；如果红黑树节点数量小于6时，会将红黑树重新变为单链表。</p><li><p>同一个单链表中所有Node的hash值不一定一样，但是他们对应的数组下标一定一样；</p><p>数组下标利用哈希函数/哈希算法根据 hash值计算得到的；</p><li><p>HashMap 是数组和单链表的结合体</p><p>数组查询效率高，但是增删元素效率较低；</p><p>单链表在随机增删元素方面效率较高，但是查询效率较低；</p><p>HashMap 将二者结合起来，充分它们各自的优点；</p><li><p>HashMap 特点</p><p>无序、不可重复；</p><p>无序: 因为不一定挂在那个单链表上了</p><li><p>为什么不可重复？</p><p>通过重写 equals 方法保证的。</p><li><p>数组扩容</p><p>resize()方法用于初始化数组或数组扩容，<strong>每次扩容后，容量为原来的2倍</strong>，并进行数据迁移。</p></ol><h4 id="hashmap扩容"><span class="mr-2">HashMap扩容</span><a href="#hashmap扩容" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>HashMap通过调用Key的hashCode()方法来得到hash值，然后通过Hash算法的<strong>高位运算和取模运算</strong>来定位该键值对的存储位置。</p><p>如果两个key定位到了同一个位置，则发生了Hash碰撞，Hash计算的结果越分散，Hash碰撞的概率越小。</p><h3 id="3-hashmaphashtableconcurrenthashmap线程安全"><span class="mr-2">3. HashMap，HashTable，ConcurrentHashMap线程安全：</span><a href="#3-hashmaphashtableconcurrenthashmap线程安全" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>HashMap 是线程不安全的</strong>。</p><p>在多线程条件下，容易导致死循环。JDK 1.8 HashMap 采用数组 + 链表 + 红黑二叉树的数据结构，优化了 1.7 中数组扩容的方案，解决了 Entry 链死循环和数据丢失问题。但是多线程背景下，put 方法存在数据覆盖的问题。</p><p><strong>HashTable是线程安全的</strong>。</p><p>在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。特别地，在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设为16），及任意数量线程的读操作。</p><p><strong>ConcurrentHashMap的高效并发机制是通过以下三方面来保证的：</strong></p><ul><li>使用volatile保证当Node中的值变化时对于其他线程是可见的，因为volatile关键字，会在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据；<li>使用table数组的头结点作为synchronized的锁来保证写操作的安全。synchronized是互斥锁，有且只有一个线程能够拿到这个锁，从而保证了put操作是线程安全的；<li>当头结点为null时，使用CAS操作来保证数据能正确的写入。所谓的CAS，即即compareAndSwap，执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。</ul><h2 id="java并发"><span class="mr-2">Java并发</span><a href="#java并发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-基础"><span class="mr-2">1. 基础</span><a href="#1-基础" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="为什么需要多线程"><span class="mr-2">为什么需要多线程</span><a href="#为什么需要多线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>CPU，内存，I/O设备的速度有极大的差异，为了合理利用CPU的高性能，平衡三者的速度差异，计算机做出了一下优化：</p><ul><li>CPU增加了缓存，以平衡与内存的速度差异，但是也导致了可见性问题；<li>操作系统增加了线程，进程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异，但是导致了原子性问题；<li>编译程序优化指令执行顺序，以便合理利用缓存，但是导致了有序性问题。</ul><h4 id="并发编程重要特性"><span class="mr-2">并发编程重要特性</span><a href="#并发编程重要特性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>原子性</strong></p><p>对于一个或多次操作，要么所有的操作全部得到执行并且不会收到任何因素的干扰而中断，要么都不执行，用synchronized关键字来保证。</p><p><strong>可见性</strong></p><p>当一个线程对共享变量进行了修改，那么另外的线程都是立即看到修改后的最新值，用volatile字段保证共享变量的可见性。</p><p><strong>有序性</strong></p><p>代码在执行过正中的先后顺序，在编译期间，代码未必顺序执行，而volatile关键字可以禁止指令进行重排优化。</p><h4 id="java如何解决并发"><span class="mr-2">Java如何解决并发</span><a href="#java如何解决并发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>volatile，synchronized和final关键字；<li>Happens-before原则。</ul><h4 id="happens-before规则"><span class="mr-2">Happens-before规则</span><a href="#happens-before规则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>JVM规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><p><strong>单一线程原则</strong>：在一个线程内，在程序前面的操作先行发生于后面的操作；</p><p><strong>管理锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作；</p><p><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面对这个变量的读操作；</p><p><strong>线程启动规则</strong>：Thread对象的start()方法调用先行发生于此线程的每一个动作；</p><p><strong>线程加入规则</strong>：Thread对象的结束先行发生于join()方法返回；</p><p><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p><p><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于它的finalize()方法的开始；</p><p><strong>传递性</strong>：如果操作A先行发生于B，操作B先行发生于C，那么操作A先行发生于操作C。</p><h4 id="线程安全实现方法"><span class="mr-2">线程安全实现方法</span><a href="#线程安全实现方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li><strong>互斥同步</strong>：synchronized和ReentrantLock；<li><strong>非阻塞同步</strong>：CAS，AtomicInteger和ABA；<ul><li>CAS：比较并交换，是硬件支持的原子性操作，CAS指令有三个操作数，内存地址V，旧的预期值A和新值B。当执行操作时，只有当V的值等于A，才将V的值更新为B。<li>ABA：通过控制变量值的版本来保证CAS的正确性。</ul><li><strong>无同步方案</strong>：栈封闭，线程本地存储和可重入代码。<ul><li>栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有。<li>线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样无需同步也能保证线程之间不出现数据争用的问题。</ul></ol><h3 id="2-线程"><span class="mr-2">2. 线程</span><a href="#2-线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="线程状态转换"><span class="mr-2">线程状态转换</span><a href="#线程状态转换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/ace830df-9919-48ca-91b5-60b193f593d2.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/ace830df-9919-48ca-91b5-60b193f593d2.png" alt="image" class="lazyload" data-proofer-ignore></a></p><h4 id="线程使用方式"><span class="mr-2">线程使用方式</span><a href="#线程使用方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>实现Runnable接口</strong>：</p><p>需要实现run()方法，通过Thread调用start()方法来启动线程。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">MyRunnable</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">();</span>
    <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
    <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>实现Callable接口</strong>：</p><p>与Runnable相比，Callable可以有返回值，返回值通过FutureTask进行封装。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyCallable</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">123</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">ExecutionException</span><span class="o">,</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="nc">MyCallable</span> <span class="n">mc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyCallable</span><span class="o">();</span>
    <span class="nc">FutureTask</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">ft</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FutureTask</span><span class="o">&lt;&gt;(</span><span class="n">mc</span><span class="o">);</span>
    <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">ft</span><span class="o">);</span>
    <span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">ft</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>继承Thread类</strong>：</p><p>同样是实现run()方法，因为Thread类也实现了Runnable接口。</p><p>当调用start()方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的run()方法。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// ...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">MyThread</span> <span class="n">mt</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
    <span class="n">mt</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="3-锁"><span class="mr-2">3. 锁</span><a href="#3-锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Java中的锁分为显示锁和隐式锁。隐式锁由synchronized关键字实现，而显示锁是由实现了Lock接口和AQS框架等等类来实现。</p><h4 id="锁的分类"><span class="mr-2">锁的分类</span><a href="#锁的分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>从宏观上看，锁的分类可以分为乐观锁与悲观锁；共享锁和排他锁，可重入锁和不可重入锁等。</p><p><strong>乐观锁和悲观锁</strong></p><p>乐观锁就是对数据冲突保持乐观态度，认为不会有其他线程同时修改数据。因此乐观锁不会上锁，只是在更新数据的时候判断是否有其他线程更新，如果没有其他线程修改则更新数据，有其他线程同时更改数据，则放弃数据。</p><p>悲观锁对数据冲突持悲观态度，认为总有数据发生冲突。因此他以一种预防的态度，先行把数据锁住，直到操作完成才释放锁，在此期间其他线程无法操作数据。</p><p><strong>自旋锁</strong></p><p>线程如果没有争取到资源时，就会进入阻塞状态，当持有锁的线程释放了锁以后，才可以去竞争，这样会浪费大量性能在阻塞和唤醒的切换上，为了避免这点，在没有获得锁的时候，就不进入阻塞，而是不断循环检测锁是否被释放，这就是自旋。</p><p><strong>公平锁和非公平锁</strong></p><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中第一个线程才能获得锁。优点是等待锁的线程不会饿死，缺点是整体吞吐量比非公平锁妖帝，开销较大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队尾等待。如果锁刚好够用，那么这个线程可以无需阻塞直接获取锁。优点是可以减少唤起线程的开销，整体吞吐率较高，缺点是可能有线程会饿死。</p><p><strong>可重入锁不可重入锁</strong></p><p>又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁，不会因为之前已经获取过还没释放而阻塞，可以避免死锁。</p><p>和可重入锁相反，再进入该线程的内层方法不会自动获取锁。</p><p><strong>共享锁和排他锁</strong></p><p>指该锁可以被多个线程持有，如果线程T对数据A加上共享锁后，其他线程只能对A再加共享锁，不能加排他锁。获得共享锁的线程只能读数据，不能改数据。</p><p>指该锁一次只能被一个线程持有。如果线程T对数据A加上排他锁后，其他线程不能对A再加任何类型的锁。获得排他锁的线程既能读数据也能改数据。</p><h4 id="锁状态"><span class="mr-2">锁状态</span><a href="#锁状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><h5 id="无锁"><span class="mr-2">无锁</span><a href="#无锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>不锁住资源，多个线程中有一个能修改资源成功，其他线程会重试。</p><h5 id="偏向锁"><span class="mr-2">偏向锁</span><a href="#偏向锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>一段同步代码，共享资源一直被一个线程访问，那么该线程自动获取锁，降低代价。</p><h5 id="轻量级锁"><span class="mr-2">轻量级锁</span><a href="#轻量级锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>当锁是偏向锁的时候，被另外的线程访问，偏向锁回升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><h5 id="重量级锁"><span class="mr-2">重量级锁</span><a href="#重量级锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>互斥锁，会被阻塞。</p><p>Java的锁升级由锁状态头控制。</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/1460000022904668.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/1460000022904668.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="死锁"><span class="mr-2">死锁</span><a href="#死锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>一般来说，要出现死锁问题需要满足以下条件：</p><ol><li>互斥条件：一个资源每次只能被一个线程使用。<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</ol><p>只要破坏死锁 4 个必要条件之一中的任何一个，死锁问题就能被解决。</p><h3 id="4-synchronized关键字"><span class="mr-2">4. Synchronized关键字</span><a href="#4-synchronized关键字" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Synchronized关键字解决的是多个线程之间访问资源的同步性，他可以保证被他修饰的方法或者代码块在任意时刻只能有一个线程执行，在java1.5以前，synchronized属于重量级锁，效率低下。</p><p>在Java中，每个对象都有一把锁，放置于对象头中，用于记录当前对象被哪个线程持有。synchronized被编译后，使用的是monitor和monitorExit两个字节码指令，而这两个字节码指令以来操作系统中的mutex lock实现。</p><h4 id="synchronized关键字作用"><span class="mr-2">synchronized关键字作用</span><a href="#synchronized关键字作用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>通过使用内置锁，来实现对共享变量的同步操作，进而解决了对共享变量操作的原子性，保证了其他线程对共享变量的可见性、有序性，从而确保在并发情况下的线程安全。</p><p>同时synchronize是可重入的锁，避免了同一个线程重复请求自身一获取的锁时出现死锁问题。</p><h4 id="synchronized字段使用方式"><span class="mr-2">Synchronized字段使用方式</span><a href="#synchronized字段使用方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li><strong>修饰实例方法</strong>：作用于当前对象实例this加锁，进入同步代码块前需要先获得该对象实例的锁。<li><strong>修饰静态方法</strong>：也就是给当前类的Class对象加锁，会作用于类的所有对象实例，进入同步代码块之前要先获得当前class的锁。<li><strong>修饰代码块</strong>：指定加锁的对象，给对象/类加锁synchronized(this｜Object)表示进入同步代码块要获得给定对象的锁。</ol><h4 id="与lock的区别"><span class="mr-2">与lock的区别</span><a href="#与lock的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>synchronized是Java的关键字，而lock是一个接口；<li>synchronized以获取锁的线程执行完成同步代码，释放锁，如果线程执行异常，jvm会让线程释放锁。而lock在finally中必须释放锁，不然容易造成死锁；<li>对于synchronized关键字，假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待；Lock有多个锁获取的方式可以尝试获得锁，线程可以不用一直等待；<li>synchronized关键字无法判断锁状态，而lock可以判断；<li>synchronized锁是可重入，不可中断，非公平的锁，lock是可重入，可判断，可公平的锁；<li>synchronized关键字支持少量同步，而lock可以实现大量同步。</ol><h3 id="5-volatile"><span class="mr-2">5. volatile</span><a href="#5-volatile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="概念"><span class="mr-2">概念</span><a href="#概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p><h4 id="java内存模型"><span class="mr-2">Java内存模型</span><a href="#java内存模型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>JMM规定，线程对变量的所有操作都必须在本地内存进行，不能直接读写主存变量。变量从主存于本地内存之间的交互，由8种操作完成。</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/%E6%88%AA%E5%B1%8F2023-03-30%2020.34.16-0226475.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/%E6%88%AA%E5%B1%8F2023-03-30%2020.34.16-0226475.png" alt="截屏2023-03-30 20.34.16" class="lazyload" data-proofer-ignore></a></p><p>线程的共享变量存储在主内存中，每个线程可以吧变量的副本存在本地内存中，这样可能造成变量不一致。</p><h4 id="volatile变量特性"><span class="mr-2">volatile变量特性</span><a href="#volatile变量特性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>(1) <strong>保证可见性，不保证原子性</strong></p><p>当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的缓存无效。</p><p>其解决了内存不一致问题，当变量声明为volatile时，就告诉JMM该变量是共享且不稳定的，每一次使用都要从主存中读取。</p><p>(2) <strong>禁止指令重排</strong></p><p><strong>重排序</strong>在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><h4 id="volatile原理"><span class="mr-2">volatile原理</span><a href="#volatile原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。</p><h4 id="与synchronized关键字区别"><span class="mr-2">与Synchronized关键字区别</span><a href="#与synchronized关键字区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>volatile关键字是线程同步的轻量级实现，性能更好；</p><p>volatile关键字只能用于变量而synchronized关键字可以修饰方法和代码块；</p><p>volatile只保证数据的可见性，不保证原子性，而synchronized关键字两者都可以保证；</p><p>volatile解决变量在多个线程之间的可见性，而synchronized解决多个线程之间资源访问的同步性。</p><h3 id="6-final"><span class="mr-2">6. final</span><a href="#6-final" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>final可以修饰类，修饰方法，修饰参数以及修饰变量。</p><h4 id="修饰类"><span class="mr-2">修饰类</span><a href="#修饰类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不许别人这么做，即这个类不能有子类。</p><h4 id="修饰方法"><span class="mr-2">修饰方法</span><a href="#修饰方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>父类final方法不能被子类重写，但是可以重载。</p><h4 id="修饰参数"><span class="mr-2">修饰参数</span><a href="#修饰参数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java允许在参数列表中以声明的方式将参数指名为final，即无法在方法中更改参数引用所指的对象。这个特性主要用来向匿名内部类传递数据。</p><h4 id="修饰变量"><span class="mr-2">修饰变量</span><a href="#修饰变量" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>final修饰的字段不一定都是编译器常量，只是初始化之后无法在改变。</p><h3 id="7-casunsafe"><span class="mr-2">7. CAS，Unsafe</span><a href="#7-casunsafe" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="cas"><span class="mr-2">CAS</span><a href="#cas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>CAS的全称是Compare-And-Swap，是一条CPU的原子指令。其作用是让CPU先进行比较两个值是否相等，然后原子性地更新某个位置的值。其靠硬件实现。CAS操作需要输入预期的旧值和新值，在操作期间先比较下旧值有没有发生变化，如果没有发生变化，才交换成新值，否则不做操作。</p><p>CAS是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。在Java中，提供了AtomicInteger原子类，其底层基于CAS进行更新数据的。</p><p><strong>CAS问题</strong></p><p>CAS方式为乐观锁，Synchronized为悲观锁。</p><ul><li><p>ABA问题</p><p>因为CAS在需要操作值的时候，检查值有没有发生变化，没有变化则更新。但是如果一个值原来是A，后来被改成了B，最后又变成了A，那么使用CAS进行检查时就会发现它的值没有发生变化，但实际上却变化了。ABA解决思路就是在变量前加上版本号，每次更新就把版本号加一。</p><li><p>循环时间长开销过大</p><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定提升。<strong>pause指令有两个作用：第一他可以延迟流水线执行命令，使CPU不会消耗过多执行资源，第二它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU执行效率。</strong></p><li><p>只能保证一个共享变量</p><p>当对一个共享变量进行操作时，我们可以使用CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p></ul><p>从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><h4 id="unsafe类"><span class="mr-2">Unsafe类</span><a href="#unsafe类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别，不安全操作的方法。如直接访问系统内存资源，自主管理内存资源等，这些方法可以提升Java运行效率，增强Java语言底层资源操作能力。</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/java-thread-x-atomicinteger-unsafe.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/java-thread-x-atomicinteger-unsafe.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="原子类"><span class="mr-2">原子类</span><a href="#原子类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>JDK中提供了12个原子操作类。</p><p><strong>原子更新基本类型</strong></p><ul><li>AtomicInteger：原子更新整型；<li>AtomicBoolean：原子更新布尔类型；<li>AtomicLong：原子更新长整型。</ul><p><strong>原子更新数组</strong></p><ul><li>AtomicIntegerArray：原子更新整数组里的元素；<li>AtomicLongArray：原子更新长整形数组里的元素；<li>AtomicReferenceArray：原子更新引用数组里的元素。</ul><p><strong>原子更新引用类型</strong></p><ul><li>AtomicReference：原子更新引用类型；<li>AtomicStampedReference：原子更新引用类型，内部使用Pair来存储元素值及其版本号；<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</ul><p><strong>原子更新字段类</strong></p><ul><li>AtomicIntegerFiledUpdater：原子更新整型字段的更新器；<li>AtomicLongFieldUpdater：原子更新整型字段的更新器；<li>AtomicReferenceFieldUpdater：更新的字段必须要用volatile修饰。</ul><h3 id="8-juc原子类和锁"><span class="mr-2">8. JUC原子类和锁</span><a href="#8-juc原子类和锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="locksupport"><span class="mr-2">LockSupport</span><a href="#locksupport" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>LockSupport是一个线程阻塞工具类，所有的方法都是静态方法。主要有两类方法park和unpark。</p><p>当调用park时，表示阻塞当前线程，直到unpark方法调用或当前线程被中断，park方法才会返回。当调用unpark时，必须把等待获得许可的线程作为参数进行传递，来唤醒处于阻塞状态的线程。</p><p>其和显式锁、隐式锁等待唤醒的区别</p><ul><li>park和unpark方法的调用不需要获取锁。<li>先调用unpark方法后调用park方法依然可以唤醒。<li>park方法响应中断，线程被中断后park方法直接返回，但是不会抛InterruptedException异常。<li>unpark方法是直接唤醒指定的线程。</ul><p><strong>LockSupport.park</strong></p><p>阻塞线程，并且该线程在下列情况发生之前都会被阻塞：</p><ul><li>调用unpark函数，释放该线程的许可；<li>该线程被中断；<li>设置的时间到了，当time设为0，则表示无限等待，直到unpark发送。</ul><p>park函数有两个版本，区别在于无参或传入block参数。</p><p><strong>LockSupport.unpark</strong></p><p>如果传入的线程在park上受阻塞，则将它解除其阻塞状态，否则，保障下一次调用park不会受阻塞。如果给定的线程尚未启动，则无法保证效果。</p><p><strong>线程同步</strong></p><p>使用wait/notify实现同步时，必须先调用wait，后调用notify。如果先调用notify，再调用wait，则无法起作用，线程会一直阻塞；</p><p>使用park/unpark实现线程同步时，如果先调用unpark再调用park，线程仍然能正确实现同步，不会被阻塞，跳过park继续执行后续内容，不会造成由wait/notify顺序不当引起的阻塞，因此park/unpark更灵活。</p><p><strong>Object.wait()和LockSupport.park()的区别</strong></p><ul><li>wait()方法需要在synchronized块中执行，park()方法可以在任意地方执行；<li>wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出，park()不需要捕获异常；<li>wait()不带超时的时候，需要另一个线程执行notify()唤醒，但不一定执行后续内容；<li>park()不带超时的时候，需要另一个线程执行unpark()唤醒，一定会执行后续内容。</ul><h4 id="aqs"><span class="mr-2">AQS</span><a href="#aqs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>AQS是一个用来构建锁和同步器的框架，其内部使用同步队列来解决实现同步器时的一些细节。使用AQS能简单且高效地构造出应用广泛的大量同步器，比如ReentrantLock，Semaphore， 其他诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask都是基于AQS的。</p><p><strong>核心思想</strong></p><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制。这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p><strong>AQS使用一个int成员</strong> <code class="language-plaintext highlighter-rouge">state</code> <strong>变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</strong></p><p><strong>资源共享方式</strong></p><p>AQS定义两种资源共享方式</p><ul><li>Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</ul><li>Share(共享)：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</ul><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队/唤醒出队等)，AQS已经在上层已经帮我们实现好了。</p><p><strong>AQS参数</strong></p><p>AQS使用了模版方法模式，使用者继承AQS并重写指定的方法。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">isHeldExclusively</span><span class="o">()</span><span class="c1">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
<span class="n">tryAcquire</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="c1">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
<span class="n">tryRelease</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="c1">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="n">tryAcquireShared</span><span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="c1">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
</pre></table></code></div></div><p>这些方法的实现必须是内部线程安全的。</p><p><strong>AQS数据结构</strong></p><p>AQS底层使用CLH队列，其是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。</p><p><strong>在AQS中所有等待锁的线程都会被包装成Node扔到一个同步队列中。</strong>每个结点包含了一个thread类型的引用，并且每个结点还存在一个状态<code class="language-plaintext highlighter-rouge">waitStatus</code>，具体状态如下</p><ul><li><code class="language-plaintext highlighter-rouge">CANCELLED</code>，值为1，表示当前的线程被取消。<li><code class="language-plaintext highlighter-rouge">SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。<li><code class="language-plaintext highlighter-rouge">CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition queue中。<li><code class="language-plaintext highlighter-rouge">PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行。<li>值为0，表示当前节点在sync queue中，等待着获取锁。</ul><p><strong>Sync queue</strong></p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/1460000016446954" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/1460000016446954" alt="dummy head" class="lazyload" data-proofer-ignore></a></p><p><code class="language-plaintext highlighter-rouge">sync queue</code>，同步队列，是一个双向链表，我们使用<code class="language-plaintext highlighter-rouge">prev</code>、<code class="language-plaintext highlighter-rouge">next</code>属性来串联节点。但是在这个同步队列中，我们一直没有用到<code class="language-plaintext highlighter-rouge">nextWaiter</code>属性，即使是在共享锁模式下，这一属性也只作为一个标记，指向了一个空节点，因此，在<code class="language-plaintext highlighter-rouge">sync queue</code>中，我们不会用它来串联节点。</p><p><strong>Condtion queue</strong></p><p>条件队列不是必须的，每创建一个Condtion对象就会对应一个Condtion队列，每一个调用了Condtion对象的await方法的线程都会被包装成Node扔进一个条件队列中:</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/1460000016462284" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/1460000016462284" alt="Conditon queue" class="lazyload" data-proofer-ignore></a></p><p>每一个Condition对象对应一个Conditon队列，每个Condtion队列都是独立的，互相不影响的。在上图中，如果我们对当前线程调用了<code class="language-plaintext highlighter-rouge">notFull.await()</code>, 则当前线程就会被包装成Node加到<code class="language-plaintext highlighter-rouge">notFull</code>队列的末尾。</p><p>一般情况下，等待锁的同步队列和条件队列是相互独立的，彼此之间没有任何关系，但是当调用某个条件队列的signal方法时，会将某个或所有等待在这个条件队列中的线程唤醒，被唤醒的线程和普通线程一样要去争锁，如果没有抢到则同样要被加到等待锁的同步队列中，此时结点就<strong>一个一个</strong>的从条件队列转移到同步队列中。</p><p><strong>总结</strong></p><p>对于AbstractQueuedSynchronizer的分析，最核心的就是sync queue的分析。</p><ul><li>每一个结点都是由前一个结点唤醒。<li>当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。<li>condition queue中的结点向sync queue中转移是通过signal操作完成的。<li>当结点的状态为SIGNAL时，表示后面的结点需要运行。</ul><h4 id="reentrantlock"><span class="mr-2">ReentrantLock</span><a href="#reentrantlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>ReentrantLock实现了Lock接口，Lock接口中定义了lock与unlock相关操作，并且还存在newCondition方法，表示生成一个条件。</p><p><strong>ReentrantLock是一种悲观锁</strong>，它总是假设竞争条件总是会发生，所以它同一时刻只有一个线程能获得锁。其支持公平和非公平性的获取锁，内部默认是<strong>非公平锁</strong>, 因为非公平锁的吞吐量会比公平锁高。</p><p>由于ReentrantLock基于AQS实现的，所以它支持三种方式获取锁:</p><ul><li><code class="language-plaintext highlighter-rouge">lock()</code>: 不支持中断的获取锁；<li><code class="language-plaintext highlighter-rouge">lockInterruptibly()</code>: 响应中断地获取锁；<li><code class="language-plaintext highlighter-rouge">tryLock(long timeout, TimeUnit unit)</code>: 响应中断并且支持超时获取锁。</ul><h4 id="reentrantreadwritelock"><span class="mr-2">ReentrantReadWriteLock</span><a href="#reentrantreadwritelock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>ReentrantReadWriteLock底层是基于ReentrantLock和AQS来实现的，<strong>ReentrantReadWriteLock是一种乐观锁</strong>，它假设竞争条件并不会经常发生，所以同一时刻能让多个线程执行。它将读写分离，在进行读操作时，多个线程可以同时获取锁，这样能更好的提高并发度。</p><p>其有以下特性：</p><ul><li>公平性: 与ReentrantLock一样，ReentrantReadWriteLock内部也是支持公平性和非公平性锁，默认是非公平性的锁；<li>可重入: ReentrantReadWriteLock支持一个线程多次获取锁；<li>读写分离: ReentrantReadWriteLock内部维护两个锁，一个是读锁，另外一个是写锁. 在读多写少的情况下，ReentrantReadWriteLock能发挥更大的并发度。因为ReentrantReadWriteLock支持多个读线程同时获取锁。ReentrantReadWriteLock的读写规则: 当一个写线程获得锁后, 其他线程不能获取锁. 当读线程获得锁后, 其他的读线程可以获得锁，但是写线程不能；<li>锁降级: 当一个线程持有写锁后, 再获取读锁, 然后释放写锁, 这个过程称为一个锁的降级。ReentrantReadWriteLock不支持锁的升级, 因为锁的升级有可能带来竞争条件的问题。</ul><p>AQS中的状态int类型有32位, ReentrantReadWriteLock将高16位作为读状态，低16位作为写状态，这样每次通过一定的位运算来获取高16位或者低16位。</p><h3 id="9-juc集合"><span class="mr-2">9. JUC集合</span><a href="#9-juc集合" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="concurrenthashmap"><span class="mr-2">ConcurrentHashMap</span><a href="#concurrenthashmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Hashtable是线程安全的，但是效率低下，因为使用了synchronized关键字对put进行加锁，而synchronized关键字是对整个对象进行加锁，所以在put操作下会把整张表锁住，所以效率低下。</p><p>在JDK1.7之前，ConcurrentHashMap是通过锁分段机制来实现的，所以最大并发度受到Segment个数的限制，而在JDK1.8中，选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和Synchronized实现。</p><p><strong>数据结构</strong></p><p>在java1.7之前，concurrentHashMap是一个Segment数组，Segment通过继承ReentrantLock来进行加锁，所以每次加锁锁住的都是一个segment，这样只要保证每个segment是线程安全的即可。</p><p>而在 Java8 之后，concurrentHashMap的结构和 HashMap 基本一样，不过它要保证线程安全性，所以在源码上要复杂一些。</p><p><strong>并发性分析</strong></p><p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，而由于get操作不会加锁，所以并发问题主要出现在get操作中同时发生put或remove的情况。</p><ul><li>put 操作的线程安全性。<ul><li>初始化槽，使用了 CAS 来初始化 Segment 中的数组。<li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。<li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</ul><li>remove 操作的线程安全性。<ul><li>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。<li>如果 remove 先破坏了一个节点，分两种情况考虑。 1、如果此节点是头节点，那么需要将头节点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组。2、如果要删除的节点不是头节点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</ul></ul><h4 id="copyonwritearraylist"><span class="mr-2">CopyOnWriteArrayList</span><a href="#copyonwritearraylist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>CopyOnWriteArrayList实现了List接口，List接口定义了对列表的基本操作，同时也实现了RandomAccess接口，表示可以随机访问，同时实现了Cloneable接口，表示可克隆；同时也实现了Serializable接口，表示可被序列化。</p><p><strong>类的属性</strong></p><p>CopyOnWriteArrayList的部分属性如下</p><p>（transient是Java的关键字，<strong>用来表示一个成员变量不是该对象序列化的一部分</strong>）</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="nc">List</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;,</span> <span class="nc">RandomAccess</span><span class="o">,</span> <span class="nc">Cloneable</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
    <span class="c1">// 版本序列号</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="mi">8673264195747942595L</span><span class="o">;</span>
    <span class="c1">// 可重入锁</span>
    <span class="kd">final</span> <span class="kd">transient</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
    <span class="c1">// 对象数组，用于存放元素</span>
    <span class="kd">private</span> <span class="kd">transient</span> <span class="kd">volatile</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    <span class="c1">// 反射机制</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span> <span class="no">UNSAFE</span><span class="o">;</span>
    <span class="c1">// lock域的内存偏移量</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">lockOffset</span><span class="o">;</span>
    <span class="kd">static</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="no">UNSAFE</span> <span class="o">=</span> <span class="n">sun</span><span class="o">.</span><span class="na">misc</span><span class="o">.</span><span class="na">Unsafe</span><span class="o">.</span><span class="na">getUnsafe</span><span class="o">();</span>
            <span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">k</span> <span class="o">=</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
            <span class="n">lockOffset</span> <span class="o">=</span> <span class="no">UNSAFE</span><span class="o">.</span><span class="na">objectFieldOffset</span>
                <span class="o">(</span><span class="n">k</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"lock"</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>其内部还包括一个内部类COWIterator，表示迭代器，其也有一个Object数组作为CopyOnWriteArrayList数组的快照，这种快照风格的迭代器方法在创建迭代器时使用了对当前数组的引用。此数组在迭代器的生存周期内不会更改，因此不可能发生冲突。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。在迭代器上进行的元素更改操作(remove、set 和 add)不受支持。</p><p><strong>构造函数</strong></p><p>CopyOnWriteArrayList有三种构造函数，默认无参构造，<code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList(Collection&lt;? extends E&gt;)</code> 型构造函数和 <code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList(E[])</code> 构造函数。</p><p><code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList(Collection&lt;? extends E&gt;)</code> 构造函数用来创建一个按照collection的迭代器返回元素的顺序包含指定collection的元素列表。</p><p>该构造函数的处理流程如下：</p><ul><li>判断传入的集合c的类型是否为CopyOnWriteArrayList类型，若是，则获取该集合类型的底层数组Object[]，并且设置当前CopyOnWriteArrayList的数组，进入步骤③；否则，进入步骤②。<li>将传入的集合转化为数组elements，判断elements的类型是否为Object[]类型，若不是，则将elements转化为Object类型的数组。<li>设置当前CopyOnWriteArrayList的数组为elements。</ul><p><code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList(E[])</code> 构造函数</p><p>该构造函数用于创建一个保存给指定数组的副本的列表。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nf">CopyOnWriteArrayList</span><span class="o">(</span><span class="no">E</span><span class="o">[]</span> <span class="n">toCopyIn</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 将toCopyIn转化为Object[]类型数组，然后设置当前数组</span>
    <span class="n">setArray</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">toCopyIn</span><span class="o">,</span> <span class="n">toCopyIn</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="nc">Object</span><span class="o">[].</span><span class="na">class</span><span class="o">));</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>copyOf函数</strong></p><p>该函数用于复制指定的数组，截取或用null填充，使得副本有指定的长度。</p><p><strong>add函数</strong></p><p>此函数用于将指定的元素添加到此列表的尾部，处理流程如下</p><ul><li>获取锁，获取当前的Object数组，获取Object数组的长度为length。<li>根据Object数组复制一个长度为length+1的Object数组为newElements。<li>将下标为length的数组元素newElements[length]设置为元素e，在设置当前Object[]为newElements，释放锁，返回。这样就完成了元素的添加。</ul><p><strong>set函数</strong></p><p>该函数用于指定元素替代此列表指定位置上的元素，也是基于数组的复制来实现的。</p><p><strong>remove函数</strong></p><p>此函数用于移除此列表指定位置上的元素。</p><ul><li>获取锁，获取当前的Object数组elements，获取数组的长度为length。获取索引的值elements[index]，计算需要移动的元素个数(length - index - 1)，如果个数为0，则表示移除的是数组最后一个元素，复制elements数组，复制长度为length-1，然后设置数组/<li>如果移除的不是最后一个元素，则先复制index索引前的元素，再复制index索引后的元素，然后设置数组。<li>释放锁，返回旧值。</ul><p><strong>总结</strong></p><ol><li><p>该方法是线程安全的。</p><li><p>在add()的时候会加Lock锁，然后复制出个新的数组，往新的数组里面add真正的元素，最后把array的指向改变为新的数组。</p><li><p>get()方法或者是size()方法只是获取array所指向的元素或者大小，读不加锁，但是写加锁。</p><li><p>很耗费内存，每次set，add都会复制一个数组出来。</p><li><p>只能保证数据最终一致性，不能保证数据的实时一致性。</p><p>假设有两个线程，A 去读CopyOnWriteArrayList 的数据还没读完，如果现在线程B把这个List给清空了，线程 A此时还是可以把剩余数据给读出来。</p></ol><h2 id="线程池"><span class="mr-2">线程池</span><a href="#线程池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-线程和进程的区别"><span class="mr-2">1. 线程和进程的区别</span><a href="#1-线程和进程的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>进程是对运行时程序的封装，是<strong>系统进行资源调度和分配的的基本单位，实现了操作系统的并发</strong>；</p><p>线程是进程的子任务，<strong>是CPU调度和分派的基本单位</strong>，<strong>用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位</strong>。每个线程都独自占用一个<strong>虚拟处理器</strong>：独自的<strong>寄存器组</strong>，<strong>指令计数器和处理器状态</strong>。每个线程完成不同的任务，但是<strong>共享同一地址空间</strong>（也就是同样的<strong>动态内存，映射文件，目标代码等等</strong>），<strong>打开的文件队列和其他内核资源</strong>。</p><p>线程在进程下行进（单纯的车厢无法运行）</p><p>一个进程可以包含多个线程（一辆火车可以有多个车厢）</p><p>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</p><p>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</p><p>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</p><p>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</p><p>进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）</p><p>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”</p><p>进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</p><p><strong>僵尸进程</strong>：一个<strong>进程</strong>使用fork创建子<strong>进程</strong>，如果子<strong>进程</strong>退出，而父<strong>进程</strong>并没有调用wait 或waitpid 获取子<strong>进程</strong>的状态信息，那么子<strong>进程</strong>的<strong>进程</strong>描述符仍然保存在系统中，这种<strong>进程</strong>称之为僵尸<strong>进程</strong>。</p><p><strong>孤儿进程</strong>：一个父<strong>进程</strong>退出，而它的一个或多个子<strong>进程</strong>还在运行，那么这些子<strong>进程</strong>将成为<strong>孤儿进程</strong>。</p><h3 id="2-futuretask"><span class="mr-2">2. FutureTask</span><a href="#2-futuretask" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>FutureTask为Future提供了基础实现，如获取任务执行结果和取消任务等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消。FutureTask常用来封装Callable和Runnable，也可以作为一个任务提交到线程池中执行。</p><h4 id="关系"><span class="mr-2">关系</span><a href="#关系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/java-thread-x-juc-futuretask-1.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/java-thread-x-juc-futuretask-1.png" alt="img" class="lazyload" data-proofer-ignore></a></p><p>FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口。所以FutureTask既能当一个Runnable接口被Thread执行，也能作为Future用来得到Callable的计算结果。</p><h4 id="核心属性"><span class="mr-2">核心属性</span><a href="#核心属性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">//内部持有的callable任务，运行完毕后置空</span>
<span class="kd">private</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">callable</span><span class="o">;</span>

<span class="c1">//从get()中返回的结果或抛出的异常</span>
<span class="kd">private</span> <span class="nc">Object</span> <span class="n">outcome</span><span class="o">;</span> <span class="c1">// non-volatile, protected by state reads/writes</span>

<span class="c1">//运行callable的线程</span>
<span class="kd">private</span> <span class="kd">volatile</span> <span class="nc">Thread</span> <span class="n">runner</span><span class="o">;</span>

<span class="c1">//使用Treiber栈保存等待线程</span>
<span class="kd">private</span> <span class="kd">volatile</span> <span class="nc">WaitNode</span> <span class="n">waiters</span><span class="o">;</span>

<span class="c1">//任务状态</span>
<span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">NEW</span>          <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">COMPLETING</span>   <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">NORMAL</span>       <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">EXCEPTIONAL</span>  <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">CANCELLED</span>    <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">INTERRUPTING</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">INTERRUPTED</span>  <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>
</pre></table></code></div></div><p>其中需要注意的是state是volatile类型的，也就是说只要有任何一个线程修改了这个变量，那么其他所有的线程都会知道最新的值。7种状态具体表示：</p><ul><li><code class="language-plaintext highlighter-rouge">NEW</code>:表示是个新的任务或者还没被执行完的任务。这是初始状态。<li><code class="language-plaintext highlighter-rouge">COMPLETING</code>:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。<li><code class="language-plaintext highlighter-rouge">NORMAL</code>:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。<li><code class="language-plaintext highlighter-rouge">EXCEPTIONAL</code>:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。<li><code class="language-plaintext highlighter-rouge">CANCELLED</code>:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。<li><code class="language-plaintext highlighter-rouge">INTERRUPTING</code>: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。<li><code class="language-plaintext highlighter-rouge">INTERRUPTED</code>:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。 有一点需要注意的是，所有值大于COMPLETING的状态都表示任务已经执行完成(任务正常执行完成，任务执行异常或者任务被取消)。</ul><p>各个状态之间的可能转换关系如下图所示：</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/java-thread-x-juc-futuretask-2.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/java-thread-x-juc-futuretask-2.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h3 id="3-线程池"><span class="mr-2">3. 线程池</span><a href="#3-线程池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>线程池（Thread Pool）</strong>是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。</p><p>线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</p><p>使用线程池可以带来一系列好处：</p><ul><li><strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。<li><strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。<li><strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</ul><h4 id="线程池解决的问题"><span class="mr-2">线程池解决的问题</span><a href="#线程池解决的问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>线程池解决的核心问题就是资源管理问题。</p><p>在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。</p><h4 id="核心设计与实现"><span class="mr-2">核心设计与实现</span><a href="#核心设计与实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Java中的线程池核心实现类是ThreadPoolExecutor，ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。</p><p>ThreadPoolExecutor运行机制如图：</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/77441586f6b312a54264e3fcf5eebe2663494.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/77441586f6b312a54264e3fcf5eebe2663494.png" alt="图2 ThreadPoolExecutor运行流程" class="lazyload" data-proofer-ignore></a></p><p>Java线程池的实现原理，简要来说时一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务时，线程池会先将任务放在workQueue中，workerSet中的线程会不断的从workQueue中获取线程然后执行。当workQueue中没有任务的时候，worker就会阻塞，直到队列中有任务了就取出来继续执行。</p><h4 id="execute原理"><span class="mr-2">Execute原理</span><a href="#execute原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当一个任务提交至线程池之后：</p><ul><li>线程池首先判断当前运行的线程数量是否少于corePoolSize，如果是，则创建一个新的工作线程来执行任务，如果都在执行任务，则进入下一步；<li>判断BlockingQueue是否已经满了，如果还没满，则将线程放入BlockingQueue，否则进入下一步；<li>如果创建一个新的工作线程将使当前运行的线程数量超过maximumPoolSize，则交给RejectedExecutionHandler来处理任务。</ul><p>当ThreadPoolExecutor创建新线程时，通过CAS来更新线程池状态。</p><h4 id="线程池的创建"><span class="mr-2">线程池的创建</span><a href="#线程池的创建" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>通过Executors类提供的方法。</strong></p><ol><li><p><strong>newCachedThreadPool</strong></p><p>创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。</p><li><p><strong>newFixedThreadPool</strong></p><p>创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。</p><li><p><strong>newSingleThreadExecutor</strong></p><p>创建一个单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p>—————————————–（后面不常用）————————————————–</p><li><p><strong>newScheduledThreadPool</strong></p><p>创建一个周期性的线程池，支持定时及周期性执行任务。</p><li><p><strong>newSingleThreadScheduledExecutor</strong></p><p>创建一个单线程的可以执行延迟任务的线程池。</p><li><p><strong>newWorkStealingPool</strong></p><p>创建一个抢占式执行的线程池(任务执行顺序不确定)。</p></ol><p><strong>通过ThreadPoolExecutor类自定义。</strong></p><pre><code class="language-Java">public ThreadPoolExecutor(int corePoolSize,
	int maximumPoolSize,
	long keepAliveTime,
	TimeUnit unit,
	BlockingQueue&lt;Runnable&gt; workQueue,
	ThreadFactory threadFactory,
	RejectedExecutionHandler handler) {
	// 省略...
}
</code></pre><p>具体参数如下</p><ul><li><code class="language-plaintext highlighter-rouge">corePoolSize</code> 线程池中的核心线程数。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize，即使有其他空闲的线程能够执行新来的任务，也会继续创建线程。如果当前线程数等于corePoolSize，继续提交的任务会被保存到阻塞队列中等待被执行。<li><code class="language-plaintext highlighter-rouge">workQueue</code> 用来保存等待被执行的任务的阻塞队列，在JDK中有如下队列：<ul><li><code class="language-plaintext highlighter-rouge">ArrayBlockingQueue</code>: 基于数组结构的有界阻塞队列，按FIFO排序任务；<li><code class="language-plaintext highlighter-rouge">LinkedBlockingQueue</code>: 基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue；<li><code class="language-plaintext highlighter-rouge">SynchronousQueue</code>: 一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue；<li><code class="language-plaintext highlighter-rouge">PriorityBlockingQueue</code>: 具有优先级的无界阻塞队列；</ul><li><code class="language-plaintext highlighter-rouge">maximumPoolSize</code> 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，直到线程数为maximumPoolSize；当阻塞队列是无界队列，则最大线程数不起作用。<li><code class="language-plaintext highlighter-rouge">keepAliveTime</code> 线程空闲时的存活时间，即当线程没有任务执行时，该线程继续存活的时间。默认情况下该参数只有线程数大于corePoolSize时才有用，超过这个时间点空闲线程将被终止。<li><code class="language-plaintext highlighter-rouge">unit </code> keepAliveTime的单位。<li><code class="language-plaintext highlighter-rouge">threadFactory </code> 创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名。默认为DefaultThreadFactory。<li><code class="language-plaintext highlighter-rouge">handler </code> 线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:<ul><li><code class="language-plaintext highlighter-rouge">AbortPolicy</code>: 直接抛出异常，默认策略；<li><code class="language-plaintext highlighter-rouge">CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；<li><code class="language-plaintext highlighter-rouge">DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；<li><code class="language-plaintext highlighter-rouge">DiscardPolicy</code>: 直接丢弃任务。</ul></ul><p>Executors 返回的线程池对象的弊端如下：</p><ul><li><p>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p><li><p>CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></ul><p>线程池的创建推荐使用最后一种 ThreadPoolExecutor 的方式来创建，因为使用它可以明确线程池的运行规则，规避资源耗尽的风险。</p><h5 id="threadlocal"><span class="mr-2">ThreadLocal</span><a href="#threadlocal" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><p>ThreadLocal（线程本地存储）提供了一种方式，让在多线程环境下，每个线程都可以拥有自己私有的数据结构，进而减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。但因为其自身的实现机制，使用之后记得及remove，避免内存泄露。</p><h2 id="设计模式"><span class="mr-2">设计模式</span><a href="#设计模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><h3 id="1-分类"><span class="mr-2">1. 分类</span><a href="#1-分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</strong></p><p><strong>结构型模式：把类或对象结合在一起形成一个更大的结构。</strong></p><p><strong>行为型模式：类和对象如何交互，及划分责任和算法。</strong></p><h3 id="2-特点"><span class="mr-2">2. 特点</span><a href="#2-特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="创建型模式"><span class="mr-2">创建型模式</span><a href="#创建型模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>单例模式：某个类只能有一个实例，提供一个全局的访问点。</p><p>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</p><p>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。</p><p>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。</p><p>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。</p><p>原型模式：通过复制现有的实例来创建新的实例。</p><h4 id="结构型模式"><span class="mr-2">结构型模式</span><a href="#结构型模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。</p><p>组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</p><p>装饰模式：动态的给对象添加新的功能。</p><p>代理模式：为其他对象提供一个代理以便控制这个对象的访问。</p><p>亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。</p><p>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</p><p>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</p><h4 id="行为型模式"><span class="mr-2">行为型模式</span><a href="#行为型模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</p><p>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</p><p>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</p><p>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</p><p>观察者模式：对象间的一对多的依赖关系。</p><p>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。</p><p>中介者模式：用一个中介对象来封装一系列的对象交互。</p><p>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</p><p>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</p><p>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</p><p>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</p><h3 id="3-单例模式"><span class="mr-2">3. 单例模式</span><a href="#3-单例模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>单例模式指<strong>在程序运行期间, 某些类有且最多只有一个实例对象。</strong></p><p>其优势是尽可能节约内存空间，减少垃圾回收的消耗，并使得程序正常运行。</p><h4 id="实现思路"><span class="mr-2">实现思路</span><a href="#实现思路" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>静态化实例对象，让实例对象与Class相互绑定，通过Class类对象可以直接访问；<li><strong>私有化构造方法，禁止通过构造方法创建多个实例</strong>；<li>提供一个公共的静态方法，用来返回这个类的唯一实例。</ol><h4 id="实现方法"><span class="mr-2">实现方法</span><a href="#实现方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>饿汉模式（eager）</strong></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 饿汉模式: 类加载时就初始化
 */</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="nc">HungrySingleton</span> <span class="o">{</span>
    <span class="cm">/** 实例对象 */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">HungrySingleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HungrySingleton</span><span class="o">();</span>

    <span class="cm">/** 禁用构造方法 */</span>
    <span class="kd">private</span> <span class="nf">HungrySingleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

    <span class="cm">/**
     * 获取单例对象, 直接返回已创建的实例
     * @return instance 本类的实例
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">HungrySingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>优点是线程安全，JVM在加载这个类的时候就会对它进行初始化，这里包含对静态变量的初始化；缺点是容易造成空间的浪费。</p><p><strong>懒汉模式（lazy）</strong></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 懒汉模式: 用到时再初始化, 线程不安全, 可以在方法上使用synchronized关键字实现线程安全
 */</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="nc">LazySingleton</span> <span class="o">{</span>
    <span class="cm">/** 实例对象 */</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">LazySingleton</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="cm">/** 禁用构造方法 */</span>
    <span class="kd">private</span> <span class="nf">LazySingleton</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>

    <span class="cm">/**
     * 线程不安全, 可以在方法上使用synchronized关键字实现线程安全
     * @return instance 本类的实例
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">LazySingleton</span> <span class="nf">getInstance</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LazySingleton</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>优点是节省空间，用到的时候再创建实例对象。但是缺点是线程不安全，因为可能两个线程同时进入if语句，从而创建出两个实例。</p><p><strong>枚举类</strong></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 枚举类单例模式
 */</span>
<span class="kd">enum</span> <span class="nc">EnumSingleton</span> <span class="o">{</span>
    <span class="cm">/** 此枚举类的一个实例, 可以直接通过EnumSingleton.INSTANCE来使用 */</span>
    <span class="no">INSTANCE</span>
<span class="o">}</span>
</pre></table></code></div></div><p>优点是不需要考虑序列化问题，枚举序列化是由JVM保证的，每一个枚举类型和枚举变量在JVM中都是唯一的；也不需要考虑反射问题，因为不能通过反射创建枚举实例的。</p><p>缺点是所有的属性都必须在创建时指定，也就意味着不能延迟加载；并且使用枚举时占用的内存比静态变量的2倍还多, 这在性能要求严苛的应用中是不可忽视的。</p><h4 id="单例模式的破坏"><span class="mr-2">单例模式的破坏</span><a href="#单例模式的破坏" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>反射攻击</strong></p><p>反射是通过调用构造方法生成新的对象，对于类的私有构造函数，反射可以直接访问。所以可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例, 如:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nf">Singleton</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instance</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"Singleton already initialized, 此类是单例类, 不允许生成新对象"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>序列化</strong></p><p>如果单例类实现了序列化接口Serializable，就可以通过反序列化破坏单例，解决方法是：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 反序列化时直接返回当前实例</span>
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">readResolve</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Object.clone()</strong></p><p>Object.clone()方法也会破坏单例, 即使你没有实现Cloneable接口，因为clone()方法是Object类中的. 解决方法是重写clone()方法。</p><h2 id="消息队列"><span class="mr-2">消息队列</span><a href="#消息队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-基础-1"><span class="mr-2">1. 基础</span><a href="#1-基础-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>消息队列中间件是分布式系统中重要的组件，主要用于应用解耦，异步消息，流量削峰等问题。实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，RocketMQ。</p><p>MQ是消费者-生产者的一个典型代表，一端往消息队列中不断写入消息，而另一端则可以读取队列中的消息。消息的发布者只管把消息发布到MQ中而不管谁来取用，消息使用者只管从MQ中取消息而不关注是谁发布的。</p><h3 id="2-mq通信模型"><span class="mr-2">2. MQ通信模型</span><a href="#2-mq通信模型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>MQ通信模型有以下类型</p><ul><li><p><strong>点对点</strong>：点对点方式是最传统的通讯方式，它支持一对一，一对多，多对多和多对一等配置方式，支持树状，网状等拓扑结构。</p><li><p><strong>多点广播</strong>：能够将消息发送到多个目标站点，并确保为每一个站点可靠的提供消息。</p><li><p><strong>发布-订阅</strong>：Pub-Sub模式使得消息的分发可以突破目的队列地理位置的限制，使消息按照特定的主题甚至内容进行分发，用户或应用可以根据主题或内容接受所需要的消息。Pub-Sub模式使得发送者和接收者之间的耦合关系变得更加松散。</p><li><p><strong>集群</strong>：为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster(集群) 的解决方案。集群类似于一个域，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用集群通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性</p></ul><h3 id="3-mq的应用"><span class="mr-2">3. MQ的应用</span><a href="#3-mq的应用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="异步处理"><span class="mr-2">异步处理</span><a href="#异步处理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>MQ可以将系统之间的处理流程异步化，减少等待响应的时间，从而提高整体并发吞吐量。一般MQ异步处理应用于非核心流程，例如短信/邮件通知，数据推送，上报数据等。</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/mq_4.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/mq_4.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="系统解耦"><span class="mr-2">系统解耦</span><a href="#系统解耦" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>通过MQ，可以消除系统之间的强耦合，其优点如下</p><ul><li>消息的消费者系统可以随意增加，无需修改生产者的系统代码；<li>生产者系统和消费者系统彼此不会影响对方的流程。<ul><li>如果生产者系统宕机，消费者系统收不到消息，就不会有下一步的动作。<li>如果消费者系统宕机，生产者系统让然可以正常发送消息，不影响流程。</ul></ul><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/mq_2.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/mq_2.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="流量削峰"><span class="mr-2">流量削峰</span><a href="#流量削峰" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当上下游处理能力存在差距时，利用MQ做一个漏斗模型，进行流控，可以把MQ当成可靠的消息暂存地，进行一定程度的消息堆积，在下游有能力处理的时候在进行发送。MQ 的流量削峰常用于高并发场景（例如：秒杀、团抢等业务场景），它是缓解瞬时暴增流量的核心手段之一。</p><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/mq_6.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/mq_6.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="传输缓冲"><span class="mr-2">传输缓冲</span><a href="#传输缓冲" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>MQ常被用于做海量数据的传输缓冲，例如kafka常被用于做为各种日志数据、采集数据的数据中转。然后，Kafka 将数据转发给 Logstash、Elasticsearch 中，然后基于 Elasticsearch 来做日志中心，提供检索、聚合、分析日志的能力。开发者可以通过 Kibana 集成 Elasticsearch 数据进行可视化展示，或自行进行定制化开发。</p><p>MQ也可以被用于流式处理，比如Kafka几乎已经是流计算的数据采集端的标准组件。而流计算通过实时数据处理能力，提供了更为快捷的聚合计算能力，被大量应用于链路监控、实时监控、实时数仓、实时大屏、风控、推荐等应用领域。</p><h3 id="4-mq的问题"><span class="mr-2">4. MQ的问题</span><a href="#4-mq的问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="重复消费"><span class="mr-2">重复消费</span><a href="#重复消费" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>以Kafka为例，Kakfa的每个Partition都是一个有序的，不可变的记录序列，不断追加到结构化的提交日志中。Partition 中为每条记录分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的记录。</p><p>Kafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。</p><p>如果客户端应用消费消息后，因为宕机，重启等没有提交已消费的Offset，当系统恢复后就会出现重复提交。</p><p>应对重复消费的方式就是在业务层面通过幂等性设计来解决。比如重复判断，全局唯一ID。</p><h4 id="消息丢失"><span class="mr-2">消息丢失</span><a href="#消息丢失" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>唯一可能导致消费方丢失数据的情况是：消费方设置了<strong>自动提交 Offset</strong>。可以关闭此功能来防止消息丢失。</p><h4 id="消息的顺序性"><span class="mr-2">消息的顺序性</span><a href="#消息的顺序性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>写入数据到 Partition 时指定一个全局唯一的 ID，例如订单 ID。发送方保证相同 ID 的消息有序的发送到同一个 Partition。</p><h4 id="消息积压"><span class="mr-2">消息积压</span><a href="#消息积压" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>临时增加Consumer的数量。</p><h3 id="5-mq的高可用以kafka为代表"><span class="mr-2">5. MQ的高可用：以Kafka为代表</span><a href="#5-mq的高可用以kafka为代表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="kafka核心概念"><span class="mr-2">Kafka核心概念</span><a href="#kafka核心概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Kafka包含以下几部分</p><ul><li><strong>Broker</strong>：Kafka集群包含一个或多个节点，这种节点被称为Broker；<li><strong>Topic</strong>：每条发布到Kafka集群里的消息都有一个类别，这个类别被称为Topic。不同 Topic 的消息是物理隔离的；同一个 Topic 的消息保存在一个或多个 Broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处。<li><strong>Partition</strong>：提高了Kafla的吞吐率，每个Topic包含一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition所有的消息和索引文件。</ul><p><a href="/assets/blog_res/2023-03-16-JAVA.assets/kafka-cluster-roles.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-JAVA.assets/kafka-cluster-roles.png" alt="img" class="lazyload" data-proofer-ignore></a></p><h4 id="kafka的副本机制"><span class="mr-2">Kafka的副本机制</span><a href="#kafka的副本机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>为了实现高可用，Kafka 引入了复制功能。<strong>每个 Partition 都有一个 Leader，零个或多个 Follower</strong>。Leader 和 Follower 都是 Broker，每个 Broker 都会成为某些分区的 Leader 和某些分区的 Follower，因此集群的负载是平衡的。Leader处理一切对分区的读写请求，而Follower只需被动的同步Leader上的数据。</p><p>同一个Topic的不同Partition会分布在多个Broker上，而且一个Partition还会在其他的Broker上进行备份。发布者在发布消息到某个分区时，先找到该 Partition 的 Leader，然后向这个 Leader 推送消息；每个 Follower 都从 Leader 拉取消息，拉取消息成功之后，向 Leader 发送一个 ACK 确认。</p><h4 id="kafka-选举-leader"><span class="mr-2">Kafka 选举 Leader</span><a href="#kafka-选举-leader" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Partition 在多个 Broker 上存在副本，如果某个 Follower 宕机，啥事儿没有，正常工作。如果 Leader 宕机了，会从 Follower 中<strong>重新选举</strong>一个新的 Leader。</p><h2 id="其他"><span class="mr-2">其他</span><a href="#其他" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-docker"><span class="mr-2">1. Docker</span><a href="#1-docker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Docker的优势总结如下：</p><ul><li>更快的启动时间。Docker容器启动是几秒钟的事情，因为容器只是一个操作系统进程而已。带有完整操作系统的虚拟机则需要几分钟来加载。<li>更快部署。不需要建立一个新的环境。使用Docker,Web开发团队只需要下载Docker镜像并在不同的服务器上运行。<li>容器更易管理与扩展。因为销毁与运行容器比销毁与运行虚拟机更快。<li>计算资源的更好利用，因为在一个服务器上你可以运行的容器比虚拟机要多。<li>支持多种操作系统，Windows,Mac,Debian等等。</ul><h3 id="2-zookeeper"><span class="mr-2">2. Zookeeper</span><a href="#2-zookeeper" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="介绍"><span class="mr-2">介绍</span><a href="#介绍" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p><h4 id="解决问题"><span class="mr-2">解决问题</span><a href="#解决问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在分布式系统中，以下问题经常出现：</p><ul><li>确定Leader；<li>配置协调管理；<li>群组管理；<li>分布式锁。</ul><h4 id="设计"><span class="mr-2">设计</span><a href="#设计" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>顺序一致性，从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去。<li>原子性，所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。<li>单一视图，无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。<li>可靠性，一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直被保留，除非有另一个事务对其进行了变更。<li>实时性，Zookeeper 保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</ul><h4 id="组成"><span class="mr-2">组成</span><a href="#组成" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><p>客户端: 使用Zookeeper服务，</p><li><p>服务器:用于负载平衡和容错的复制服务集成，</p><li><p>会话:客户端连接到服务器直到其关闭，</p><li><p>Znode:客户端的内存数据对象。像传统的文件系统但不存储太多的文件。</p><p>临时znode:在会话中保持活动，在关闭时进行清理。</p><p>普通znode:由用户创建，由Zookeeper服务维护的根节点。</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >JAVA</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=JAVA%20-%20Eraser&url=%2Fposts%2FJAVA%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=JAVA%20-%20Eraser&u=%2Fposts%2FJAVA%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FJAVA%2F&text=JAVA%20-%20Eraser" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/JAVA/">JAVA</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><li><a href="/posts/JVM/">JVM</a><li><a href="/posts/Spring/">Spring</a><li><a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs5289/">CS5289</a> <a class="post-tag" href="/tags/java/">JAVA</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/reactive-programming/">Reactive Programming</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据库</h3><div class="text-muted small"><p> 数据库 MySQL 1. InnoDB引擎 MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎。 MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是MySQL之前的默认存储引擎。 MEMORY存储引擎提供”内存中”表。MERGE存储引擎允许集合...</p></div></div></a></div><div class="card"> <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>计算机网络</h3><div class="text-muted small"><p> 计算机网络 TCP 1. TCP基础 TCP全程传输控制协议，是面向连接的，可靠的，基于字节流的传输层通信协议。 面向连接：连接是一对一的，而不是和UDP一样可以一堆多； 可靠的：无论网络中出现了怎样的链路变化，TCP都能保证一个报文一定能到达接收端； 字节流：用户消息通过TCP传输时，消息可能会被操作系统分组成多个的TCP报文，如果接收方不知道消息的边界，是无法读取出...</p></div></div></a></div><div class="card"> <a href="/posts/JVM/"><div class="card-body"> <em class="small" data-ts="1647928800" data-df="YYYY/MM/DD" > 2022/03/22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JVM</h3><div class="text-muted small"><p> JVM 类加载 1. 类的生命周期 类加载的过程包括了加载，验证，准备，解析，初始化五个阶段。在这五个阶段中，加载，验证，准备和初始化这四个阶段发生的顺序是确定的，而解析阶段不一定。 加载 类的加载指查找并加载类的二进制数据。加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事： 通过一个类的全限定名来获取其定义的二进制字节流； 将这个字节流所代表的静...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"><div class="btn btn-outline-primary disabled" prompt="上一篇"><p>-</p></div><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="btn btn-outline-primary" prompt="下一篇"><p>数据库</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs5289/">CS5289</a> <a class="post-tag" href="/tags/java/">JAVA</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/reactive-programming/">Reactive Programming</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/EraserE">Eraser</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
