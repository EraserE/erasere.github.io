<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="计算机网络" /><meta name="author" content="Eraser" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="计算机网络" /><meta property="og:description" content="计算机网络" /><link rel="canonical" href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" /><meta property="og:url" content="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" /><meta property="og:site_name" content="Eraser" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-16T02:34:00+00:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="计算机网络" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Eraser" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Eraser"},"dateModified":"2023-10-24T02:53:01+00:00","datePublished":"2022-03-16T02:34:00+00:00","description":"计算机网络","headline":"计算机网络","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},"url":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}</script><title>计算机网络 | Eraser</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Eraser"><meta name="application-name" content="Eraser"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/config/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Eraser</a></div><div class="site-subtitle font-italic">Gura天下第一！</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/erasere" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['m.sathe2900','protonmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>计算机网络</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>计算机网络</h1><div class="post-meta text-muted"> <span> 发表于 <em class="" data-ts="1647398040" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2022/03/16 </em> </span> <span> 更新于 <em class="" data-ts="1698115981" data-df="YYYY/MM/DD" data-toggle="tooltip" data-placement="bottom"> 2023/10/23 </em> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="17588 字"> <em>97 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="计算机网络">计算机网络</h1><h2 id="tcp"><span class="mr-2">TCP</span><a href="#tcp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-tcp基础"><span class="mr-2">1. TCP基础</span><a href="#1-tcp基础" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP全程<strong>传输控制协议</strong>，是<strong>面向连接的，可靠的，基于字节流</strong>的传输层通信协议。</p><ul><li>面向连接：连接是一对一的，而不是和UDP一样可以一堆多；<li>可靠的：无论网络中出现了怎样的链路变化，TCP都能保证一个报文一定能到达接收端；<li>字节流：用户消息通过TCP传输时，消息可能会被操作系统分组成多个的TCP报文，如果接收方不知道消息的边界，是无法读取出有效信息的。TCP消息流有顺序，只有前一个TCP报文收到才能接受下一个报文。</ul><h4 id="tcp头部"><span class="mr-2">TCP头部</span><a href="#tcp头部" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>TCP头部格式分为以下几部分：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/format,png-20230309230534096-0474042.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/format,png-20230309230534096-0474042.png" alt="TCP 头格式" class="lazyload" data-proofer-ignore></a></p><ul><li><strong>序列号</strong>：在建立连接的时候由计算机生成的随机数作为初始值，通过SYN包传给接收端主机，每发送一次，就累加一次该<strong>数据字节数</strong>的大小，<strong>用来解决网络包的乱序问题</strong>。<li><strong>确认应答号</strong>：指下一次期望收到的数据的序列号，发送端收到这个确认应答号之后，可以认为在这个之前的数据已被正常接受，<strong>用来解决丢包问题</strong>。<li><strong>控制位</strong>：<ul><li><code class="language-plaintext highlighter-rouge">ACK</code>：该位为1时，确认应答的字段变为有效，TCP 规定除了最初建立连接时的 <code class="language-plaintext highlighter-rouge">SYN</code> 包之外该位必须设置为 1 。<li><code class="language-plaintext highlighter-rouge">RST</code>：该位为1时，表示 TCP 连接中出现异常必须强制断开连接。<li><code class="language-plaintext highlighter-rouge">SYN</code>：该位为1时，表示希望建立连接，并在其<strong>序列号</strong>的字段进行序列号初始值的设定。<li><code class="language-plaintext highlighter-rouge">FIN</code>：该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code class="language-plaintext highlighter-rouge">FIN</code> 位为 1 的 TCP 段。</ul></ul><h4 id="tcp连接"><span class="mr-2">TCP连接</span><a href="#tcp连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket，序列号和窗口大小称为连接。</strong></p><p>TCP的四元组可以确定唯一一个连接</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E5%9B%9B%E5%85%83%E7%BB%84.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E5%9B%9B%E5%85%83%E7%BB%84.png" alt="TCP四元组" class="lazyload" data-proofer-ignore></a></p><p>源地址和目标地址字段（32位）是在IP头部，作用是通过IP协议发送报文到对方主机。</p><p>源端口和目的端口字段（16位）是在TCP头部，作用是告诉TCP协议该把报文发送到哪个进程中。</p><h4 id="tcpudp"><span class="mr-2">TCP/UDP</span><a href="#tcpudp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>UDP全称<strong>用户数据报协议</strong>，他不提供复杂的控制机制，利用IP提供面向无连接的通信服务。</p><p>UDP协议头部只有8个字节，分别是：源端口和目标端口号，包长度，校验和。</p><p>他们的区别如下：</p><ol><li><p><strong>连接</strong></p><p>TCP是面向连接的传输协议，在传输数据前要先建立连接；UDP不需要建立连接，即刻传输数据。</p><li><p><strong>服务对象</strong></p><p>TCP是一对一的两点服务，仅支持一对一连接；UDP支持一对一，一对多，多对多的交互通信。</p><li><p><strong>可靠性</strong></p><p>TCP是可靠的，数据可以无差错，不丢失，不重复，按顺序到达；UDP 是尽最大努力交付，不保证可靠交付数据。</p><li><p><strong>拥塞控制，流量控制</strong></p><p>TCP拥有流量控制，拥塞控制的功能，保证传输数据的安全，UDP没有。</p><li><p><strong>首部开销</strong></p><p>TCP的首部较长，会有一定的开销，首部在没有使用选项的大小是20字节；UDP首部较短，只有固定的8个字节，开销较小。</p><li><p><strong>传输方式</strong></p><p>TCP是<strong>流式传输</strong>，没有边界，但是保证顺序和可靠。UDP是一个一个包发送是有边界的，但是可能丢包和乱序。</p><li><p><strong>分片</strong></p><p>TCP的大小如果大于MSS（最大报文长度）大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP包。如果中途丢失了一个分片，只需要传输这个丢失的分片。</p><p>UDP的数据如果大于MTU，则会在IP层进行分片，目标主机收到后，在IP层进行组装。</p></ol><p>TCP和UDP可以共用同一个端口。当主机收到数据包的时候，可以在IP包头的协议号字段知道该数据包是TCP还是UDP，并发送给不同的模块。因此TCP和UDP的端口相互独立。</p><h4 id="tcp特点"><span class="mr-2">TCP特点</span><a href="#tcp特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>(1) 超时重传</p><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code class="language-plaintext highlighter-rouge">ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><p>(2) 流量控制</p><p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><p>(3) 拥塞控制</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p><p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络</strong>。</p><h3 id="2-tcpip模型四层"><span class="mr-2">2. TCP/IP模型（四层）</span><a href="#2-tcpip模型四层" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li><strong>应用层</strong>：软件实现层面，HTTP、FTP、Telnet、DNS、SMTP等。<li><p><strong>传输层</strong>：TCP/UDP。TCP是传输控制协议，相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。UDP 相对来说就很简单，简单到只负责发送数据包，传输效率高。可以在应用层实现TCP的功能。</p><li><p><strong>网络层</strong>：IP/ICMP协议。数据部分+TCP/UDP头+IP头。</p><p>IP地址有两种意义：</p><ul><li>一个是<strong>网络号</strong>，负责标识该 IP 地址是属于哪个「子网」的；<li>一个是<strong>主机号</strong>，负责标识同一「子网」下的不同主机；</ul><p>IP地址和子网掩码做<strong>AND</strong>运算得到网络号。</p><p>IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。</p><li><strong>网络接口层</strong>：MAC头部，包含了接收方和发送方的 MAC 地址。网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。</ol><p>Ping是由ICMP协议控制的。</p><h4 id="在浏览器输入url之后具体流程是什么"><span class="mr-2">在浏览器输入URL之后，具体流程是什么？</span><a href="#在浏览器输入url之后具体流程是什么" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>具体的流程如下：</p><ul><li>URL解析：浏览器首先解析输入的URL，提取出协议、主机名、端口号、路径等信息。<li>DNS解析：浏览器将主机名转换为对应的IP地址，通过DNS解析来完成这一步骤。<li>建立TCP连接：浏览器与服务器之间建立TCP连接，通过三次握手建立可靠的连接。<li>发送HTTP请求：浏览器构建HTTP请求报文，包括请求方法（GET、POST等）、请求头部、请求体等信息，并将其发送给服务器。<li>服务器处理请求：服务器接收到请求后，根据请求的路径、参数等进行处理，并生成对应的HTTP响应。<li>接收HTTP响应：浏览器接收到服务器返回的HTTP响应报文，包括响应状态码、响应头部、响应体等信息。<li>渲染页面：浏览器根据接收到的响应数据，解析HTML、CSS、JavaScript等资源，并进行页面的渲染，展示给用户。<li>关闭TCP连接：页面渲染完成后，浏览器与服务器之间的TCP连接会被关闭，释放网络资源。</ul><h3 id="3-tcp三次握手"><span class="mr-2">3. TCP三次握手</span><a href="#3-tcp三次握手" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" class="lazyload" data-proofer-ignore></a></p><ul><li>一开始，客户端和服务端都处于 <code class="language-plaintext highlighter-rouge">CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code class="language-plaintext highlighter-rouge">LISTEN</code> 状态<li>客户端会随机初始化序号（<code class="language-plaintext highlighter-rouge">client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code class="language-plaintext highlighter-rouge">SYN</code> 标志位置为 <code class="language-plaintext highlighter-rouge">1</code>，表示 <code class="language-plaintext highlighter-rouge">SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code class="language-plaintext highlighter-rouge">SYN-SENT</code> 状态<li>服务端收到客户端的 <code class="language-plaintext highlighter-rouge">SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code class="language-plaintext highlighter-rouge">server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code class="language-plaintext highlighter-rouge">client_isn + 1</code>, 接着把 <code class="language-plaintext highlighter-rouge">SYN</code> 和 <code class="language-plaintext highlighter-rouge">ACK</code> 标志位置为 <code class="language-plaintext highlighter-rouge">1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code class="language-plaintext highlighter-rouge">SYN-RCVD</code> 状态<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code class="language-plaintext highlighter-rouge">ACK</code> 标志位置为 <code class="language-plaintext highlighter-rouge">1</code> ，其次「确认应答号」字段填入 <code class="language-plaintext highlighter-rouge">server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> 状态。<li>服务端收到客户端的应答报文后，也进入 <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> 状态</ul><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>。</p><p>TCP 的连接状态在 Linux下可以通过 <code class="language-plaintext highlighter-rouge">netstat -napt</code> 命令查看。</p><h4 id="为什么是三次握手"><span class="mr-2">为什么是三次握手？</span><a href="#为什么是三次握手" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>由之前的定义，TCP的连接包含<strong>Socket，序列号和窗口大小</strong>。保持三次连接可以防止重复连接，同步序列号以及减少资源浪费。</p><ol><li><p><strong>防止重复连接</strong></p><p>三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱</strong></p><p>当客户端先发送了<code class="language-plaintext highlighter-rouge">SYN=90</code>的报文，但是此时客户端突然下线，而发送的<code class="language-plaintext highlighter-rouge">SYN</code>报文也因为网络原因造成拥塞，服务端没有及时收到。而现在客户端重新上线后，又发送了<code class="language-plaintext highlighter-rouge">SYN=100</code>的报文。此时如果旧的<code class="language-plaintext highlighter-rouge">SYN=90</code>的报文先到达服务端，假如没有第三次握手，服务端就会直接和旧的报文建立连接。而在三次握手的情况下，服务端会返回<code class="language-plaintext highlighter-rouge">SYN=90+1</code>给客户端，客户端收到后发现于预期<code class="language-plaintext highlighter-rouge">SYN=100+1</code>不符，于是向服务器发送<code class="language-plaintext highlighter-rouge">RST</code>主动终止旧的连接。</p><p>所以TCP使用三次握手建立连接的<strong>最主要原因就是防止「历史连接」初始化了连接</strong>。</p><li><p><strong>同步序列号</strong></p><p>TCP通信协议的双方，都要维护一个序列号，增加传输的可靠性。其有以下作用：</p><ul><li>接收方可以去掉重复数据；<li>接收方可以按照序列号确认包的接受顺序；<li>可以标识发送出去的数据包中，哪些是已被对方接收的。</ul><p>服务端接收到客户端的序列号，回应<code class="language-plaintext highlighter-rouge">ACK</code>并发送自己的序列号，客户端收到后再回应服务端<code class="language-plaintext highlighter-rouge">ACK</code>，这样可以确认两者都接收到各自的序列号。</p><li><p><strong>减少资源浪费</strong></p><p>在第一点中，如果没有第三次握手，服务端建立了旧的连接，那么会发送大量无用数据包，占用网络资源。</p></ol><p>所以，不使用两次握手和四次握手的原因：</p><ul><li>两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；<li>四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</ul><h4 id="序列号的初始化"><span class="mr-2">序列号的初始化</span><a href="#序列号的初始化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>每次建立TCP连接时，都需要初始化不同的序列号，这样的原因是，<strong>为了防止历史报文被下一个相同的四元组的连接接收</strong>，以及<strong>防止TCP报文被伪造</strong>。</p><h4 id="连接丢失"><span class="mr-2">连接丢失</span><a href="#连接丢失" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>第一次握手丢失</strong>会触发超时重传；</p><p><strong>第二次握手丢失</strong>客户端会认为第一次握手没有成功，也会触发超时重传。</p><p>如果<strong>第三次握手丢失</strong>，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p><h3 id="4-tcp四次挥手"><span class="mr-2">4. TCP四次挥手</span><a href="#4-tcp四次挥手" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-9008837.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-9008837.png" alt="TCP四次挥手" class="lazyload" data-proofer-ignore></a></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code class="language-plaintext highlighter-rouge">FIN</code> 标志位被置为 <code class="language-plaintext highlighter-rouge">1</code> 的报文，也即 <code class="language-plaintext highlighter-rouge">FIN</code> 报文，之后客户端进入 <code class="language-plaintext highlighter-rouge">FIN_WAIT_1</code> 状态。<li>服务端收到该报文后，就向客户端发送 <code class="language-plaintext highlighter-rouge">ACK</code> 应答报文，接着服务端进入 <code class="language-plaintext highlighter-rouge">CLOSE_WAIT</code> 状态。<li>客户端收到服务端的 <code class="language-plaintext highlighter-rouge">ACK</code> 应答报文后，之后进入 <code class="language-plaintext highlighter-rouge">FIN_WAIT_2</code> 状态。<li>等待服务端处理完数据后，也向客户端发送 <code class="language-plaintext highlighter-rouge">FIN</code> 报文，之后服务端进入 <code class="language-plaintext highlighter-rouge">LAST_ACK</code> 状态。<li>客户端收到服务端的 <code class="language-plaintext highlighter-rouge">FIN</code> 报文后，回一个 <code class="language-plaintext highlighter-rouge">ACK</code> 应答报文，之后进入 <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> 状态<li>服务端收到了 <code class="language-plaintext highlighter-rouge">ACK</code> 应答报文后，就进入了 <code class="language-plaintext highlighter-rouge">CLOSE</code> 状态，至此服务端已经完成连接的关闭。<li>客户端在经过 <code class="language-plaintext highlighter-rouge">2MSL</code> 一段时间后，自动进入 <code class="language-plaintext highlighter-rouge">CLOSE</code> 状态，至此客户端也完成连接的关闭。</ul><h4 id="为什么挥手四次"><span class="mr-2">为什么挥手四次</span><a href="#为什么挥手四次" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>服务器在收到客户端的<code class="language-plaintext highlighter-rouge">FIN</code>报文时，通常还会有等待完成的数据的发送和处理，所以服务端的<code class="language-plaintext highlighter-rouge">ACK</code>和<code class="language-plaintext highlighter-rouge">FIN</code>一般是分开发送。但在某些特定情况下，四次挥手也可以变为三次挥手。</p><h4 id="挥手丢失"><span class="mr-2">挥手丢失</span><a href="#挥手丢失" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>第一次挥手丢失</strong>，客户端在调用close函数后发送<code class="language-plaintext highlighter-rouge">FIN</code>报文，迟迟没有等来<code class="language-plaintext highlighter-rouge">ACK</code>，那么会触发超时重传。重传次数由<code class="language-plaintext highlighter-rouge">tcp_orphan_retries</code>控制，如果超出，就不再发送，在等待一段时间后，会直接进入到close状态。</p><p><strong>第二次挥手丢失</strong>，由于<code class="language-plaintext highlighter-rouge">ACK</code>报文不会重传，则在一段时间后会触发客户端的超时重传。</p><p><strong>第三次挥手丢失</strong>，当服务端进程调用close后，服务端发送<code class="language-plaintext highlighter-rouge">FIN</code>报文，如果迟迟没有等来客户端的<code class="language-plaintext highlighter-rouge">ACK</code>，则会尝试重新发送，重传次数由<code class="language-plaintext highlighter-rouge">tcp_orphan_retries</code>控制，如果超出，就不再发送，在等待一段时间后，会直接断开连接。</p><p><strong>第四次挥手丢失</strong>，客户端发送的<code class="language-plaintext highlighter-rouge">ACK</code>报文服务端没有收到，那么服务端就会认为<code class="language-plaintext highlighter-rouge">FIN</code>报文丢失，触发重传机制。客户端在<code class="language-plaintext highlighter-rouge">TIME_WAIT</code>状态时，如果重新收到<code class="language-plaintext highlighter-rouge">FIN</code>报文，就会重置2MSL定时器，直到断开连接。</p><h4 id="time_wait"><span class="mr-2">TIME_WAIT</span><a href="#time_wait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><strong>为什么等待时间是2MSL</strong></p><p>MSL指最大报文生成时间，他是报文在网络上存在的最长时间，超出报文会被丢弃。TCP是基于IP协议的，而IP头中有一个<code class="language-plaintext highlighter-rouge">TTL</code>字段，是IP数据包可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p><p>MSL的时间长度大于TTL消耗为0的时间，以确保报文自动消亡。一般来说，网络中可能有发送方的数据包，这些数据包被接收后处理后，又会向对方发送响应，一个来回正好是2MSL。</p><p><strong>为什么需要</strong></p><p>只有主动发起关闭连接的一方才有TIME_WAIT，主要原因如下：</p><ul><li><p>防止历史连接中的数据，被后面相同的四元组接收</p><p>为防止TCP连接中的数据被错误接收，TCP中设计了TIME_WAIT状态，并且为2MSL，这样可以保证本次连接中的数据都自然消失，再出现的数据包都是下一次连接的。</p><li><p>保证被动关闭连接的一方能正确关闭</p><p><strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong>比如服务端没收到<code class="language-plaintext highlighter-rouge">ACK</code>报文，出发了超时重传，那么客户端就会在关闭前有时间重新收到服务端发来的<code class="language-plaintext highlighter-rouge">FIN</code>重传报文，从而重置等待时间，帮助服务端正确关闭。</p></ul><p><strong>过多如何解决</strong></p><p>解决TIME_WAIT状态过多的首要方法就是<strong>避免服务器频繁主动断开连接，让客户端去断开，由分布在各处的客户端去承受 TIME_WAIT</strong>。</p><p>解决 time_wait 状态大量存在，导致新连接创建失败的问题，一般解决办法：</p><p>1.客户端：HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间：现在的浏览器，一般都这么进行了</p><p>2.服务器端：</p><p>允许 time_wait 状态的 socket 被重用</p><p>缩减 time_wait 时间，设置为<strong>1 MSL（即，2 mins）</strong></p><p>但是<strong>等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包</strong>。</p><h3 id="5-socket编程"><span class="mr-2">5. Socket编程</span><a href="#5-socket编程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>针对TCP该如何进行Socket编程</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/format,png-20230309230545997-0725405.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/format,png-20230309230545997-0725405.png" alt="基于 TCP 协议的客户端和服务端工作" class="lazyload" data-proofer-ignore></a></p><ol><li>服务端和客户端初始化<code class="language-plaintext highlighter-rouge">socket</code>，得到文件描述符；<li>服务端调用<code class="language-plaintext highlighter-rouge">bind</code>，将<code class="language-plaintext highlighter-rouge">socket</code>绑定在指定的IP和端口；<li>服务端调用<code class="language-plaintext highlighter-rouge">listen</code>，进行监听；<li>服务端调用<code class="language-plaintext highlighter-rouge">accept</code>，等待客户端连接；<li>客户端调用<code class="language-plaintext highlighter-rouge">connect</code>，向服务端的地址和接口发起连接请求；<li>服务端<code class="language-plaintext highlighter-rouge">accept</code>，返回用于传输<code class="language-plaintext highlighter-rouge">socket</code>的文件描述符；<li>客户端调用<code class="language-plaintext highlighter-rouge">write</code>写入数据，服务端调用<code class="language-plaintext highlighter-rouge">read</code>读取数据；<li>客户端断开连接时，会调用<code class="language-plaintext highlighter-rouge">close</code>，那么服务端 <code class="language-plaintext highlighter-rouge">read</code> 读取数据的时候，就会读取到了 <code class="language-plaintext highlighter-rouge">EOF</code>，待处理完数据后，服务端调用 <code class="language-plaintext highlighter-rouge">close</code>，表示连接关闭。</ol><p>监听的 socket 和真正用来传送数据的 socket，是两个 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><h3 id="6-tcp重传"><span class="mr-2">6. TCP重传</span><a href="#6-tcp重传" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="重传机制"><span class="mr-2">重传机制</span><a href="#重传机制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>TCP实现可靠传输的方式之一，是通过序列号与确认应答。在TCP中，当发送端的数据到达接收主机时，接收端会返回一个确认应答消息，表示已收到消息。</p><p>但是数据传输过程中会有丢失，所以TCP针对丢包情况，会有重传机制。</p><ol><li><p><strong>超时重传</strong></p><p>在发送数据时设定一个定时器，当超过指定时间后，没有收到对方的<code class="language-plaintext highlighter-rouge">ACK</code>确认应答报文，就会重发该数据。一般发生在：<strong>数据包丢失，确认应答丢失</strong>。</p><p>超时重传的时间是以<code class="language-plaintext highlighter-rouge">RT0</code>表示（Retransmission Timeout 超时重传时间），而<code class="language-plaintext highlighter-rouge">RTT</code>（Round-Trip Time 往返时延）是<strong>数据从发送时刻到接收到确认的时刻的差值</strong>。<code class="language-plaintext highlighter-rouge">RTO</code>不能过大也不能过小，<strong>超时重传时间RTO的值应该略大于报文往返RTT的值</strong>。</p><p>报文往返RTT是经常变化的，因为网络经常变化，所以超时重传RTO的值应该是一个<strong>动态变化的值</strong>。在TCP的策略下，如果超时重发的数据，再次要超时重传，会将超时时间加倍。<strong>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</strong>。</p><li><p><strong>快速重传</strong></p><p>以数据为驱动重传。当收到<strong>三个相同的ACK报文时</strong>，就会在定时器过期之前，重传丢失的报文。但是无法判断该重传哪些TCP报文。</p><p>例如发送方发送了Seq=1，2，3，4，5，6六条数据，而Seq2由于某些原因没有收到，所以在接收方收到后面的Seq3，4，5时，还是会回传ACK=2，而发送方收到三次相同的ACK=2后，<strong>知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong>但是如果Seq2，3都丢失，接收方还是只会传ACK=2，发送方无法判断是重传Seq2还是Seq2及之后的报文。</p><li><p><strong>SACK方法</strong></p><p>即选择性确认，其在TCP头部选项字段里加一个<code class="language-plaintext highlighter-rouge">SACK</code>，他可以<strong>将已经收到的数据信息发送给发送方</strong>，这样发送方就知道哪些数据丢失，就可以只重传丢失的数据。</p><li><p><strong>Duplicated SACK</strong></p><p>又称<code class="language-plaintext highlighter-rouge">D-SACK</code>，其主要使用了SACK来告诉发送方有哪些数据被重复接受了。一般用于ACK报文丢失的情况。</p><ul><li><p>ACK丢失</p><p>发送方超时重传后，接收方发给发送方的两个ACK都丢失了，接收方收到数据包1，2，在下次在收到发送方重传的数据包1后，发现数据重复，所以返回一个ACK和SACK=数据包1，如果发送方收到应答，则知道数据没有丢失，而是ACK丢失。</p><li><p>网络延时</p><p>发送方的数据包1000-1499被网络延迟，导致没收到ACK=1500的应答，后面发送方收到三个ACK=1500的确认报文，于是触发了快速重传机制，但是在重传后，接收方又收到了1000-1499的数据包。<strong>所以接收方回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包</strong>。</p></ul></ol><h3 id="7-滑动窗口"><span class="mr-2">7. 滑动窗口</span><a href="#7-滑动窗口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP每发送一个数据都要进行一次确认应答。但是当<strong>往返时间越长，通信的效率越低</strong>。为了解决这个问题，TCP引入了窗口的概念，窗口的大小就是<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答前，必须在缓冲区中保留已发送过的数据，如果收到确认应答，此时数据就可以从缓存区清除。</p><p>窗口的大小由TCP头中的<code class="language-plaintext highlighter-rouge">Window</code>字段决定。<strong>这个字段是接收方告诉发送端自己还有多少缓冲区可以接受数据</strong>。</p><ol><li><p><strong>发送方的滑动窗口</strong></p><p>发送方的缓存窗口如下：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/16-0212323.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/16-0212323.jpg" alt="img" class="lazyload" data-proofer-ignore></a></p><p>当发送方一次性发送所有数据后，滑动窗口的大小会变成0，表示可用窗口耗尽。在下一个ACK回应到来前，无法再发送数据。</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/17-0820933.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/17-0820933.jpg" alt="可用窗口耗尽" class="lazyload" data-proofer-ignore></a></p><p>当接收方确认5个字节的数据后，滑动窗口会往右移动5个字节。</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/18-0212375.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/18-0212375.jpg" alt="32 ~ 36 字节已确认" class="lazyload" data-proofer-ignore></a></p><li><p><strong>接收方的窗口</strong></p><p>接收方窗口大小约等于发送方窗口大小，但不一定完全相等。</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/20-0212424.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/20-0212424.jpg" alt="接收窗口" class="lazyload" data-proofer-ignore></a></p></ol><h3 id="8-流量控制"><span class="mr-2">8. 流量控制</span><a href="#8-流量控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果发送方发送数据不考虑接收方的能力，那么就会一直触发重传机制。为了解决这种现象的发生，<strong>TCP提供一种机制可以让发送方根据接收方发实际接受能力控制发送的数据量，这就是流量控制。</strong></p><h4 id="操作系统与滑动窗口的关系"><span class="mr-2">操作系统与滑动窗口的关系</span><a href="#操作系统与滑动窗口的关系" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在滑动窗口中，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区，而内存缓冲区会被操作系统调整。</p><p>当接收端的进程长时间没有读取缓冲区里的内容时，数据会占用缓冲区，而随着发送方持续发送数据，接收窗口会收缩到0，发生了窗口关闭。</p><p>当服务端操作系统资源很紧张时，可能会改变其接收窗口的大小。当客户端发送一段数据包后，服务端的接收窗口发生了收缩，没有及时告知客户端，导致服务端收到的字节数大于其现在的窗口大小，则会发生数据的丢失。所以，如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。</p><p><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></p><h4 id="窗口关闭"><span class="mr-2">窗口关闭</span><a href="#窗口关闭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>如果窗口大小为0时，就会阻止发送方给接收方传递数据，直到窗口变为非0，这就是窗口关闭。</p><p>接收方向发送方通告窗口大小，是通过ACK报文通告。但是如果此时非0的ACK报文丢失，则会造成死锁现象。</p><p>所以TCP每个连接都设有一个持续定时器，<strong>只要TCP连接一方收到对方的零窗口通知，就会启动持续计时器。</strong>如果持续计时器超时，就会发送<strong>窗口探测报文</strong>，而对方在收到这个报文时，会返回自己现在窗口的大小。如果窗口仍为0，则重置定时器。</p><h4 id="糊涂窗口综合症"><span class="mr-2">糊涂窗口综合症</span><a href="#糊涂窗口综合症" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当接收方较忙时，如果<strong>接收方腾出几个字节并告诉发送方现在有几个字节的窗口，那么发送方会义无反顾的发送这几个字节，称为糊涂窗口综合症</strong>。</p><p>其一般出现在<strong>发送方可以发送一个小窗口</strong>和<strong>接收方可以通告一个小窗口</strong>的情况下，解决方式如下：</p><ul><li>对于接收方，当窗口大小小于<strong><em>min(MSS, 缓存空间/2)</em></strong>时，则会向发送方通告窗口为0，阻止了发送方发送数据。<li>对于发送方，可以使用Nagle算法，延时处理，满足下面任意一个条件才可以发送数据：<ul><li>要等到窗口大小 &gt;= <code class="language-plaintext highlighter-rouge">MSS</code> 并且 数据大小 &gt;= <code class="language-plaintext highlighter-rouge">MSS</code>；<li>收到之前发送数据的 <code class="language-plaintext highlighter-rouge">ack</code> 回包；</ul></ul><p>发送方和接收方同时满足上面的要求后，才能避免糊涂窗口综合症。</p><h3 id="9-拥塞控制"><span class="mr-2">9. 拥塞控制</span><a href="#9-拥塞控制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>流量控制可以控制发送接收方，但无法知道网络中发生什么。<strong>在网络出现拥堵时，如果继续发送大量数据包，可能导致数据包延时，丢失等，这时TCP就会重传数据，但是重传会导致网络负担更重</strong>，所以为了避免上述情况，当网络发生拥塞时，TCP会降低数据发送量。<strong>拥塞控制的目的是避免发送方的数据填满整个网络。</strong></p><p>为了让发送方调节所要发送数据的量，定义了拥塞窗口，<strong>拥塞窗口</strong> (<strong>cwnd</strong>)是发送方维护的一个状态变量，他会根据<strong>网络的拥塞程度动态变化</strong>。</p><p>发送端和接受端在有发送窗口和接收窗口下，加入拥塞窗口，此时发送窗口的值为<code class="language-plaintext highlighter-rouge">swnd=min(cwnd,rwnd)</code>。</p><p>在Linux中，可以用<code class="language-plaintext highlighter-rouge">ss -nli|grep cwnd</code>来查看每一个TCP连接的窗口初始值。</p><p>拥塞控制有以下四个算法：</p><ol><li><p><strong>慢启动</strong></p><p>TCP刚建立连接后，首先有慢启动的过程，即一点一点提高发送数据包的数量，<strong>当发送方每收到一个 <code class="language-plaintext highlighter-rouge">ACK</code>，拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd</code> 的大小就会加 1。</strong></p><p>慢启动达到一定数量后，就会使用拥塞避免算法。</p><li><p><strong>拥塞避免</strong></p><p>当前窗口超过慢启动门限<code class="language-plaintext highlighter-rouge">ssthresh</code>后会进入拥塞避免算法。一般来说<code class="language-plaintext highlighter-rouge">sstheesh</code>的大小是65535字节。在进入拥塞避免算法后，<strong>每当收到一个 <code class="language-plaintext highlighter-rouge">ACK</code> 时，<code class="language-plaintext highlighter-rouge">cwnd</code> 增加 1/cwnd</strong>。</p><p>当网络发生拥塞，就会有丢包现象，如果触发超时重传机制，就会进入拥塞发生算法。</p><li><p><strong>拥塞发生</strong></p><p>拥塞发生有两种重传情况，超时重传和快速重传，这两种重传使用的拥塞发生算法不同。</p><p><strong>当发生超时重传</strong>，就会使用拥塞发生算法，这时<code class="language-plaintext highlighter-rouge">ssthresh</code>r和<code class="language-plaintext highlighter-rouge">cwnd</code>的值会发生变化。</p><ul><li><code class="language-plaintext highlighter-rouge">ssthresh</code> 设为 <code class="language-plaintext highlighter-rouge">cwnd/2</code>，<li><code class="language-plaintext highlighter-rouge">cwnd</code> 重置为初始值。</ul><p>但这种方法比较激进，容易发生网络卡顿。</p><p><strong>当发生快速重传</strong>，此时TCP认为丢包不是很严重，只丢了一小部分，这时<code class="language-plaintext highlighter-rouge">ssthresh</code>r和<code class="language-plaintext highlighter-rouge">cwnd</code>的值变化如下：</p><ul><li><code class="language-plaintext highlighter-rouge">cwnd</code> 设为<code class="language-plaintext highlighter-rouge">cwnd/2</code>，<li><code class="language-plaintext highlighter-rouge">ssthresh</code> 设为 <code class="language-plaintext highlighter-rouge">cwnd</code>，<li>进入快速恢复算法。</ul><li><p><strong>快速恢复</strong></p><p>快速重传一般和快速恢复算法同时使用，在进入快速恢复前，<code class="language-plaintext highlighter-rouge">cwnd</code>和<code class="language-plaintext highlighter-rouge">ssthresh</code>已经被更新：</p><ul><li>拥塞窗口 <code class="language-plaintext highlighter-rouge">cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；<li>重传丢失的数据包；<li>如果再收到重复的 ACK，那么 <code class="language-plaintext highlighter-rouge">cwnd</code> 增加 1；<li>如果收到新数据的 ACK 后，把 <code class="language-plaintext highlighter-rouge">cwnd</code> 设置为第一步中的 <code class="language-plaintext highlighter-rouge">ssthresh</code> 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</ul></ol><h3 id="10-tcp半连接队列和全连接队列"><span class="mr-2">10. TCP半连接队列和全连接队列</span><a href="#10-tcp半连接队列和全连接队列" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在TCP三次握手的过程中，Linux内核会维护两个队列，分别是：</p><ul><li>半连接队列，也称SYN队列；<li>全连接队列，也称accept队列。</ul><p>服务端在收到客户端发起的SYN请求时，<strong>内核会把该连接储存到半连接队列</strong>，并向客户端响应SYN+ACK，接着客户端会返回ACK，服务端在收到第三次握手的ACK后，<strong>内核会把连接从半连接队列移除，然后创建新的完全连接，并将其添加到accept队列，等待进程调用accept函数时把连接取出来</strong>。</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/3-0906917.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/3-0906917.jpg" alt="半连接队列与全连接队列" class="lazyload" data-proofer-ignore></a></p><p>不管是半连接还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回RST包。</p><h3 id="11-tcp流式传输"><span class="mr-2">11. TCP流式传输</span><a href="#11-tcp流式传输" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>TCP是面向字节流的协议，而UDP是面向报文的协议，是因为操作系统对他们的发送机制不同。</p><h4 id="面向报文"><span class="mr-2">面向报文</span><a href="#面向报文" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当用户通过UDP发送消息时，操作系统不会对消息进行拆分，在组装好UDP头部后就交给网络层处理，所以<strong>每一个UDP报文就是一个用户消息的边界，</strong>这样接收方在收到消息后，读一个UDP报文就能读取到完整的用户信息。</p><p>操作系统在收到UDP报文后，会将其插入到队列里，队列里每一个元素就是一个UDP报文。</p><h4 id="字节流"><span class="mr-2">字节流</span><a href="#字节流" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>当用户通过TCP发送消息时，<strong>消息可能会被操作系统拆分成多个TCP报文</strong>，这时，如果接收方不知道发送消息的长度，也不知道消息边界，则无法读出用户信息。<strong>不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议</strong>。</p><h4 id="如何解决粘包"><span class="mr-2">如何解决粘包</span><a href="#如何解决粘包" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>粘包问题的出现是接受端不知道用户消息的边界，从而无法有效划分出用户消息。</p><p>一般有三种分包方式：</p><ul><li><p>固定长度的消息</p><p>即每个用户消息都是固定长度的，比如64字节，当接收方收满64字节时，就认为其为完整有效的信息。不过此方法灵活性不高，一般很少使用。</p><li><p>特殊字符作为边界</p><p>可以在两个用户消息之间插一个特殊字符串，这样接收方在接受数据时，读到这个特殊字符，就认为已经读完一个完整的消息。比如HTTP协议就用回车，换行符作为HTTP消息的边界。</p><li><p>自定义消息结构</p><p>可以自定义一种数据结构，比如包头固定大小，包头里有一个字段来表明后面的数据体的大小。</p></ul><h2 id="ip"><span class="mr-2">IP</span><a href="#ip" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-基础知识"><span class="mr-2">1. 基础知识</span><a href="#1-基础知识" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IP处于网络层，而网络层的作用就是<strong>实现主机与主机之间的通信，也叫点对点通信</strong>。IPv4地址由32位正整数来表示。</p><h4 id="ip地址分类"><span class="mr-2">IP地址分类</span><a href="#ip地址分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>IP地址分为5种类型，分别是A，B，C，D，E：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/7-1165342-1165343.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/7-1165342-1165343.jpg" alt="IP 地址分类" class="lazyload" data-proofer-ignore></a></p><p>对于A，B，C类地址，分为网络号和主机号。在IP地址中有两个特殊地址，分别是主机号全为0和主机号全为1的地址。</p><ul><li>主机号全为 1 指定某个网络下的所有主机，用于广播<li>主机号全为 0 指定某个网络</ul><p>广播地址用于<strong>在同一个链路中相互连接的主机之间发送数据包</strong>。</p><p>对于D，E类地址，是没有主机号的，所以不可用于主机IP，D类为<strong>多播地址</strong>，E类留用。</p><h3 id="2-ping工作原理"><span class="mr-2">2. Ping工作原理</span><a href="#2-ping工作原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="icmp协议"><span class="mr-2">ICMP协议</span><a href="#icmp协议" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Ping是基于ICMP协议工作的，ICMP全程<strong>互联网控制报文协议</strong>，其主要功能包括<strong>确认IP包是否成功送达目标地址，报告发送过程中IP包被废弃的原因和改善网络设置等</strong>。</p><p>如果IP通信中某个IP包因为某种原因未能到达目标地址，那么<strong>具体原因将由ICMP协议通知</strong>。</p><h2 id="http"><span class="mr-2">HTTP</span><a href="#http" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="1-http解析网页请求过程"><span class="mr-2">1. HTTP解析（网页请求过程）</span><a href="#1-http解析网页请求过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="解析url"><span class="mr-2">解析URL</span><a href="#解析url" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>数据协议+web服务器+目录名/文件名</p><p>HTTP的请求报文和响应报文：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F.jpg" alt="HTTP消息格式" class="lazyload" data-proofer-ignore></a></p><h4 id="dns解析"><span class="mr-2">DNS解析</span><a href="#dns解析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>通过解析URL生成HTTP消息后，需要<strong>查询服务器域名对应的IP地址</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。其解析流程如下：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/DNS%E8%A7%A3%E6%9E%90.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/DNS%E8%A7%A3%E6%9E%90.jpg" alt="DNS解析" class="lazyload" data-proofer-ignore></a></p><h4 id="协议栈"><span class="mr-2">协议栈</span><a href="#协议栈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分别是负责收发数据的 TCP 和 UDP 协议，下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/7.jpg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/7.jpg" alt="协议栈" class="lazyload" data-proofer-ignore></a></p><p><strong>TCP</strong></p><p>TCP会给数据包加上TCP头部，而TCP数据部分存放着HTTP头部和数据。</p><p><strong>IP</strong></p><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。IP会加IP头部。</p><p>IP 中的 <code class="language-plaintext highlighter-rouge">ICMP</code> 协议和 <code class="language-plaintext highlighter-rouge">ARP</code> 协议。</p><ul><li><code class="language-plaintext highlighter-rouge">ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。<li><code class="language-plaintext highlighter-rouge">ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><p><strong>MAC</strong></p><p>用于两点传输。MAC包头的协议类型只是用IP协议和ARP协议。</p><p>发送方的MAC地址是写在网卡ROM里的。对于接收方，只需要告诉以太网对方的MAC地址，以太网就会把包发过去。</p><p>发送方可以查<strong>路由表</strong>来找到目标，然后把包发给Gateway中的IP地址。如果不知道对方MAC地址，就用ARP协议广播。</p><p><strong>网卡</strong></p><p>数字信号——&gt;电信号</p><h4 id="交换机"><span class="mr-2">交换机</span><a href="#交换机" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>交换机有mac地址表映射网线端口。找不到对应的mac就广播发送。</p><p>广播地址：</p><ul><li>MAC 地址中的 <code class="language-plaintext highlighter-rouge">FF:FF:FF:FF:FF:FF</code><li>IP 地址中的 <code class="language-plaintext highlighter-rouge">255.255.255.255</code></ul><h4 id="路由器"><span class="mr-2">路由器</span><a href="#路由器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>路由器的接收与自己端口MAC地址匹配的包。然后根据路由表和包的IP来判断转发目标。得到目标IP后，再用ARP协议得到其MAC地址转发。</p><p>和交换机区别：</p><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；<li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</ul><h3 id="2-http状态码"><span class="mr-2">2. HTTP状态码</span><a href="#2-http状态码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="table-wrapper"><table><thead><tr><th>100<th>Continue<th>继续。客户端应继续其请求<tbody><tr><td>101<td>Switching Protocols<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议<tr><td> <td> <td> <tr><td>200<td>OK<td>请求成功。一般用于GET与POST请求<tr><td>201<td>Created<td>已创建。成功请求并创建了新的资源<tr><td>202<td>Accepted<td>已接受。已经接受请求，但未处理完成<tr><td>203<td>Non-Authoritative Information<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本<tr><td>204<td>No Content<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档<tr><td>205<td>Reset Content<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域<tr><td>206<td>Partial Content<td>部分内容。服务器成功处理了部分GET请求<tr><td> <td> <td> <tr><td>300<td>Multiple Choices<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择<tr><td>301<td>Moved Permanently<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替<tr><td>302<td>Found<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI<tr><td>303<td>See Other<td>查看其它地址。与301类似。使用GET和POST请求查看<tr><td>304<td>Not Modified<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源<tr><td>305<td>Use Proxy<td>使用代理。所请求的资源必须通过代理访问<tr><td>306<td>Unused<td>已经被废弃的HTTP状态码<tr><td>307<td>Temporary Redirect<td>临时重定向。与302类似。使用GET请求重定向<tr><td> <td> <td> <tr><td>400<td>Bad Request<td>客户端请求的语法错误，服务器无法理解<tr><td>401<td>Unauthorized<td>请求要求用户的身份认证<tr><td>402<td>Payment Required<td>保留，将来使用<tr><td>403<td>Forbidden<td>服务器理解请求客户端的请求，但是拒绝执行此请求<tr><td>404<td>Not Found<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面<tr><td>405<td>Method Not Allowed<td>客户端请求中的方法被禁止<tr><td>406<td>Not Acceptable<td>服务器无法根据客户端请求的内容特性完成请求<tr><td>407<td>Proxy Authentication Required<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权<tr><td>408<td>Request Time-out<td>服务器等待客户端发送的请求时间过长，超时<tr><td>409<td>Conflict<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突<tr><td>410<td>Gone<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置<tr><td>411<td>Length Required<td>服务器无法处理客户端发送的不带Content-Length的请求信息<tr><td>412<td>Precondition Failed<td>客户端请求信息的先决条件错误<tr><td>413<td>Request Entity Too Large<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息<tr><td>414<td>Request-URI Too Large<td>请求的URI过长（URI通常为网址），服务器无法处理<tr><td>415<td>Unsupported Media Type<td>服务器无法处理请求附带的媒体格式<tr><td>416<td>Requested range not satisfiable<td>客户端请求的范围无效<tr><td>417<td>Expectation Failed<td>服务器无法满足Expect的请求头信息<tr><td> <td> <td> <tr><td>500<td>Internal Server Error<td>服务器内部错误，无法完成请求<tr><td>501<td>Not Implemented<td>服务器不支持请求的功能，无法完成请求<tr><td>502<td>Bad Gateway<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应<tr><td>503<td>Service Unavailable<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中<tr><td>504<td>Gateway Time-out<td>充当网关或代理的服务器，未及时从远端服务器获取请求<tr><td>505<td>HTTP Version not supported<td>服务器不支持请求的HTTP协议的版本，无法完成处理</table></div><h3 id="3-http字段"><span class="mr-2">3. HTTP字段</span><a href="#3-http字段" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>Host字段</strong>：</p><p>客户端发送请求时，用来指定服务器的域名；</p><p><strong>Content-Length字段</strong>：</p><p>服务器在返回数据时会有此字段，用来表示本次回应的数据长度；</p><p>HTTP是基于TCP传输协议进行通信的，TCP协议会存在粘包的问题，<strong>HTTP协议通过设置回车符，换行符作为HTTP header的边界，通过Content-Length作为HTTP body的边界来解决粘包的问题</strong>。</p><p><strong>Connection字段</strong>：</p><p>该字段最常用于客户端要求服务端使用HTTP长连接机制，以便请求其他复用。<strong>HTTP长连接的特点是，只要一方没有明确提出断开连接，则保持TCP连接状态</strong>。</p><p>HTTP/1.1版本默认都是长连接，但为了兼容老版本HTTP，需要指定<code class="language-plaintext highlighter-rouge">Connection</code>首部字段的值为<code class="language-plaintext highlighter-rouge">Keep-Alive</code>.</p><p><strong>Content-Type字段</strong></p><p>该字段用于回应服务器时，告诉客户端，本次数据是什么格式。</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Content-Type: text/html; Charset=utf-8
</pre></table></code></div></div><p>上面的类型表明，发送的是网页，而且编码是UTF-8。客户端请求的时候，可以用<code class="language-plaintext highlighter-rouge">Accept</code>字段声明自己接受哪些数据格式。</p><p><strong>Content-Encoding字段</strong></p><p>该字段说明数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。客户端在请求时，用 <code class="language-plaintext highlighter-rouge">Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p><h3 id="4-get与post区别"><span class="mr-2">4. GET与POST区别</span><a href="#4-get与post区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>GET的语义是从服务器获取指定资源；POST的语义是根据请求负荷（报文Body）对指定资源作出处理。</strong></p><p>GET的请求参数位置一般是写在URL中的，URL规定只能支持ASCII，所以GET请求只允许ASCII字符，而且浏览器会对URL的长度有限制（HTTP协议对URL的长度是没有限制的）。</p><p>POST请求携带数据的位置一般是写在抱文body中，body中可以是任意格式的数据，而且浏览器一般不限制大小。</p><p>对于安全和幂等，在HTTP协议中，所谓安全是指请求方法不会破坏服务器上的资源；而所谓幂等是指多次执行相同操作，结果都是相同的。</p><p>所以在安全和幂等方面：</p><ul><li><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。<li><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</ul><p>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。</p><h3 id="5-http缓存"><span class="mr-2">5. HTTP缓存</span><a href="#5-http缓存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="实现方式"><span class="mr-2">实现方式</span><a href="#实现方式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>对于一些重复性请求，我们可以把这对请求-响应的数据都缓存在本地，那么下次就直接读取本地的数据，所以避免发送HTTP请求的方法是通过缓存技术。</p><p>HTTP的缓存实现方式分为<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><ol><li><p><strong>强制缓存</strong></p><p>强制缓存是指只要浏览器判断缓存没有过期，则直接使用浏览器本地缓存，决定权在浏览器这边。其是利用下面两个HTTP响应头部字段来实现的，他们表示资源在客户段缓存的有效期：</p><ul><li><code class="language-plaintext highlighter-rouge">Cache-Control</code>， 是一个相对时间；<li><code class="language-plaintext highlighter-rouge">Expires</code>，是一个绝对时间；</ul><p>如果 HTTP 响应头部同时有 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 和 <code class="language-plaintext highlighter-rouge">Expires</code> 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong> 。</p><p><code class="language-plaintext highlighter-rouge">Cache-control</code> 选项更多一些，设置更加精细，所以建议使用 <code class="language-plaintext highlighter-rouge">Cache-Control</code> 来实现强缓存。具体的实现流程如下：</p><ul><li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 <code class="language-plaintext highlighter-rouge">Cache-Control</code>，<code class="language-plaintext highlighter-rouge">Cache-Control</code> 中设置了过期时间大小；<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</ul><li><p><strong>协商缓存</strong></p><p>当请求返回304的时候，一般是服务端告诉浏览器可以使用本地缓存资源，这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E7%BC%93%E5%AD%98etag.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E7%BC%93%E5%AD%98etag.png" alt="协商缓存" class="lazyload" data-proofer-ignore></a></p><p>上图为协商缓存的一个过程，所以协商缓存就是与服务端协商后，通过协商结果来判断是否使用本地缓存。</p><p>协商缓存可以基于两种头部实现：</p><p>(1) 请求头部中的 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 字段与响应头部中的 <code class="language-plaintext highlighter-rouge">Last-Modified</code> 字段实现，这两个字段的意思是：</p><ul><li>服务器发回的HTTP响应头部中的 <code class="language-plaintext highlighter-rouge">Last-Modified</code>：标示这个响应资源的最后修改时间；<li>客户端请求头部中的 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code>：当资源过期了，发现响应头中具有 <code class="language-plaintext highlighter-rouge">Last-Modified</code> 声明，则客户端再次发起请求的时候带上 <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> 字段，值为其第一次请求时返回的 <code class="language-plaintext highlighter-rouge">Last-Modified</code> ，服务器收到请求后与被请求资源的最后修改时间进行对比，如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。</ul><p>(2) 请求头部中的 <code class="language-plaintext highlighter-rouge">If-None-Match</code> 字段与响应头部中的 <code class="language-plaintext highlighter-rouge">ETag</code> 字段，这两个字段的意思是：</p><ul><li>响应头部中 <code class="language-plaintext highlighter-rouge">Etag</code>：唯一标识响应资源；<li>请求头部中的 <code class="language-plaintext highlighter-rouge">If-None-Match</code>：当资源过期时，浏览器发现响应头里有 <code class="language-plaintext highlighter-rouge">Etag</code>，则再次向服务器发起请求时，会将请求头 <code class="language-plaintext highlighter-rouge">If-None-Match</code> 值设置为 <code class="language-plaintext highlighter-rouge">Etag</code> 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。</ul><p>第一种是根据时间实现的，第二种方法是根据唯一标识实现的，相对来说后者可以更加准确判断文件内容是否被修改，避免由于篡改时间导致的不可靠问题。</p><p>如果第一次请求的时候服务器返回的HTTP头部同时有<code class="language-plaintext highlighter-rouge">Last-Modified</code>和<code class="language-plaintext highlighter-rouge">ETag</code>字段时，那么客户端下一次请求的时候，如果带上这两个值，则<code class="language-plaintext highlighter-rouge">ETag</code>的优先级更高，即服务端先会判断<code class="language-plaintext highlighter-rouge">ETag</code>是否变化，如果没变化再判断<code class="language-plaintext highlighter-rouge">Last-Modified</code>。<code class="language-plaintext highlighter-rouge">ETag</code>优先级更高的原因有下：</p><ol><li><p>在没有修改文件的情况下最后修改时间也有可能会变，导致重复请求；</p><li><p>有些文件是在秒级以内修改的，<code class="language-plaintext highlighter-rouge">If-Modified</code>字段只能以秒为颗粒度检测，使用<code class="language-plaintext highlighter-rouge">ETag</code>就能保证一秒内刷新多次。</p><li><p>有些服务器不能精确获取文件修改时间。</p></ol><p><strong>协商缓存的这两个字段都需要配合强制缓存中的Cache-control字段来使用，只有在未能命中强制缓存的时候，才能发起协商缓存字段的请求</strong>。</p><p>下面是强制缓存和协商缓存的工作流程：</p></ol><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/http%E7%BC%93%E5%AD%98.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/http%E7%BC%93%E5%AD%98.png" alt="工作流程" class="lazyload" data-proofer-ignore></a></p><h3 id="6-http版本"><span class="mr-2">6. HTTP版本</span><a href="#6-http版本" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>到目前为止，HTTP 常见到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。</p><h4 id="http11"><span class="mr-2">HTTP/1.1</span><a href="#http11" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>HTTP1.1最突出的特点是简单，灵活和易于扩展以及应用广泛和跨平台。</p><p><strong>简单</strong>：HTTP报文的格式是head+body，头部信息也是key-value的简单形式，易于理解。</p><p><strong>灵活和易于扩展</strong>：HTTP请求里的各类方法，URI/URL，状态码等都允许开发者自定义和补充；同时由于HTTP工作在应用层，则它的下层可以随意变化，比如HTTPS就是在HTTP和TCP层之间加了SSL/TLS安全协议。</p><p><strong>应用广泛和跨平台</strong>：大家都用。</p><p>但是HTTP也有缺点，无状态，明文传输，不安全。</p><p><strong>无状态</strong>：好处是服务器不用记忆HTTP的状态，可以减轻服务器负担；坏处就是服务器没有记忆能力，在完成有关联性的操作会非常麻烦。对于无状态问题，解决方法之一就是<strong>Cookie</strong>。</p><p><strong>明文传输</strong>：用HTTPS解决。</p><p>HTTP1.1是基于TCP/IP，并且使用了<strong>请求-应答</strong>通信模式。其性能从以下三个方面来看：</p><ol><li><p><strong>长连接</strong></p><p>早期HTTP1.0有一个问题是，每发起一次请求都要建立一次TCP连接，并且是串行请求，增加了网络开销。在HTTP1.1时期，提出了长连接的通信方式，这种连接方式的特点是<strong>只要一方没有明确提出断开连接，则保持TCP连接状态</strong>。如果一方长时间没有数据交互，则HTTP会自动断开连接。</p><li><p><strong>管道网络传输</strong></p><p>HTTP1.1采用了长连接的方式，这使得管道传输成为可能。管道网络传输指在同一个TCP连接中，客户端可以发起多个请求，只要第一个请求发出，不必等其回来，就可以发第二个请求，<strong>减少响应时间</strong>。但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。如果服务器在处理前面的请求耗时较长，那么后面的请求处理会被阻塞住，这称为<strong>队头阻塞</strong>。所以，<strong>HTTP1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>。</p><li><p><strong>队头阻塞</strong></p><p>请求-应答的模式会造成HTTP的性能问题，产生队头阻塞，所以HTTP1.1性能一般。</p></ol><h4 id="http2"><span class="mr-2">HTTP/2</span><a href="#http2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p><p>其相比于HTTP/1.1有如下性能上的改进：</p><ol><li><p><strong>头部压缩</strong></p><p>如果你同时发出多个请求，他们具有相同或相似的头部，那么HTTP/2会消除重复的部分。这就是所谓的<code class="language-plaintext highlighter-rouge">HPACK</code>算法：<strong>在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，之后就发送索引号，加快传输速度。</strong></p><li><p><strong>二进制格式</strong></p><p>区别于HTTP/1.1的纯文本形式的报文，HTTP/2采用二进制格式，头部信息和数据都是二进制格式，统称为帧，<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p>计算机在收到报文后，无需进行转换，可以直接解析二进制报文，增加了数据传输效率。</p><li><p><strong>并发传输</strong></p><p>HTTP/1.1是基于请求-响应模型的，同一个连接中，HTTP完成一个事物才能进行下一个，如果遇到响应迟迟不来，则会造成队头阻塞。</p><p>HTTP/2引出了Stream概念，多个Stream复用在一条TCP连接。一个TCP连接包含多个Stream，每个Stream里可以包含一个或多个Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）。</p><p><strong>针对不同的HTTP请求用独一无二的Stream ID来进行区分，接收端可以通过Stream ID来有序组装成HTTP消息，不同Stream的帧可以是乱序发送的，因此可以并发不同的Stream，即交错发送请求和相应。</strong></p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-0390350.jpeg" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/http2%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-0390350.jpeg" alt="img" class="lazyload" data-proofer-ignore></a></p><li><p><strong>服务器主动推送资源</strong></p><p>服务器不仅是被动的响应，而是可以主动向客户端发起信息。客户端和服务端都可以建立Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>比如客户端在请求HTML网页时，服务端可以主动推送css文件，减少通信次数。</p></ol><p>HTTP/2的缺陷有以下几点：</p><ul><li>HTTP/2在HTTP层面解决了请求和响应的阻塞问题，但是在TCP层面依然可能发生拥塞。<li>HTTP/2通过多个请求复用一个TCP连接，一旦发生TCP丢包，就会阻塞住所有的HTTP请求。</ul><p><strong>由于是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当前面的字节数据没有到达时，后收到的字节数据只能存放在内核缓冲区里</strong>，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</p><h4 id="http3"><span class="mr-2">HTTP/3</span><a href="#http3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>HTTP/2的队头阻塞是因为TCP，所以<strong>HTTP/3把HTTP下层的协议改成UDP</strong>。UDP协议可以不管发送顺序，也不用管丢包。不过，基于UDP的<strong>QUIC协议</strong>可以实现类似TCP的可靠传输。</p><p>QUIC协议有以下特点：</p><ol><li><p><strong>无队头阻塞</strong></p><p>QUIC协议也有类似HTTP/2 Stream的多路复用概念，也可以在同一条连接上并发传输多个Stream。QUIC也可以保证传输的可靠性，<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。而HTTP/2只要有一个流阻塞，那么整个TCP连接都会受到阻塞。</p><li><p><strong>更快的连接建立</strong></p><p>对于HTTP/1和HTTP/2协议，TCP和TLS是分层的，很难合并到一起，因此需要分批次握手，先TCP，再TLS。</p><p>HTTP/3在传输前虽然需要QUIC协议握手，但握手过程只需要1RTT，握手的目的是确认双方的连接ID，连接迁移就是基于连接ID实现的。</p><p>HTTP/3的QUIC协议并不与TLS协议分层，而是QUIC协议包含TLS，他自己的帧里会携带TLS的记录。</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/27-HTTP3-0450214.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/27-HTTP3-0450214.png" alt="HTTP/1 ~ HTTP/3" class="lazyload" data-proofer-ignore></a></p><li><p><strong>连接迁移</strong></p><p>基于TCP传输的HTTP协议由四元组来确定一条TCP连接，那么当用户切换网络，比如WIFI到蜂窝网络，那么IP地址就会发生变化，就必须断开重连，而重连过程中又涉及多次握手，就会有延迟，连接迁移的成本就会高。</p><p>而QUIC协议没有通过四元组的方式，而使用<strong>连接ID</strong>来标记通信的两个端点。客户端和服务端可以自行选择一组ID来表示自己，即使网络变化，只要仍保有上下文信息，就可以无缝切换连接。</p><p>QUIC是新协议，可能会有适配性问题，会被当作普通UDP。</p></ol><h3 id="7-http和https"><span class="mr-2">7. HTTP和HTTPS</span><a href="#7-http和https" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="两者的区别"><span class="mr-2">两者的区别</span><a href="#两者的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。<li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</ul><h4 id="https解决了http的哪些问题"><span class="mr-2">HTTPS解决了HTTP的哪些问题</span><a href="#https解决了http的哪些问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>HTTPS在HTTP与TCP层之间加入了SSL/TLS协议，可以很好的解决HTTP不安全的风险</p><ul><li><strong>信息加密</strong>：交互信息无法被窃取。<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示。<li><strong>身份证书</strong>：证明淘宝是真的淘宝网。</ul><p>HTTPS通过<strong>混合加密，摘要算法，数字证书</strong>来保证通信的安全。</p><ol><li><p><strong>混合加密</strong></p><p>通过混合加密的方式可以保证信息的机密性。HTTPS采用的是对称加密和非对称加密结合的<strong>混合加密</strong>方式：</p><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</ul><li><p><strong>摘要算法+数字签名</strong></p><p>为了保证内容不被篡改，我们要对内容计算出一个”指纹“，发给对方，然后对方收到后也对内容做一个“指纹”，与发来的指纹进行比较，来检查数据是否被篡改。</p><p><strong>在计算机中会用到摘要算法来计算出内容的哈希值</strong>，也就是内容的指纹。但是为了防止内容和指纹同时被篡改，要用到<strong>非对称加密算法</strong>来解决。一共有两个密钥，公钥和私钥。</p><p>这两个密钥是可以双向加解密的，公钥加密，私钥解密，是为了防止内容被篡改；而私钥加密，公钥解密是为了防止消息被冒充。但是一般不会用非对称加密直接加密内容，比较耗费性能。</p><p>所以非对称加密的用途主要在于<strong>通过「私钥加密，公钥解密」的方式，来确认消息的身份</strong>，我们常说的<strong>数字签名算法</strong>，就是用的是这种方式，不过私钥加密内容不是内容本身，而是<strong>对内容的哈希值加密</strong>。</p><li><p><strong>数字证书</strong></p><p>数字证书一般用来验证身份，其工作流程如下：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程" class="lazyload" data-proofer-ignore></a></p><p>首先，服务器会把自己的公钥注册到数字证书认证机构，数字证书认证机构会用自己的私钥将服务器的公钥加密做数字签名，然后颁发数字证书。客户端在向服务端请求的时候拿到服务器的数字证书，使用预先内置的数字证书认证机构的公钥来验证服务器数字证书的真实性。然后从数字证书中获得服务器的公钥加密报文。</p></ol><h4 id="https如何建立连接"><span class="mr-2">HTTPS如何建立连接</span><a href="#https如何建立连接" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>SSL/TLS协议基本流程：</p><ul><li>客户端向服务器索要并验证服务器的公钥。<li>双方协商生产「会话秘钥」。<li>双方采用「会话秘钥」进行加密通信。</ul><p>前两步就是SSL/TLS的握手阶段，TLS的握手阶段涉及四次通信。使用不同的密钥交换算法，握手流程也会不同。现在常用的密钥交换算法有两种：<strong>RSA算法和ECDHE算法</strong>。</p><p>基于RSA算法的TLS握手过程如下所示：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-0268478.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B-0268478.png" alt="HTTPS 连接建立过程" class="lazyload" data-proofer-ignore></a></p><p>详细流程如下：</p><ol><li><p><strong>ClientHello</strong></p><p>首先，由客户端向服务器发起 <code class="language-plaintext highlighter-rouge">ClientHello</code> 加密通信请求。</p><p>在这一步，客户端主要向服务器发送一下信息：</p><ul><li>客户端支持的TLS协议版本；<li>客户端产生的随机数，用于后续的会话加密；<li>客户端支持的密码套件，如RSA加密。</ul><li><p><strong>ServerHello</strong></p><p>服务端收到客户端请求后，向客户端发出响应，包含以下内容：</p><ul><li>确认TLS版本，如果浏览器不支持，则关闭加密通信；<li>服务器产生随机数，用于后面生成会话密钥；<li>确认的密码套件，如RSA；<li>服务器的数字证书。</ul><li><p><strong>客户端回应</strong></p><p>客户端在收到服务器的回应之后，首先通过浏览器或者操作系统中的CA公钥核实服务器数字证书的真实性。</p><p>如果证书没有问题，客户端就会从证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数，会被服务器公钥加密；<li>加密方法改变通知，表明之后都会用会话密钥加密通信；<li>客户端握手结束通知，表示客户端的握手阶段已经结束。同时把之前的数据做个摘要，用来供服务端校验。</ul><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><li><p><strong>服务端最后的回应</strong></p><p>服务端收到客户端的第三个随机数后，通过协商加密的算法，计算出本次通信的会话密钥；</p><p>然后，向客户端发送最后的消息：</p><ul><li>加密算法改变的通知；<li>服务器握手结束的通知，并将之前的数据做摘要给客户端校验。</ul></ol><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><h4 id="数字证书签发"><span class="mr-2">数字证书签发</span><a href="#数字证书签发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>数字证书的签发过程大致如下：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C-0301938.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E8%AF%81%E4%B9%A6%E7%9A%84%E6%A0%A1%E9%AA%8C-0301938.png" alt="img" class="lazyload" data-proofer-ignore></a></p><p>CA签发证书为上图左部分，首先CA会把持有者的公钥，用途，颁发者，过期时间等有效信息打包，对其进行Hash加密，将加密后的哈希值用自己的私钥进行加密，形成CA的认证签名。将信息和签名组合成证书。</p><p>而客户端在拿到签名后用公钥将CA的签名解密，得到Hash值，与证书中信息的Hash值进行比较，如果相同则校验通过。</p><p>证书一般有多个层级，是为了保证根证书的安全性。</p><h4 id="https应用数据如何保持完整性"><span class="mr-2">HTTPS应用数据如何保持完整性</span><a href="#https应用数据如何保持完整性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>TLS在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</p><ul><li>握手协议就是TLS的四次握手过程，负责协商加密算法和生成加密密钥；<li>记录协议负责保护应用数据并验证其完整性和来源，所以对HTTP数据加密使用的是记录协议。</ul><p>TLS记录协议主要负责消息的压缩，加密及数据的认证，过程如下：</p><p><a href="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE-0369425-0369446.png" class="popup img-link "><img data-src="/assets/blog_res/2023-03-16-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE-0369425-0369446.png" alt="img" class="lazyload" data-proofer-ignore></a></p><ul><li>首先，消息会被分成许多更短的片段，然后分别对每个片段进行压缩；<li>接下来，经过压缩的片段会被加上消息认证码（MAC值，由Hash算法生成），这是为了保证完整性，并进行数据认证。通过MAC码可以识别出篡改，其中包含片段编码以防止重放攻击；<li>经过压缩的片段再加上消息认证码一起被对称加密；<li>最后，经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</ul><h4 id="https安全性"><span class="mr-2">HTTPS安全性</span><a href="#https安全性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</p><p>HTTPS抓包能实现就是抓包软件让客户端信任了他自己签发的证书，从而实现解包。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-tag no-text-decoration" >计算机网络</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20Eraser&url=%2Fposts%2F%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20Eraser&u=%2Fposts%2F%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2F%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C%2F&text=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20Eraser" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/JAVA/">JAVA</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><li><a href="/posts/JVM/">JVM</a><li><a href="/posts/Spring/">Spring</a><li><a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs5289/">CS5289</a> <a class="post-tag" href="/tags/java/">JAVA</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/reactive-programming/">Reactive Programming</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/JAVA/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JAVA</h3><div class="text-muted small"><p> JAVA 基础 1. 面向对象 三大特性 Java有三大特性：封装，继承，多态。 封装：利用抽象数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据在被保护的抽象数据类型的内部，尽可能隐藏内部细节，只保留一些对外接口使之与外部发生联系，用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 继承：继承实现了IS-A关系，遵循里氏替换原则，即派生子类...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/"><div class="card-body"> <em class="small" data-ts="1647398040" data-df="YYYY/MM/DD" > 2022/03/16 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>数据库</h3><div class="text-muted small"><p> 数据库 MySQL 1. InnoDB引擎 MySQL支持数个存储引擎作为对不同表的类型的处理器。MySQL存储引擎包括处理事务安全表的引擎和处理非事务安全表的引擎。 MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。MyISAM在所有MySQL配置里被支持，它是MySQL之前的默认存储引擎。 MEMORY存储引擎提供”内存中”表。MERGE存储引擎允许集合...</p></div></div></a></div><div class="card"> <a href="/posts/JVM/"><div class="card-body"> <em class="small" data-ts="1647928800" data-df="YYYY/MM/DD" > 2022/03/22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JVM</h3><div class="text-muted small"><p> JVM 类加载 1. 类的生命周期 类加载的过程包括了加载，验证，准备，解析，初始化五个阶段。在这五个阶段中，加载，验证，准备和初始化这四个阶段发生的顺序是确定的，而解析阶段不一定。 加载 类的加载指查找并加载类的二进制数据。加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事： 通过一个类的全限定名来获取其定义的二进制字节流； 将这个字节流所代表的静...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="btn btn-outline-primary" prompt="上一篇"><p>数据库</p></a> <a href="/posts/JVM/" class="btn btn-outline-primary" prompt="下一篇"><p>JVM</p></a></div></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cs5289/">CS5289</a> <a class="post-tag" href="/tags/java/">JAVA</a> <a class="post-tag" href="/tags/jvm/">JVM</a> <a class="post-tag" href="/tags/reactive-programming/">Reactive Programming</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> <a class="post-tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/EraserE">Eraser</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0">本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
